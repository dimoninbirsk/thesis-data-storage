<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>Calc.cs</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cs">
<a name="ln1">using System.Buffers.Text;</a>
<a name="ln2">using System.Collections.ObjectModel;</a>
<a name="ln3">using System.Diagnostics.CodeAnalysis;</a>
<a name="ln4">using System.Globalization;</a>
<a name="ln5">using System.Numerics;</a>
<a name="ln6">using System.Reflection;</a>
<a name="ln7">using System.Runtime.InteropServices;</a>
<a name="ln8">using System.Text;</a>
<a name="ln9"> </a>
<a name="ln10">namespace Foster.Framework;</a>
<a name="ln11"> </a>
<a name="ln12">/// &lt;summary&gt;</a>
<a name="ln13">/// Utility Functions</a>
<a name="ln14">/// &lt;/summary&gt;</a>
<a name="ln15">public static class Calc</a>
<a name="ln16">{</a>
<a name="ln17">	#region Consts</a>
<a name="ln18"> </a>
<a name="ln19">	/// &lt;summary&gt;</a>
<a name="ln20">	/// PI in radians</a>
<a name="ln21">	/// &lt;/summary&gt;</a>
<a name="ln22">	public const float PI = MathF.PI;</a>
<a name="ln23"> </a>
<a name="ln24">	/// &lt;summary&gt;</a>
<a name="ln25">	/// Half PI in radians</a>
<a name="ln26">	/// &lt;/summary&gt;</a>
<a name="ln27">	public const float HalfPI = MathF.PI / 2f;</a>
<a name="ln28"> </a>
<a name="ln29">	/// &lt;summary&gt;</a>
<a name="ln30">	/// TAU (2-PI) in radians</a>
<a name="ln31">	/// &lt;/summary&gt;</a>
<a name="ln32">	public const float TAU = MathF.PI * 2f;</a>
<a name="ln33"> </a>
<a name="ln34">	/// &lt;summary&gt;</a>
<a name="ln35">	/// Converts Degrees to Radians</a>
<a name="ln36">	/// &lt;/summary&gt;</a>
<a name="ln37">	public const float DegToRad = (MathF.PI * 2) / 360f;</a>
<a name="ln38"> </a>
<a name="ln39">	/// &lt;summary&gt;</a>
<a name="ln40">	/// Converts Radians to Degrees</a>
<a name="ln41">	/// &lt;/summary&gt;</a>
<a name="ln42">	public const float RadToDeg = 360f / (MathF.PI * 2);</a>
<a name="ln43"> </a>
<a name="ln44">	public const float Right = 0;</a>
<a name="ln45">	public const float Left = PI;</a>
<a name="ln46">	public const float Up = PI + HalfPI;</a>
<a name="ln47">	public const float Down = HalfPI;</a>
<a name="ln48">	public const float UpRight = TAU - PI * 0.25f;</a>
<a name="ln49">	public const float DownRight = PI * 0.25f;</a>
<a name="ln50">	public const float UpLeft = TAU - PI * 0.75f;</a>
<a name="ln51">	public const float DownLeft = PI * 0.75f;</a>
<a name="ln52"> </a>
<a name="ln53">	#endregion</a>
<a name="ln54"> </a>
<a name="ln55">	#region Enums</a>
<a name="ln56"> </a>
<a name="ln57">	public static int EnumCount&lt;T&gt;() where T : struct, Enum</a>
<a name="ln58">		=&gt; Enum.GetValues&lt;T&gt;().Length;</a>
<a name="ln59"> </a>
<a name="ln60">	/// &lt;summary&gt;</a>
<a name="ln61">	/// Performantly convert an enum to int</a>
<a name="ln62">	/// &lt;/summary&gt;</a>
<a name="ln63">	public static unsafe int EnumAsInt&lt;TEnum&gt;(TEnum enumValue) where TEnum : unmanaged, Enum</a>
<a name="ln64">		=&gt; *(int*)(&amp;enumValue);</a>
<a name="ln65"> </a>
<a name="ln66">	#endregion</a>
<a name="ln67"> </a>
<a name="ln68">	#region Binary  Operations</a>
<a name="ln69"> </a>
<a name="ln70">	public static bool IsBitSet(byte b, int pos)</a>
<a name="ln71">		=&gt; (b &amp; (1 &lt;&lt; pos)) != 0;</a>
<a name="ln72"> </a>
<a name="ln73">	public static bool IsBitSet(int b, int pos)</a>
<a name="ln74">		=&gt; (b &amp; (1 &lt;&lt; pos)) != 0;</a>
<a name="ln75"> </a>
<a name="ln76">	#endregion</a>
<a name="ln77"> </a>
<a name="ln78">	#region Give Me</a>
<a name="ln79"> </a>
<a name="ln80">	public static T GiveMe&lt;T&gt;(int index, params ReadOnlySpan&lt;T&gt; choices)</a>
<a name="ln81">		=&gt; choices[index];</a>
<a name="ln82"> </a>
<a name="ln83">	#endregion</a>
<a name="ln84"> </a>
<a name="ln85">	#region Math</a>
<a name="ln86"> </a>
<a name="ln87">	public static float Avg(float a, float b)</a>
<a name="ln88">		=&gt; a + (b - a) * .5f;</a>
<a name="ln89"> </a>
<a name="ln90">	public static bool SignsMatch(float a, float b)</a>
<a name="ln91">		=&gt; Math.Sign(a) == Math.Sign(b);</a>
<a name="ln92"> </a>
<a name="ln93">	public static float Squared(this float v)</a>
<a name="ln94">		=&gt; v * v;</a>
<a name="ln95"> </a>
<a name="ln96">	/// &lt;summary&gt;</a>
<a name="ln97">	/// Get the area of a triangle</a>
<a name="ln98">	/// &lt;/summary&gt;</a>
<a name="ln99">	public static float TriangleArea(in Vector2 triA, in Vector2 triB, in Vector2 triC)</a>
<a name="ln100">		=&gt; MathF.Abs((triA.X * (triB.Y - triC.Y)</a>
<a name="ln101">					+ triB.X * (triC.Y - triA.Y)</a>
<a name="ln102">					+ triC.X * (triA.Y - triB.Y)) * .5f);</a>
<a name="ln103"> </a>
<a name="ln104">	/// &lt;summary&gt;</a>
<a name="ln105">	/// Get the cross product of two Vector2s, ie. (a.X * b.Y) - (a.Y * b.X)</a>
<a name="ln106">	/// &lt;/summary&gt;</a>
<a name="ln107">	public static float Cross(in Vector2 a, in Vector2 b)</a>
<a name="ln108">		=&gt; (a.X * b.Y) - (a.Y * b.X);</a>
<a name="ln109"> </a>
<a name="ln110">	/// &lt;summary&gt;</a>
<a name="ln111">	/// Get the integral sign of the cross product of two Vector2s</a>
<a name="ln112">	/// &lt;/summary&gt;</a>
<a name="ln113">	public static int SignCross(in Vector2 a, in Vector2 b)</a>
<a name="ln114">		=&gt; MathF.Sign(Cross(a, b));</a>
<a name="ln115"> </a>
<a name="ln116">	/// &lt;summary&gt;</a>
<a name="ln117">	/// Get whether the sequence of points takes a right- or left-hand turn (-1 or 1 respectively, or 0 for no turn)</a>
<a name="ln118">	/// &lt;/summary&gt;</a>
<a name="ln119">	public static int Orient(in Vector2 pA, in Vector2 pB, in Vector2 pC)</a>
<a name="ln120">		=&gt; SignCross(new(pB.X - pA.X, pB.Y - pA.Y), new(pC.X - pA.X, pC.Y - pA.Y));</a>
<a name="ln121"> </a>
<a name="ln122">	/// &lt;summary&gt;</a>
<a name="ln123">	/// Gets whether the triangle contains the point</a>
<a name="ln124">	/// &lt;/summary&gt;</a>
<a name="ln125">	public static bool TriangleContainsPoint(in Vector2 triA, in Vector2 triB, in Vector2 triC, in Vector2 point)</a>
<a name="ln126">		=&gt; Math.Abs(Orient(triA, triB, point)</a>
<a name="ln127">			+ Orient(triB, triC, point)</a>
<a name="ln128">			+ Orient(triC, triA, point)) == 3;</a>
<a name="ln129"> </a>
<a name="ln130">	public static float AbsDot(Vector2 a, Vector2 b)</a>
<a name="ln131">		=&gt; MathF.Abs(Vector2.Dot(a, b));</a>
<a name="ln132"> </a>
<a name="ln133">	public static T Min&lt;T&gt;(T a, T b) where T : IComparable&lt;T&gt;</a>
<a name="ln134">		=&gt; a.CompareTo(b) &lt; 0 ? a : b;</a>
<a name="ln135"> </a>
<a name="ln136">	public static T Min&lt;T&gt;(T a, T b, T c) where T : IComparable&lt;T&gt;</a>
<a name="ln137">		=&gt; Min(Min(a, b), c);</a>
<a name="ln138"> </a>
<a name="ln139">	public static T Min&lt;T&gt;(T a, T b, T c, T d) where T : IComparable&lt;T&gt;</a>
<a name="ln140">		=&gt; Min(Min(Min(a, b), c), d);</a>
<a name="ln141"> </a>
<a name="ln142">	public static T Max&lt;T&gt;(T a, T b) where T : IComparable&lt;T&gt;</a>
<a name="ln143">		=&gt; a.CompareTo(b) &gt; 0 ? a : b;</a>
<a name="ln144"> </a>
<a name="ln145">	public static T Max&lt;T&gt;(T a, T b, T c) where T : IComparable&lt;T&gt;</a>
<a name="ln146">		=&gt; Max(Max(a, b), c);</a>
<a name="ln147"> </a>
<a name="ln148">	public static T Max&lt;T&gt;(T a, T b, T c, T d) where T : IComparable&lt;T&gt;</a>
<a name="ln149">		=&gt; Max(Max(Max(a, b), c), d);</a>
<a name="ln150"> </a>
<a name="ln151">	/// &lt;summary&gt;</a>
<a name="ln152">	/// Move toward a target value without passing it</a>
<a name="ln153">	/// &lt;/summary&gt;</a>
<a name="ln154">	public static float Approach(float from, float target, float amount)</a>
<a name="ln155">	{</a>
<a name="ln156">		if (from &gt; target)</a>
<a name="ln157">			return Math.Max(from - amount, target);</a>
<a name="ln158">		else</a>
<a name="ln159">			return Math.Min(from + amount, target);</a>
<a name="ln160">	}</a>
<a name="ln161"> </a>
<a name="ln162">	/// &lt;summary&gt;</a>
<a name="ln163">	/// Move toward a target value without passing it</a>
<a name="ln164">	/// &lt;/summary&gt;</a>
<a name="ln165">	public static float Approach(ref float from, float target, float amount)</a>
<a name="ln166">	{</a>
<a name="ln167">		if (from &gt; target)</a>
<a name="ln168">			return from = Math.Max(from - amount, target);</a>
<a name="ln169">		else</a>
<a name="ln170">			return from = Math.Min(from + amount, target);</a>
<a name="ln171">	}</a>
<a name="ln172"> </a>
<a name="ln173">	/// &lt;summary&gt;</a>
<a name="ln174">	/// Move toward a target value without passing it, and only if we have the opposite sign or lower magnitude</a>
<a name="ln175">	/// &lt;/summary&gt;</a>
<a name="ln176">	public static float ApproachIfLower(float from, float target, float amount)</a>
<a name="ln177">	{</a>
<a name="ln178">		if (Math.Sign(from) != Math.Sign(target) || Math.Abs(from) &lt; Math.Abs(target))</a>
<a name="ln179">			return Approach(from, target, amount);</a>
<a name="ln180">		else</a>
<a name="ln181">			return from;</a>
<a name="ln182">	}</a>
<a name="ln183"> </a>
<a name="ln184">	/// &lt;summary&gt;</a>
<a name="ln185">	/// Move toward a target value without passing it, and only if we have the opposite sign or lower magnitude</a>
<a name="ln186">	/// &lt;/summary&gt;</a>
<a name="ln187">	public static float ApproachIfLower(ref float from, float target, float amount)</a>
<a name="ln188">	{</a>
<a name="ln189">		if (Math.Sign(from) != Math.Sign(target) || Math.Abs(from) &lt; Math.Abs(target))</a>
<a name="ln190">			return Approach(ref from, target, amount);</a>
<a name="ln191">		else</a>
<a name="ln192">			return from;</a>
<a name="ln193">	}</a>
<a name="ln194"> </a>
<a name="ln195">	public static Vector2 Approach(Vector2 from, Vector2 target, float amount)</a>
<a name="ln196">	{</a>
<a name="ln197">		if (from == target)</a>
<a name="ln198">			return target;</a>
<a name="ln199">		else</a>
<a name="ln200">		{</a>
<a name="ln201">			var diff = target - from;</a>
<a name="ln202">			if (diff.LengthSquared() &lt;= amount * amount)</a>
<a name="ln203">				return target;</a>
<a name="ln204">			else</a>
<a name="ln205">				return from + diff.Normalized() * amount;</a>
<a name="ln206">		}</a>
<a name="ln207">	}</a>
<a name="ln208"> </a>
<a name="ln209">	public static Vector2 Approach(ref Vector2 from, Vector2 target, float amount)</a>
<a name="ln210">	{</a>
<a name="ln211">		if (from == target)</a>
<a name="ln212">			return target;</a>
<a name="ln213">		else</a>
<a name="ln214">		{</a>
<a name="ln215">			var diff = target - from;</a>
<a name="ln216">			if (diff.LengthSquared() &lt;= amount * amount)</a>
<a name="ln217">				return from = target;</a>
<a name="ln218">			else</a>
<a name="ln219">				return from += diff.Normalized() * amount;</a>
<a name="ln220">		}</a>
<a name="ln221">	}</a>
<a name="ln222"> </a>
<a name="ln223">	public static Vector2 RotateToward(Vector2 dir, Vector2 target, float maxAngleDelta, float maxMagnitudeDelta)</a>
<a name="ln224">	{</a>
<a name="ln225">		float angle = dir.Angle();</a>
<a name="ln226">		float len = dir.Length();</a>
<a name="ln227"> </a>
<a name="ln228">		if (maxAngleDelta &gt; 0f)</a>
<a name="ln229">			angle = AngleApproach(angle, target.Angle(), maxAngleDelta);</a>
<a name="ln230"> </a>
<a name="ln231">		if (maxMagnitudeDelta &gt; 0f)</a>
<a name="ln232">			len = Approach(len, target.Length(), maxMagnitudeDelta);</a>
<a name="ln233"> </a>
<a name="ln234">		return AngleToVector(angle, len);</a>
<a name="ln235">	}</a>
<a name="ln236"> </a>
<a name="ln237">	/// &lt;summary&gt;</a>
<a name="ln238">	/// Clamps a number between two values</a>
<a name="ln239">	/// &lt;/summary&gt;</a>
<a name="ln240">	public static int Clamp(int value, int min, int max)</a>
<a name="ln241">	{</a>
<a name="ln242">		return Math.Min(Math.Max(value, min), max);</a>
<a name="ln243">	}</a>
<a name="ln244"> </a>
<a name="ln245">	/// &lt;summary&gt;</a>
<a name="ln246">	/// Clamps a number between two values</a>
<a name="ln247">	/// &lt;/summary&gt;</a>
<a name="ln248">	public static float Clamp(float value, float min, float max)</a>
<a name="ln249">	{</a>
<a name="ln250">		return Math.Min(Math.Max(value, min), max);</a>
<a name="ln251">	}</a>
<a name="ln252"> </a>
<a name="ln253">	/// &lt;summary&gt;</a>
<a name="ln254">	/// Clamps a number between 0 and 1</a>
<a name="ln255">	/// &lt;/summary&gt;</a>
<a name="ln256">	public static float Clamp(float value)</a>
<a name="ln257">	{</a>
<a name="ln258">		return Math.Min(Math.Max(value, 0), 1);</a>
<a name="ln259">	}</a>
<a name="ln260"> </a>
<a name="ln261">	/// &lt;summary&gt;</a>
<a name="ln262">	/// Shorthand to MathF.Round but returns an Integer</a>
<a name="ln263">	/// &lt;/summary&gt;</a>
<a name="ln264">	public static int Round(float v) =&gt; (int)MathF.Round(v);</a>
<a name="ln265"> </a>
<a name="ln266">	/// &lt;summary&gt;</a>
<a name="ln267">	/// Shorthand to MathF.Floor but returns an Integer</a>
<a name="ln268">	/// &lt;/summary&gt;</a>
<a name="ln269">	public static int Floor(float v) =&gt; (int)MathF.Floor(v);</a>
<a name="ln270"> </a>
<a name="ln271">	/// &lt;summary&gt;</a>
<a name="ln272">	/// Shorthand to MathF.Ceiling but returns an Integer</a>
<a name="ln273">	/// &lt;/summary&gt;</a>
<a name="ln274">	public static int Ceil(float v) =&gt; (int)MathF.Ceiling(v);</a>
<a name="ln275"> </a>
<a name="ln276">	/// &lt;summary&gt;</a>
<a name="ln277">	/// Converts a value from 0 to 1, to 0 to 1 to 0</a>
<a name="ln278">	/// &lt;/summary&gt;</a>
<a name="ln279">	public static float YoYo(float value)</a>
<a name="ln280">	{</a>
<a name="ln281">		if (value &lt;= .5f)</a>
<a name="ln282">			return value * 2;</a>
<a name="ln283">		else</a>
<a name="ln284">			return 1 - ((value - .5f) * 2);</a>
<a name="ln285">	}</a>
<a name="ln286"> </a>
<a name="ln287">	/// &lt;summary&gt;</a>
<a name="ln288">	/// Remaps a value from min-max, to newMin-newMax</a>
<a name="ln289">	/// &lt;/summary&gt;</a>
<a name="ln290">	public static float Map(float val, float min, float max, float newMin = 0, float newMax = 1)</a>
<a name="ln291">		=&gt; ((val - min) / (max - min)) * (newMax - newMin) + newMin;</a>
<a name="ln292"> </a>
<a name="ln293">	/// &lt;summary&gt;</a>
<a name="ln294">	/// Remaps a value from min-max, to newMin-newMax, but clamps the value within the given range</a>
<a name="ln295">	/// &lt;/summary&gt;</a>
<a name="ln296">	public static float ClampedMap(float val, float min, float max, float newMin = 0, float newMax = 1)</a>
<a name="ln297">		=&gt; Clamp((val - min) / (max - min), 0, 1) * (newMax - newMin) + newMin;</a>
<a name="ln298"> </a>
<a name="ln299">	/// &lt;summary&gt;</a>
<a name="ln300">	/// Remaps the given Sin(radians) value</a>
<a name="ln301">	/// &lt;/summary&gt;</a>
<a name="ln302">	public static float SineMap(float radians, float newMin, float newMax)</a>
<a name="ln303">		=&gt; Map(MathF.Sin(radians), -1, 1, newMin, newMax);</a>
<a name="ln304"> </a>
<a name="ln305">	public static float Angle(Vector2 vec)</a>
<a name="ln306">		=&gt; MathF.Atan2(vec.Y, vec.X);</a>
<a name="ln307"> </a>
<a name="ln308">	public static float Angle(Vector2 from, Vector2 to)</a>
<a name="ln309">		=&gt; MathF.Atan2(to.Y - from.Y, to.X - from.X);</a>
<a name="ln310"> </a>
<a name="ln311">	public static Vector2 AngleToVector(float angle, float length = 1)</a>
<a name="ln312">		=&gt; new (MathF.Cos(angle) * length, MathF.Sin(angle) * length);</a>
<a name="ln313"> </a>
<a name="ln314">	public static float AngleApproach(float val, float target, float maxMove)</a>
<a name="ln315">	{</a>
<a name="ln316">		var diff = AngleDiff(val, target);</a>
<a name="ln317">		if (Math.Abs(diff) &lt; maxMove)</a>
<a name="ln318">			return target;</a>
<a name="ln319">		return val + Clamp(diff, -maxMove, maxMove);</a>
<a name="ln320">	}</a>
<a name="ln321"> </a>
<a name="ln322">	public static float AngleLerp(float startAngle, float endAngle, float percent)</a>
<a name="ln323">		=&gt; startAngle + AngleDiff(startAngle, endAngle) * percent;</a>
<a name="ln324"> </a>
<a name="ln325">	public static float AngleDiff(float radiansA, float radiansB)</a>
<a name="ln326">		=&gt; ((radiansB - radiansA - PI) % TAU + TAU) % TAU - PI;</a>
<a name="ln327"> </a>
<a name="ln328">	public static float AbsAngleDiff(float radiansA, float radiansB)</a>
<a name="ln329">		=&gt; MathF.Abs(AngleDiff(radiansA, radiansB));</a>
<a name="ln330"> </a>
<a name="ln331">	public static float AngleWrap(float radians)</a>
<a name="ln332">		=&gt; (radians + TAU) % TAU;</a>
<a name="ln333"> </a>
<a name="ln334">	public static float AngleReflectOnX(float radians)</a>
<a name="ln335">		=&gt; AngleWrap(-radians);</a>
<a name="ln336"> </a>
<a name="ln337">	public static float AngleReflectOnY(float radians)</a>
<a name="ln338">		=&gt; AngleWrap(HalfPI - (radians - HalfPI));</a>
<a name="ln339"> </a>
<a name="ln340">	public static bool OnInterval(float value, float prevValue, float interval, float offset = 0)</a>
<a name="ln341">	{</a>
<a name="ln342">		var last = ((prevValue - offset) / interval);</a>
<a name="ln343">		var next = ((value - offset) / interval);</a>
<a name="ln344">		return last != next;</a>
<a name="ln345">	}</a>
<a name="ln346"> </a>
<a name="ln347">	public static int NextPowerOfTwo(int x)</a>
<a name="ln348">	{</a>
<a name="ln349">		x--;</a>
<a name="ln350">		x |= x &gt;&gt; 1;</a>
<a name="ln351">		x |= x &gt;&gt; 2;</a>
<a name="ln352">		x |= x &gt;&gt; 4;</a>
<a name="ln353">		x |= x &gt;&gt; 8;</a>
<a name="ln354">		x |= x &gt;&gt; 16;</a>
<a name="ln355">		x++;</a>
<a name="ln356">		return x;</a>
<a name="ln357">	}</a>
<a name="ln358"> </a>
<a name="ln359">	// TODO: should this use float.Epsilon?</a>
<a name="ln360">	public static bool Approx(float a, float b)</a>
<a name="ln361">		=&gt; MathF.Abs(a - b) &lt;= 0.001f;</a>
<a name="ln362"> </a>
<a name="ln363">	public static IReadOnlyList&lt;Point2&gt; GetBresenhamsLine(Point2 a, Point2 b)</a>
<a name="ln364">	{</a>
<a name="ln365">		var list = FramePool&lt;List&lt;Point2&gt;&gt;.Get();</a>
<a name="ln366"> </a>
<a name="ln367">		bool steep = Math.Abs(b.Y - a.Y) &gt; Math.Abs(b.X - a.X);</a>
<a name="ln368">		if (steep)</a>
<a name="ln369">		{</a>
<a name="ln370">			Swap(ref a.X, ref a.Y);</a>
<a name="ln371">			Swap(ref b.X, ref b.Y);</a>
<a name="ln372">		}</a>
<a name="ln373">		if (a.X &gt; b.X)</a>
<a name="ln374">		{</a>
<a name="ln375">			Swap(ref a.X, ref b.X);</a>
<a name="ln376">			Swap(ref a.Y, ref b.Y);</a>
<a name="ln377">		}</a>
<a name="ln378">		int dx = b.X - a.X;</a>
<a name="ln379">		int dy = Math.Abs(b.Y - a.Y);</a>
<a name="ln380">		int error = dx / 2;</a>
<a name="ln381">		int ystep = (a.Y &lt; b.Y) ? 1 : -1;</a>
<a name="ln382">		int y = a.Y;</a>
<a name="ln383"> </a>
<a name="ln384">		for (int x = a.X; x &lt;= b.X; x++)</a>
<a name="ln385">		{</a>
<a name="ln386">			list.Add(new(steep ? y : x, steep ? x : y));</a>
<a name="ln387">			error -= dy;</a>
<a name="ln388">			if (error &lt; 0)</a>
<a name="ln389">			{</a>
<a name="ln390">				y += ystep;</a>
<a name="ln391">				error += dx;</a>
<a name="ln392">			}</a>
<a name="ln393">		}</a>
<a name="ln394"> </a>
<a name="ln395">		return list;</a>
<a name="ln396">	}</a>
<a name="ln397"> </a>
<a name="ln398">	#endregion</a>
<a name="ln399"> </a>
<a name="ln400">	#region Triangulation</a>
<a name="ln401"> </a>
<a name="ln402">	public static void Triangulate(IList&lt;Vector2&gt; points, List&lt;int&gt; populate)</a>
<a name="ln403">	{</a>
<a name="ln404">		float Area()</a>
<a name="ln405">		{</a>
<a name="ln406">			var area = 0f;</a>
<a name="ln407"> </a>
<a name="ln408">			for (int p = points.Count - 1, q = 0; q &lt; points.Count; p = q++)</a>
<a name="ln409">			{</a>
<a name="ln410">				var pval = points[p];</a>
<a name="ln411">				var qval = points[q];</a>
<a name="ln412"> </a>
<a name="ln413">				area += pval.X * qval.Y - qval.X * pval.Y;</a>
<a name="ln414">			}</a>
<a name="ln415"> </a>
<a name="ln416">			return area * 0.5f;</a>
<a name="ln417">		}</a>
<a name="ln418"> </a>
<a name="ln419">		bool Snip(int u, int v, int w, int n, Span&lt;int&gt; list)</a>
<a name="ln420">		{</a>
<a name="ln421">			var a = points[list[u]];</a>
<a name="ln422">			var b = points[list[v]];</a>
<a name="ln423">			var c = points[list[w]];</a>
<a name="ln424"> </a>
<a name="ln425">			if (float.Epsilon &gt; (((b.X - a.X) * (c.Y - a.Y)) - ((b.Y - a.Y) * (c.X - a.X))))</a>
<a name="ln426">				return false;</a>
<a name="ln427"> </a>
<a name="ln428">			for (int p = 0; p &lt; n; p++)</a>
<a name="ln429">			{</a>
<a name="ln430">				if ((p == u) || (p == v) || (p == w))</a>
<a name="ln431">					continue;</a>
<a name="ln432"> </a>
<a name="ln433">				if (InsideTriangle(a, b, c, points[list[p]]))</a>
<a name="ln434">					return false;</a>
<a name="ln435">			}</a>
<a name="ln436"> </a>
<a name="ln437">			return true;</a>
<a name="ln438">		}</a>
<a name="ln439"> </a>
<a name="ln440">		if (points.Count &lt; 3)</a>
<a name="ln441">			return;</a>
<a name="ln442"> </a>
<a name="ln443">		Span&lt;int&gt; list = points.Count &lt; 1000</a>
<a name="ln444">			? stackalloc int[points.Count]</a>
<a name="ln445">			: new int[points.Count];</a>
<a name="ln446"> </a>
<a name="ln447">		if (Area() &gt; 0)</a>
<a name="ln448">		{</a>
<a name="ln449">			for (int v = 0; v &lt; points.Count; v++)</a>
<a name="ln450">				list[v] = v;</a>
<a name="ln451">		}</a>
<a name="ln452">		else</a>
<a name="ln453">		{</a>
<a name="ln454">			for (int v = 0; v &lt; points.Count; v++)</a>
<a name="ln455">				list[v] = (points.Count - 1) - v;</a>
<a name="ln456">		}</a>
<a name="ln457"> </a>
<a name="ln458">		var nv = points.Count;</a>
<a name="ln459">		var count = 2 * nv;</a>
<a name="ln460"> </a>
<a name="ln461">		for (int v = nv - 1; nv &gt; 2;)</a>
<a name="ln462">		{</a>
<a name="ln463">			if ((count--) &lt;= 0)</a>
<a name="ln464">				return;</a>
<a name="ln465"> </a>
<a name="ln466">			var u = v;</a>
<a name="ln467">			if (nv &lt;= u)</a>
<a name="ln468">				u = 0;</a>
<a name="ln469">			v = u + 1;</a>
<a name="ln470">			if (nv &lt;= v)</a>
<a name="ln471">				v = 0;</a>
<a name="ln472">			var w = v + 1;</a>
<a name="ln473">			if (nv &lt;= w)</a>
<a name="ln474">				w = 0;</a>
<a name="ln475"> </a>
<a name="ln476">			if (Snip(u, v, w, nv, list))</a>
<a name="ln477">			{</a>
<a name="ln478">				populate.Add(list[u]);</a>
<a name="ln479">				populate.Add(list[v]);</a>
<a name="ln480">				populate.Add(list[w]);</a>
<a name="ln481"> </a>
<a name="ln482">				for (int s = v, t = v + 1; t &lt; nv; s++, t++)</a>
<a name="ln483">					list[s] = list[t];</a>
<a name="ln484"> </a>
<a name="ln485">				nv--;</a>
<a name="ln486">				count = 2 * nv;</a>
<a name="ln487">			}</a>
<a name="ln488">		}</a>
<a name="ln489"> </a>
<a name="ln490">		populate.Reverse();</a>
<a name="ln491">	}</a>
<a name="ln492"> </a>
<a name="ln493">	public static List&lt;int&gt; Triangulate(IList&lt;Vector2&gt; points)</a>
<a name="ln494">	{</a>
<a name="ln495">		var indices = new List&lt;int&gt;();</a>
<a name="ln496">		Triangulate(points, indices);</a>
<a name="ln497">		return indices;</a>
<a name="ln498">	}</a>
<a name="ln499"> </a>
<a name="ln500">	public static bool InsideTriangle(Vector2 a, Vector2 b, Vector2 c, Vector2 point)</a>
<a name="ln501">	{</a>
<a name="ln502">		var p0 = c - b;</a>
<a name="ln503">		var p1 = a - c;</a>
<a name="ln504">		var p2 = b - a;</a>
<a name="ln505"> </a>
<a name="ln506">		var ap = point - a;</a>
<a name="ln507">		var bp = point - b;</a>
<a name="ln508">		var cp = point - c;</a>
<a name="ln509"> </a>
<a name="ln510">		return (p0.X * bp.Y - p0.Y * bp.X &gt;= 0.0f) &amp;&amp;</a>
<a name="ln511">			   (p2.X * ap.Y - p2.Y * ap.X &gt;= 0.0f) &amp;&amp;</a>
<a name="ln512">			   (p1.X * cp.Y - p1.Y * cp.X &gt;= 0.0f);</a>
<a name="ln513">	}</a>
<a name="ln514"> </a>
<a name="ln515">	#endregion</a>
<a name="ln516"> </a>
<a name="ln517">	#region Parsing</a>
<a name="ln518"> </a>
<a name="ln519">	public static bool ParseVector2(ReadOnlySpan&lt;char&gt; span, char delimiter, out Vector2 vector)</a>
<a name="ln520">	{</a>
<a name="ln521">		vector = Vector2.Zero;</a>
<a name="ln522"> </a>
<a name="ln523">		var index = span.IndexOf(delimiter);</a>
<a name="ln524">		if (index &gt;= 0)</a>
<a name="ln525">		{</a>
<a name="ln526">			var x = span.Slice(0, index);</a>
<a name="ln527">			var y = span.Slice(index + 1);</a>
<a name="ln528"> </a>
<a name="ln529">			if (float.TryParse(x, NumberStyles.Float, CultureInfo.InvariantCulture, out vector.X) &amp;&amp;</a>
<a name="ln530">				float.TryParse(y, NumberStyles.Float, CultureInfo.InvariantCulture, out vector.Y))</a>
<a name="ln531">				return true;</a>
<a name="ln532">		}</a>
<a name="ln533"> </a>
<a name="ln534">		return false;</a>
<a name="ln535">	}</a>
<a name="ln536"> </a>
<a name="ln537">	public static bool ParseVector3(ReadOnlySpan&lt;char&gt; span, char deliminator, out Vector3 vector)</a>
<a name="ln538">	{</a>
<a name="ln539">		vector = Vector3.Zero;</a>
<a name="ln540"> </a>
<a name="ln541">		var index = span.IndexOf(deliminator);</a>
<a name="ln542">		if (index &gt; 0)</a>
<a name="ln543">		{</a>
<a name="ln544">			var first = span.Slice(0, index);</a>
<a name="ln545">			var remaining = span.Slice(index + 1);</a>
<a name="ln546"> </a>
<a name="ln547">			index = remaining.IndexOf(deliminator);</a>
<a name="ln548">			if (index &gt; 0)</a>
<a name="ln549">			{</a>
<a name="ln550">				var second = remaining.Slice(0, index);</a>
<a name="ln551">				var third = remaining.Slice(index + 1);</a>
<a name="ln552"> </a>
<a name="ln553">				if (float.TryParse(first, NumberStyles.Float, CultureInfo.InvariantCulture, out vector.X) &amp;&amp;</a>
<a name="ln554">					float.TryParse(second, NumberStyles.Float, CultureInfo.InvariantCulture, out vector.Y) &amp;&amp;</a>
<a name="ln555">					float.TryParse(third, NumberStyles.Float, CultureInfo.InvariantCulture, out vector.Z))</a>
<a name="ln556">					return true;</a>
<a name="ln557">			}</a>
<a name="ln558">		}</a>
<a name="ln559"> </a>
<a name="ln560">		return false;</a>
<a name="ln561">	}</a>
<a name="ln562"> </a>
<a name="ln563">	#endregion</a>
<a name="ln564"> </a>
<a name="ln565">	#region Utils</a>
<a name="ln566"> </a>
<a name="ln567">	/// &lt;summary&gt;</a>
<a name="ln568">	/// .NET Core doesn't always hash string values the same (it can seed it based on the running instance)</a>
<a name="ln569">	/// So this is to get a static value for every same string</a>
<a name="ln570">	/// &lt;/summary&gt;</a>
<a name="ln571">	public static int StaticStringHash(ReadOnlySpan&lt;char&gt; value)</a>
<a name="ln572">	{</a>
<a name="ln573">		unchecked</a>
<a name="ln574">		{</a>
<a name="ln575">			int hash = 5381;</a>
<a name="ln576">			for (int i = 0; i &lt; value.Length; i++)</a>
<a name="ln577">				hash = ((hash &lt;&lt; 5) + hash) + value[i];</a>
<a name="ln578">			return hash;</a>
<a name="ln579">		}</a>
<a name="ln580">	}</a>
<a name="ln581"> </a>
<a name="ln582">	public static int StaticStringHash(ReadOnlySpan&lt;byte&gt; value)</a>
<a name="ln583">	{</a>
<a name="ln584">		unchecked</a>
<a name="ln585">		{</a>
<a name="ln586">			int hash = 5381;</a>
<a name="ln587">			for (int i = 0; i &lt; value.Length; i++)</a>
<a name="ln588">				hash = ((hash &lt;&lt; 5) + hash) + value[i];</a>
<a name="ln589">			return hash;</a>
<a name="ln590">		}</a>
<a name="ln591">	}</a>
<a name="ln592"> </a>
<a name="ln593">	/// &lt;summary&gt;</a>
<a name="ln594">	/// Check if two UTF8 strings are equal, ingoring case</a>
<a name="ln595">	/// TODO: is there a built in C# way to do this?? this seems bad</a>
<a name="ln596">	/// &lt;/summary&gt;</a>
<a name="ln597">	public static bool EqualsOrdinalIgnoreCaseUtf8(ReadOnlySpan&lt;byte&gt; a, ReadOnlySpan&lt;byte&gt; b)</a>
<a name="ln598">	{</a>
<a name="ln599">		if (a.Length != b.Length)</a>
<a name="ln600">			return false;</a>
<a name="ln601"> </a>
<a name="ln602">		var charCountA = Encoding.UTF8.GetCharCount(a);</a>
<a name="ln603">		var charCountB = Encoding.UTF8.GetCharCount(b);</a>
<a name="ln604"> </a>
<a name="ln605">		if (charCountA != charCountB)</a>
<a name="ln606">			return false;</a>
<a name="ln607"> </a>
<a name="ln608">		Span&lt;char&gt; charsA = stackalloc char[charCountA];</a>
<a name="ln609">		Span&lt;char&gt; charsB = stackalloc char[charCountB];</a>
<a name="ln610">		Encoding.UTF8.GetChars(a, charsA);</a>
<a name="ln611">		Encoding.UTF8.GetChars(b, charsB);</a>
<a name="ln612"> </a>
<a name="ln613">		return MemoryExtensions.Equals(charsA, charsB, StringComparison.OrdinalIgnoreCase);</a>
<a name="ln614">	}</a>
<a name="ln615"> </a>
<a name="ln616">	/// &lt;summary&gt;</a>
<a name="ln617">	/// Returns the amount of characters the strings have in common starting from the start</a>
<a name="ln618">	/// &lt;/summary&gt;</a>
<a name="ln619">	public static int AmountInCommon(this string a, string b)</a>
<a name="ln620">	{</a>
<a name="ln621">		int i = 0;</a>
<a name="ln622">		for (; i &lt; a.Length &amp;&amp; i &lt; b.Length; i++)</a>
<a name="ln623">			if (a[i] != b[i])</a>
<a name="ln624">				break;</a>
<a name="ln625">		return i;</a>
<a name="ln626">	}</a>
<a name="ln627"> </a>
<a name="ln628">	public static string NormalizePath(string a, string b)</a>
<a name="ln629">	{</a>
<a name="ln630">		return NormalizePath(Path.Join(a, b));</a>
<a name="ln631">	}</a>
<a name="ln632"> </a>
<a name="ln633">	public static string NormalizePath(string a, string b, string c)</a>
<a name="ln634">	{</a>
<a name="ln635">		return NormalizePath(Path.Join(a, b, c));</a>
<a name="ln636">	}</a>
<a name="ln637"> </a>
<a name="ln638">	public static string NormalizePath(string path)</a>
<a name="ln639">	{</a>
<a name="ln640">		unsafe</a>
<a name="ln641">		{</a>
<a name="ln642">			Span&lt;char&gt; temp = stackalloc char[path.Length];</a>
<a name="ln643">			for (int i = 0; i &lt; path.Length; i++)</a>
<a name="ln644">				temp[i] = path[i];</a>
<a name="ln645">			return NormalizePath(temp).ToString();</a>
<a name="ln646">		}</a>
<a name="ln647">	}</a>
<a name="ln648"> </a>
<a name="ln649">	public static Span&lt;char&gt; NormalizePath(Span&lt;char&gt; path)</a>
<a name="ln650">	{</a>
<a name="ln651">		for (int i = 0; i &lt; path.Length; i++)</a>
<a name="ln652">			if (path[i] == '\\') path[i] = '/';</a>
<a name="ln653"> </a>
<a name="ln654">		int length = path.Length;</a>
<a name="ln655">		for (int i = 1, t = 1, l = length; t &lt; l; i++, t++)</a>
<a name="ln656">		{</a>
<a name="ln657">			if (path[t - 1] == '/' &amp;&amp; path[t] == '/')</a>
<a name="ln658">			{</a>
<a name="ln659">				i--;</a>
<a name="ln660">				length--;</a>
<a name="ln661">			}</a>
<a name="ln662">			else</a>
<a name="ln663">				path[i] = path[t];</a>
<a name="ln664">		}</a>
<a name="ln665"> </a>
<a name="ln666">		return path[..length];</a>
<a name="ln667">	}</a>
<a name="ln668"> </a>
<a name="ln669">	public static ReadOnlySpan&lt;byte&gt; ToBytes&lt;T&gt;(Span&lt;T&gt; span) where T : struct</a>
<a name="ln670">	{</a>
<a name="ln671">		return MemoryMarshal.Cast&lt;T, byte&gt;(span);</a>
<a name="ln672">	}</a>
<a name="ln673"> </a>
<a name="ln674">	public static bool TryFirst&lt;T&gt;(this List&lt;T&gt; list, Func&lt;T, bool&gt; predicate, [NotNullWhen(true)] out T? match) where T : class</a>
<a name="ln675">	{</a>
<a name="ln676">		foreach (var t in list)</a>
<a name="ln677">			if (predicate(t))</a>
<a name="ln678">			{</a>
<a name="ln679">				match = t;</a>
<a name="ln680">				return true;</a>
<a name="ln681">			}</a>
<a name="ln682"> </a>
<a name="ln683">		match = null;</a>
<a name="ln684">		return false;</a>
<a name="ln685">	}</a>
<a name="ln686"> </a>
<a name="ln687">	public static void Swap&lt;T&gt;(ref T a, ref T b)</a>
<a name="ln688">		=&gt; (b, a) = (a, b);</a>
<a name="ln689"> </a>
<a name="ln690">	#endregion</a>
<a name="ln691"> </a>
<a name="ln692">	#region Reflection</a>
<a name="ln693"> </a>
<a name="ln694">	public static bool HasAttr&lt;T&gt;(this MemberInfo member) where T : Attribute</a>
<a name="ln695">		=&gt; member.GetCustomAttribute&lt;T&gt;() != null;</a>
<a name="ln696"> </a>
<a name="ln697">	public static bool TryGetAttr&lt;T&gt;(this FieldInfo field, [NotNullWhen(true)] out T? attr) where T : Attribute</a>
<a name="ln698">		=&gt; (attr = field.GetCustomAttribute&lt;T&gt;()) != null;</a>
<a name="ln699"> </a>
<a name="ln700">	public static bool IsNullable(this PropertyInfo property) =&gt;</a>
<a name="ln701">		IsNullableHelper(property.PropertyType, property.DeclaringType, property.CustomAttributes);</a>
<a name="ln702"> </a>
<a name="ln703">	public static bool IsNullable(this FieldInfo field) =&gt;</a>
<a name="ln704">		IsNullableHelper(field.FieldType, field.DeclaringType, field.CustomAttributes);</a>
<a name="ln705"> </a>
<a name="ln706">	private static bool IsNullableHelper(Type memberType, MemberInfo? declaringType, IEnumerable&lt;CustomAttributeData&gt; customAttributes)</a>
<a name="ln707">	{</a>
<a name="ln708">		if (memberType.IsValueType)</a>
<a name="ln709">			return Nullable.GetUnderlyingType(memberType) != null;</a>
<a name="ln710"> </a>
<a name="ln711">		var nullable = customAttributes</a>
<a name="ln712">			.FirstOrDefault(x =&gt; x.AttributeType.FullName == &quot;System.Runtime.CompilerServices.NullableAttribute&quot;);</a>
<a name="ln713">		if (nullable != null &amp;&amp; nullable.ConstructorArguments.Count == 1)</a>
<a name="ln714">		{</a>
<a name="ln715">			var attributeArgument = nullable.ConstructorArguments[0];</a>
<a name="ln716">			if (attributeArgument.ArgumentType == typeof(byte[]))</a>
<a name="ln717">			{</a>
<a name="ln718">				var args = (ReadOnlyCollection&lt;CustomAttributeTypedArgument&gt;)attributeArgument.Value!;</a>
<a name="ln719">				if (args.Count &gt; 0 &amp;&amp; args[0].ArgumentType == typeof(byte))</a>
<a name="ln720">				{</a>
<a name="ln721">					return (byte)args[0].Value! == 2;</a>
<a name="ln722">				}</a>
<a name="ln723">			}</a>
<a name="ln724">			else if (attributeArgument.ArgumentType == typeof(byte))</a>
<a name="ln725">			{</a>
<a name="ln726">				return (byte)attributeArgument.Value! == 2;</a>
<a name="ln727">			}</a>
<a name="ln728">		}</a>
<a name="ln729"> </a>
<a name="ln730">		for (var type = declaringType; type != null; type = type.DeclaringType)</a>
<a name="ln731">		{</a>
<a name="ln732">			var context = type.CustomAttributes</a>
<a name="ln733">				.FirstOrDefault(x =&gt; x.AttributeType.FullName == &quot;System.Runtime.CompilerServices.NullableContextAttribute&quot;);</a>
<a name="ln734">			if (context != null &amp;&amp;</a>
<a name="ln735">				context.ConstructorArguments.Count == 1 &amp;&amp;</a>
<a name="ln736">				context.ConstructorArguments[0].ArgumentType == typeof(byte))</a>
<a name="ln737">			{</a>
<a name="ln738">				return (byte)context.ConstructorArguments[0].Value! == 2;</a>
<a name="ln739">			}</a>
<a name="ln740">		}</a>
<a name="ln741"> </a>
<a name="ln742">		// Couldn't find a suitable attribute</a>
<a name="ln743">		return false;</a>
<a name="ln744">	}</a>
<a name="ln745">	#endregion</a>
<a name="ln746"> </a>
<a name="ln747">	#region Interpolation</a>
<a name="ln748"> </a>
<a name="ln749">	public static float Lerp(float a, float b, float percent)</a>
<a name="ln750">		=&gt; (a + (b - a) * percent);</a>
<a name="ln751"> </a>
<a name="ln752">	public static float Bezier(float a, float b, float c, float t)</a>
<a name="ln753">		=&gt; Lerp(Lerp(a, b, t), Lerp(b, c, t), t);</a>
<a name="ln754"> </a>
<a name="ln755">	public static float Bezier(float a, float b, float c, float d, float t)</a>
<a name="ln756">		=&gt; Bezier(Lerp(a, b, t), Lerp(b, c, t), Lerp(c, d, t), t);</a>
<a name="ln757"> </a>
<a name="ln758">	public static Vector2 Bezier(Vector2 a, Vector2 b, Vector2 c, float t)</a>
<a name="ln759">		=&gt; Vector2.Lerp(Vector2.Lerp(a, b, t), Vector2.Lerp(b, c, t), t);</a>
<a name="ln760"> </a>
<a name="ln761">	public static Vector2 Bezier(Vector2 a, Vector2 b, Vector2 c, Vector2 d, float t)</a>
<a name="ln762">		=&gt; Bezier(Vector2.Lerp(a, b, t), Vector2.Lerp(b, c, t), Vector2.Lerp(c, d, t), t);</a>
<a name="ln763"> </a>
<a name="ln764">	public static float SmoothDamp(float current, float target, ref float velocity, float smoothTime, float maxSpeed, float deltaTime)</a>
<a name="ln765">	{</a>
<a name="ln766">		smoothTime = Math.Max(0.0001f, smoothTime);</a>
<a name="ln767">		float omega = 2f / smoothTime;</a>
<a name="ln768">		float x = omega * deltaTime;</a>
<a name="ln769">		float exp = 1f / (1f + x + 0.48f * x * x + 0.235f * x * x * x);</a>
<a name="ln770">		float change = current - target;</a>
<a name="ln771">		float origTo = target;</a>
<a name="ln772">		float maxChange = maxSpeed * smoothTime;</a>
<a name="ln773">		change = Math.Clamp(change, -maxChange, maxChange);</a>
<a name="ln774">		target = current - change;</a>
<a name="ln775">		float temp = (velocity + omega * change) * deltaTime;</a>
<a name="ln776">		velocity = (velocity - omega * temp) * exp;</a>
<a name="ln777">		float output = target + (change + temp) * exp;</a>
<a name="ln778">		if (origTo - current &gt; 0f == output &gt; origTo)</a>
<a name="ln779">		{</a>
<a name="ln780">			output = origTo;</a>
<a name="ln781">			velocity = (output - origTo) / deltaTime;</a>
<a name="ln782">		}</a>
<a name="ln783">		return output;</a>
<a name="ln784">	}</a>
<a name="ln785"> </a>
<a name="ln786">	#endregion</a>
<a name="ln787"> </a>
<a name="ln788">	#region Snap</a>
<a name="ln789"> </a>
<a name="ln790">	/// &lt;summary&gt;</a>
<a name="ln791">	/// Round the value to the nearest interval. Eg: Snap(2.2, 1.2) = 2.4</a>
<a name="ln792">	/// &lt;/summary&gt;</a>
<a name="ln793">	public static float Snap(float value, float snapTo)</a>
<a name="ln794">		=&gt; MathF.Round(value / snapTo) * snapTo;</a>
<a name="ln795"> </a>
<a name="ln796">	/// &lt;summary&gt;</a>
<a name="ln797">	/// Round the value to the nearest interval. Eg: Snap(3.2, 2) = 4</a>
<a name="ln798">	/// &lt;/summary&gt;</a>
<a name="ln799">	public static int Snap(float value, int snapTo)</a>
<a name="ln800">		=&gt; Round(value / snapTo) * snapTo;</a>
<a name="ln801"> </a>
<a name="ln802">	/// &lt;summary&gt;</a>
<a name="ln803">	/// Round the vector to the nearest intervals. Eg: Snap([0.8, 1.9], [1.2, 1.2]) = [1.2, 2.4]</a>
<a name="ln804">	/// &lt;/summary&gt;</a>
<a name="ln805">	public static Vector2 Snap(Vector2 value, Vector2 snapTo)</a>
<a name="ln806">		=&gt; new(Snap(value.X, snapTo.X), Snap(value.Y, snapTo.Y));</a>
<a name="ln807"> </a>
<a name="ln808">	/// &lt;summary&gt;</a>
<a name="ln809">	/// Round the vector to the nearest intervals. Eg: Snap([0.8, 1.6], [1, 1]) = [1, 2]</a>
<a name="ln810">	/// &lt;/summary&gt;</a>
<a name="ln811">	public static Point2 Snap(Vector2 value, Point2 snapTo)</a>
<a name="ln812">		=&gt; new(Snap(value.X, snapTo.X), Snap(value.Y, snapTo.Y));</a>
<a name="ln813"> </a>
<a name="ln814">	/// &lt;summary&gt;</a>
<a name="ln815">	/// Round the vector to the nearest interval on both axes. Eg: Snap([0.8, 1.9], 1.2) = [1.2, 2.4]</a>
<a name="ln816">	/// &lt;/summary&gt;</a>
<a name="ln817">	public static Vector2 Snap(Vector2 value, float snapTo)</a>
<a name="ln818">		=&gt; new(Snap(value.X, snapTo), Snap(value.Y, snapTo));</a>
<a name="ln819"> </a>
<a name="ln820">	/// &lt;summary&gt;</a>
<a name="ln821">	/// Round the vector to the nearest interval on both axes. Eg: Snap([0.8, 1.6], 1) = [1, 2]</a>
<a name="ln822">	/// &lt;/summary&gt;</a>
<a name="ln823">	public static Point2 Snap(Vector2 value, int snapTo)</a>
<a name="ln824">		=&gt; new(Snap(value.X, snapTo), Snap(value.Y, snapTo));</a>
<a name="ln825"> </a>
<a name="ln826">	/// &lt;summary&gt;</a>
<a name="ln827">	/// Floor the value to the nearest interval. Eg: SnapFloor(2.2, 1.2) = 1.2</a>
<a name="ln828">	/// &lt;/summary&gt;</a>
<a name="ln829">	public static float SnapFloor(float value, float snapTo)</a>
<a name="ln830">		=&gt; MathF.Floor(value / snapTo) * snapTo;</a>
<a name="ln831"> </a>
<a name="ln832">	/// &lt;summary&gt;</a>
<a name="ln833">	/// Floor the value to the nearest interval. Eg: SnapFloor(3.2, 2) = 2</a>
<a name="ln834">	/// &lt;/summary&gt;</a>
<a name="ln835">	public static int SnapFloor(float value, int snapTo)</a>
<a name="ln836">		=&gt; Floor(value / snapTo) * snapTo;</a>
<a name="ln837"> </a>
<a name="ln838">	/// &lt;summary&gt;</a>
<a name="ln839">	/// Floor the vector to the nearest intervals. Eg: SnapFloor([0.8, 2.3], [0, 1.2]) = [1.2, 1.2]</a>
<a name="ln840">	/// &lt;/summary&gt;</a>
<a name="ln841">	public static Vector2 SnapFloor(Vector2 value, Vector2 snapTo)</a>
<a name="ln842">		=&gt; new(SnapFloor(value.X, snapTo.X), SnapFloor(value.Y, snapTo.Y));</a>
<a name="ln843"> </a>
<a name="ln844">	/// &lt;summary&gt;</a>
<a name="ln845">	/// Floor the vector to the nearest intervals. Eg: SnapFloor([0.8, 1.6], [1, 1]) = [0, 1]</a>
<a name="ln846">	/// &lt;/summary&gt;</a>
<a name="ln847">	public static Point2 SnapFloor(Vector2 value, Point2 snapTo)</a>
<a name="ln848">		=&gt; new(SnapFloor(value.X, snapTo.X), SnapFloor(value.Y, snapTo.Y));</a>
<a name="ln849"> </a>
<a name="ln850">	/// &lt;summary&gt;</a>
<a name="ln851">	/// Floor the vector to the nearest interval on both axes. Eg: SnapFloor([0.8, 2.3], 1.2) = [0, 1.2]</a>
<a name="ln852">	/// &lt;/summary&gt;</a>
<a name="ln853">	public static Vector2 SnapFloor(Vector2 value, float snapTo)</a>
<a name="ln854">		=&gt; new(SnapFloor(value.X, snapTo), SnapFloor(value.Y, snapTo));</a>
<a name="ln855"> </a>
<a name="ln856">	/// &lt;summary&gt;</a>
<a name="ln857">	/// Floor the vector to the nearest interval on both axes. Eg: SnapFloor([0.8, 1.6], 1) = [0, 1]</a>
<a name="ln858">	/// &lt;/summary&gt;</a>
<a name="ln859">	public static Point2 SnapFloor(Vector2 value, int snapTo)</a>
<a name="ln860">		=&gt; new(SnapFloor(value.X, snapTo), SnapFloor(value.Y, snapTo));</a>
<a name="ln861"> </a>
<a name="ln862">	/// &lt;summary&gt;</a>
<a name="ln863">	/// Ceil the value to the nearest interval. Eg: SnapCeil(1.4, 1.2) = 2.4</a>
<a name="ln864">	/// &lt;/summary&gt;</a>
<a name="ln865">	public static float SnapCeil(float value, float snapTo)</a>
<a name="ln866">		=&gt; MathF.Ceiling(value / snapTo) * snapTo;</a>
<a name="ln867"> </a>
<a name="ln868">	/// &lt;summary&gt;</a>
<a name="ln869">	/// Ceil the value to the nearest interval. Eg: SnapCeil(2.2, 2) = 4</a>
<a name="ln870">	/// &lt;/summary&gt;</a>
<a name="ln871">	public static int SnapCeil(float value, int snapTo)</a>
<a name="ln872">		=&gt; Ceil(value / snapTo) * snapTo;</a>
<a name="ln873"> </a>
<a name="ln874">	/// &lt;summary&gt;</a>
<a name="ln875">	/// Ceil the vector to the nearest intervals. Eg: SnapCeil([0.8, 1.3], [0, 1.2]) = [1.2, 2.4]</a>
<a name="ln876">	/// &lt;/summary&gt;</a>
<a name="ln877">	public static Vector2 SnapCeil(Vector2 value, Vector2 snapTo)</a>
<a name="ln878">		=&gt; new(SnapCeil(value.X, snapTo.X), SnapCeil(value.Y, snapTo.Y));</a>
<a name="ln879"> </a>
<a name="ln880">	/// &lt;summary&gt;</a>
<a name="ln881">	/// Ceil the vector to the nearest intervals. Eg: SnapCeil([0.8, 1.2], [1, 1]) = [1, 2]</a>
<a name="ln882">	/// &lt;/summary&gt;</a>
<a name="ln883">	public static Point2 SnapCeil(Vector2 value, Point2 snapTo)</a>
<a name="ln884">		=&gt; new(SnapCeil(value.X, snapTo.X), SnapCeil(value.Y, snapTo.Y));</a>
<a name="ln885"> </a>
<a name="ln886">	/// &lt;summary&gt;</a>
<a name="ln887">	/// Ceil the vector to the nearest interval on both axes. Eg: SnapCeil([0.8, 1.3], 1.2) = [1.2, 2.4]</a>
<a name="ln888">	/// &lt;/summary&gt;</a>
<a name="ln889">	public static Vector2 SnapCeil(Vector2 value, float snapTo)</a>
<a name="ln890">		=&gt; new(SnapCeil(value.X, snapTo), SnapCeil(value.Y, snapTo));</a>
<a name="ln891"> </a>
<a name="ln892">	/// &lt;summary&gt;</a>
<a name="ln893">	/// Ceil the vector to the nearest interval on both axes. Eg: SnapCeil([0.8, 1.2], 1) = [1, 2]</a>
<a name="ln894">	/// &lt;/summary&gt;</a>
<a name="ln895">	public static Point2 SnapCeil(Vector2 value, int snapTo)</a>
<a name="ln896">		=&gt; new(SnapCeil(value.X, snapTo), SnapCeil(value.Y, snapTo));</a>
<a name="ln897"> </a>
<a name="ln898">	#endregion</a>
<a name="ln899"> </a>
<a name="ln900">}</a>
</code></pre>
<div class="balloon" rel="344"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3024/" target="_blank">V3024</a> An odd precise comparison: last != next. Consider using a comparison with defined precision: Math.Abs(A - B) &gt; Epsilon.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>