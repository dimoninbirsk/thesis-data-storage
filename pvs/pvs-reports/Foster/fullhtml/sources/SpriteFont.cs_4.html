<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>SpriteFont.cs</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cs">
<a name="ln1">using System.Collections.Concurrent;</a>
<a name="ln2">using System.Diagnostics;</a>
<a name="ln3">using System.Numerics;</a>
<a name="ln4"> </a>
<a name="ln5">namespace Foster.Framework;</a>
<a name="ln6"> </a>
<a name="ln7">/// &lt;summary&gt;</a>
<a name="ln8">/// A Font used to render text to a Sprite &lt;see cref=&quot;Batcher&quot;/&gt;.&lt;br/&gt;</a>
<a name="ln9">/// &lt;br/&gt;</a>
<a name="ln10">/// By default the &lt;see cref=&quot;SpriteFont&quot;/&gt; will prepare characters as they are</a>
<a name="ln11">/// requested, which means there can occasionally be a delay between trying</a>
<a name="ln12">/// to draw some text and it actually appearing on-screen. To remove this delay, </a>
<a name="ln13">/// you can call &lt;see cref=&quot;PrepareCharacters(ReadOnlySpan{char}, bool)&quot;/&gt; to </a>
<a name="ln14">/// pre-render all characters that you would like to use.</a>
<a name="ln15">/// &lt;/summary&gt;</a>
<a name="ln16">public class SpriteFont : IDisposable</a>
<a name="ln17">{</a>
<a name="ln18">	public readonly record struct Character(</a>
<a name="ln19">		int Codepoint,</a>
<a name="ln20">		Subtexture Subtexture,</a>
<a name="ln21">		float Advance,</a>
<a name="ln22">		Vector2 Offset,</a>
<a name="ln23">		bool Exists</a>
<a name="ln24">	);</a>
<a name="ln25"> </a>
<a name="ln26">	private readonly record struct KerningPair(int First, int Second);</a>
<a name="ln27"> </a>
<a name="ln28">	/// &lt;summary&gt;</a>
<a name="ln29">	/// Set of ASCII character unicode values</a>
<a name="ln30">	/// &lt;/summary&gt;</a>
<a name="ln31">	public static readonly int[] Ascii = [.. Enumerable.Range(32, 128 - 32)];</a>
<a name="ln32"> </a>
<a name="ln33">	/// &lt;summary&gt;</a>
<a name="ln34">	/// The GraphicsDevice the Sprite Font belongs to</a>
<a name="ln35">	/// &lt;/summary&gt;</a>
<a name="ln36">	public readonly GraphicsDevice GraphicsDevice;</a>
<a name="ln37"> </a>
<a name="ln38">	/// &lt;summary&gt;</a>
<a name="ln39">	/// The Font being used by the SpriteFont.</a>
<a name="ln40">	/// This can be null if the SpriteFont was created without a Font, in which</a>
<a name="ln41">	/// case only custom Characters will be used.</a>
<a name="ln42">	/// &lt;/summary&gt;</a>
<a name="ln43">	public readonly Font? Font;</a>
<a name="ln44"> </a>
<a name="ln45">	/// &lt;summary&gt;</a>
<a name="ln46">	/// Name of the Sprite Font. Not used internally.</a>
<a name="ln47">	/// &lt;/summary&gt;</a>
<a name="ln48">	public string Name = string.Empty;</a>
<a name="ln49"> </a>
<a name="ln50">	/// &lt;summary&gt;</a>
<a name="ln51">	/// Font Size</a>
<a name="ln52">	/// &lt;/summary&gt;</a>
<a name="ln53">	public readonly float Size;</a>
<a name="ln54"> </a>
<a name="ln55">	/// &lt;summary&gt;</a>
<a name="ln56">	/// Font Ascent</a>
<a name="ln57">	/// &lt;/summary&gt;</a>
<a name="ln58">	public float Ascent;</a>
<a name="ln59"> </a>
<a name="ln60">	/// &lt;summary&gt;</a>
<a name="ln61">	/// Font Descent</a>
<a name="ln62">	/// &lt;/summary&gt;</a>
<a name="ln63">	public float Descent;</a>
<a name="ln64"> </a>
<a name="ln65">	/// &lt;summary&gt;</a>
<a name="ln66">	/// Font Line Gap (space between each line of text)</a>
<a name="ln67">	/// &lt;/summary&gt;</a>
<a name="ln68">	public float LineGap;</a>
<a name="ln69"> </a>
<a name="ln70">	/// &lt;summary&gt;</a>
<a name="ln71">	/// Height of the Font</a>
<a name="ln72">	/// &lt;/summary&gt;</a>
<a name="ln73">	public float Height =&gt; Ascent - Descent;</a>
<a name="ln74"> </a>
<a name="ln75">	/// &lt;summary&gt;</a>
<a name="ln76">	/// Line Height (including Line Gap)</a>
<a name="ln77">	/// &lt;/summary&gt;</a>
<a name="ln78">	public float LineHeight =&gt; Ascent - Descent + LineGap;</a>
<a name="ln79"> </a>
<a name="ln80">	/// &lt;summary&gt;</a>
<a name="ln81">	/// If the generated character images should premultiply their alpha.</a>
<a name="ln82">	/// This should be true if you render the SpriteFont with the default</a>
<a name="ln83">	/// Premultiply BlendMode.</a>
<a name="ln84">	/// Note that this property does not modify already-created characters.</a>
<a name="ln85">	/// &lt;/summary&gt;</a>
<a name="ln86">	public bool PremultiplyAlpha = true;</a>
<a name="ln87"> </a>
<a name="ln88">	/// &lt;summary&gt;</a>
<a name="ln89">	/// If True, the SpriteFont will always wait for all characters to be ready before</a>
<a name="ln90">	/// drawing anything to the screen. This will potentially cause your game to halt</a>
<a name="ln91">	/// as characters prepare themselves.</a>
<a name="ln92">	/// &lt;/summary&gt;</a>
<a name="ln93">	public bool WaitForPendingCharacters = false;</a>
<a name="ln94"> </a>
<a name="ln95">	/// &lt;summary&gt;</a>
<a name="ln96">	/// Newline characters to use during various text measuring and rendering methods.</a>
<a name="ln97">	/// &lt;/summary&gt;</a>
<a name="ln98">	public readonly List&lt;char&gt; NewlineCharacters = [ '\n' ];</a>
<a name="ln99"> </a>
<a name="ln100">	/// &lt;summary&gt;</a>
<a name="ln101">	/// Wordbreak characters to use during Text Wrapping calculations and rendering.</a>
<a name="ln102">	/// &lt;/summary&gt;</a>
<a name="ln103">	public readonly List&lt;char&gt; WordbreakCharacters = [ '\n', ' ' ];</a>
<a name="ln104"> </a>
<a name="ln105">	private readonly float fontScale = 1.0f;</a>
<a name="ln106">	private readonly Dictionary&lt;int, Character&gt; characters = [];</a>
<a name="ln107">	private readonly Dictionary&lt;KerningPair, float&gt; kerning = [];</a>
<a name="ln108">	private readonly List&lt;Page&gt; pages = [];</a>
<a name="ln109">	private readonly BlockingCollection&lt;(int Codepoint, Font.Character Metrics)&gt; blittingQueue = [];</a>
<a name="ln110">	private readonly BlockingCollection&lt;(int Codepoint, int Page, Rect Source, Rect Frame)&gt; blittingResults = [];</a>
<a name="ln111">	private Task? blittingTask;</a>
<a name="ln112">	private Color[] blitBuffer = [];</a>
<a name="ln113"> </a>
<a name="ln114">	public SpriteFont(GraphicsDevice graphicsDevice, Font font, float size, ReadOnlySpan&lt;int&gt; prebakedCodepoints = default, bool premultiplyAlpha = true)</a>
<a name="ln115">	{</a>
<a name="ln116">		GraphicsDevice = graphicsDevice;</a>
<a name="ln117">		Font = font;</a>
<a name="ln118">		Size = size;</a>
<a name="ln119">		fontScale = font.GetScale(size);</a>
<a name="ln120">		Ascent = font.Ascent * fontScale;</a>
<a name="ln121">		Descent = font.Descent * fontScale;</a>
<a name="ln122">		LineGap = font.LineGap * fontScale;</a>
<a name="ln123">		PremultiplyAlpha = premultiplyAlpha;</a>
<a name="ln124"> </a>
<a name="ln125">		if (prebakedCodepoints.Length &gt; 0)</a>
<a name="ln126">			PrepareCharacters(prebakedCodepoints, true);</a>
<a name="ln127">	}</a>
<a name="ln128"> </a>
<a name="ln129">	public SpriteFont(GraphicsDevice graphicsDevice, string path, float size, ReadOnlySpan&lt;int&gt; prebakedCodepoints = default, bool premultiplyAlpha = true)</a>
<a name="ln130">		: this(graphicsDevice, new Font(path), size, prebakedCodepoints, premultiplyAlpha)</a>
<a name="ln131">	{</a>
<a name="ln132"> </a>
<a name="ln133">	}</a>
<a name="ln134"> </a>
<a name="ln135">	public SpriteFont(GraphicsDevice graphicsDevice, Stream stream, float size, ReadOnlySpan&lt;int&gt; prebakedCodepoints = default, bool premultiplyAlpha = true)</a>
<a name="ln136">		: this(graphicsDevice, new Font(stream), size, prebakedCodepoints, premultiplyAlpha)</a>
<a name="ln137">	{</a>
<a name="ln138">		</a>
<a name="ln139">	}</a>
<a name="ln140"> </a>
<a name="ln141">	public SpriteFont(GraphicsDevice graphicsDevice, float size = 16)</a>
<a name="ln142">	{</a>
<a name="ln143">		GraphicsDevice = graphicsDevice;</a>
<a name="ln144">		Font = null;</a>
<a name="ln145">		Size = size;</a>
<a name="ln146">	}</a>
<a name="ln147"> </a>
<a name="ln148">	~SpriteFont()</a>
<a name="ln149">	{</a>
<a name="ln150">		Dispose();</a>
<a name="ln151">	}</a>
<a name="ln152"> </a>
<a name="ln153">	public void Dispose()</a>
<a name="ln154">	{</a>
<a name="ln155">		GC.SuppressFinalize(this);</a>
<a name="ln156">		</a>
<a name="ln157">		if (blittingTask != null)</a>
<a name="ln158">		{</a>
<a name="ln159">			blittingQueue.CompleteAdding();</a>
<a name="ln160">			blittingTask?.Wait();</a>
<a name="ln161">			blittingTask = null;</a>
<a name="ln162">		}</a>
<a name="ln163">	}</a>
<a name="ln164"> </a>
<a name="ln165">	public Character this[int codepoint] =&gt; GetCharacter(codepoint);</a>
<a name="ln166">	public Character this[char ch] =&gt; GetCharacter(ch);</a>
<a name="ln167"> </a>
<a name="ln168">	/// &lt;summary&gt;</a>
<a name="ln169">	/// Calculates the width of the given text. If the text has multiple lines,</a>
<a name="ln170">	/// then the width of the widest line will be returned.</a>
<a name="ln171">	/// &lt;/summary&gt;</a>
<a name="ln172">	public float WidthOf(ReadOnlySpan&lt;char&gt; text)</a>
<a name="ln173">	{</a>
<a name="ln174">		float width = 0;</a>
<a name="ln175">		float lineWidth = 0;</a>
<a name="ln176">		int lastCodepoint = 0;</a>
<a name="ln177"> </a>
<a name="ln178">		for (int i = 0; i &lt; text.Length; i ++)</a>
<a name="ln179">		{</a>
<a name="ln180">			if (NewlineCharacters.Contains(text[i]))</a>
<a name="ln181">			{</a>
<a name="ln182">				lineWidth = 0;</a>
<a name="ln183">				lastCodepoint = 0;</a>
<a name="ln184">				continue;</a>
<a name="ln185">			}</a>
<a name="ln186"> </a>
<a name="ln187">			if (TryGetCharacter(text, i, out var ch, out var step))</a>
<a name="ln188">			{</a>
<a name="ln189">				lineWidth += ch.Advance;</a>
<a name="ln190">				if (lastCodepoint != 0)</a>
<a name="ln191">					lineWidth += GetKerning(lastCodepoint, ch.Codepoint);</a>
<a name="ln192">				if (lineWidth &gt; width)</a>
<a name="ln193">					width = lineWidth;</a>
<a name="ln194">				lastCodepoint = ch.Codepoint;</a>
<a name="ln195">				i += step - 1;</a>
<a name="ln196">			}</a>
<a name="ln197">		}</a>
<a name="ln198"> </a>
<a name="ln199">		return width;</a>
<a name="ln200">	}</a>
<a name="ln201"> </a>
<a name="ln202">	/// &lt;summary&gt;</a>
<a name="ln203">	/// Calculates the width of the given text, up to the first line-break.</a>
<a name="ln204">	/// &lt;/summary&gt;</a>
<a name="ln205">	public float WidthOfLine(ReadOnlySpan&lt;char&gt; text)</a>
<a name="ln206">	{</a>
<a name="ln207">		float lineWidth = 0;</a>
<a name="ln208">		int lastCodepoint = 0;</a>
<a name="ln209"> </a>
<a name="ln210">		for (int i = 0; i &lt; text.Length; i ++)</a>
<a name="ln211">		{</a>
<a name="ln212">			if (NewlineCharacters.Contains(text[i]))</a>
<a name="ln213">				break;</a>
<a name="ln214"> </a>
<a name="ln215">			if (TryGetCharacter(text, i, out var ch, out var step))</a>
<a name="ln216">			{</a>
<a name="ln217">				lineWidth += ch.Advance;</a>
<a name="ln218">				if (lastCodepoint != 0)</a>
<a name="ln219">					lineWidth += GetKerning(lastCodepoint, ch.Codepoint);</a>
<a name="ln220">				lastCodepoint = ch.Codepoint;</a>
<a name="ln221">				i += step - 1;</a>
<a name="ln222">			}</a>
<a name="ln223">		}</a>
<a name="ln224"> </a>
<a name="ln225">		return lineWidth;</a>
<a name="ln226">	}</a>
<a name="ln227"> </a>
<a name="ln228">	/// &lt;summary&gt;</a>
<a name="ln229">	/// Calculates the width of the next word in the given text</a>
<a name="ln230">	/// &lt;/summary&gt;</a>
<a name="ln231">	public float WidthOfWord(ReadOnlySpan&lt;char&gt; text, out int length)</a>
<a name="ln232">	{</a>
<a name="ln233">		float lineWidth = 0;</a>
<a name="ln234">		int lastCodepoint = 0;</a>
<a name="ln235">		</a>
<a name="ln236">		length = 0;</a>
<a name="ln237">		while (length &lt; text.Length)</a>
<a name="ln238">		{</a>
<a name="ln239">			if (TryGetCharacter(text, length, out var ch, out var step))</a>
<a name="ln240">			{</a>
<a name="ln241">				lineWidth += ch.Advance;</a>
<a name="ln242">				if (lastCodepoint != 0)</a>
<a name="ln243">					lineWidth += GetKerning(lastCodepoint, ch.Codepoint);</a>
<a name="ln244">				lastCodepoint = ch.Codepoint;</a>
<a name="ln245">				length += step;</a>
<a name="ln246">			}</a>
<a name="ln247">			else</a>
<a name="ln248">			{</a>
<a name="ln249">				length++;</a>
<a name="ln250">			}</a>
<a name="ln251"> </a>
<a name="ln252">			if (length &gt;= text.Length || WordbreakCharacters.Contains(text[length]))</a>
<a name="ln253">				break;</a>
<a name="ln254">		}</a>
<a name="ln255"> </a>
<a name="ln256">		return lineWidth;</a>
<a name="ln257">	}</a>
<a name="ln258"> </a>
<a name="ln259">	/// &lt;summary&gt;</a>
<a name="ln260">	/// Calculate the height of the given text</a>
<a name="ln261">	/// &lt;/summary&gt;</a>
<a name="ln262">	public float HeightOf(ReadOnlySpan&lt;char&gt; text)</a>
<a name="ln263">	{</a>
<a name="ln264">		if (text.Length &lt;= 0)</a>
<a name="ln265">			return 0;</a>
<a name="ln266"> </a>
<a name="ln267">		float height = LineHeight;</a>
<a name="ln268"> </a>
<a name="ln269">		for (int i = 0; i &lt; text.Length; i ++)</a>
<a name="ln270">		{</a>
<a name="ln271">			if (NewlineCharacters.Contains(text[i]))</a>
<a name="ln272">				height += LineHeight;</a>
<a name="ln273">		}</a>
<a name="ln274"> </a>
<a name="ln275">		return height - LineGap;</a>
<a name="ln276">	}</a>
<a name="ln277"> </a>
<a name="ln278">	/// &lt;summary&gt;</a>
<a name="ln279">	/// Calculate the size of the given text</a>
<a name="ln280">	/// &lt;/summary&gt;</a>
<a name="ln281">	public Vector2 SizeOf(ReadOnlySpan&lt;char&gt; text)</a>
<a name="ln282">	{</a>
<a name="ln283">		return new Vector2(</a>
<a name="ln284">			WidthOf(text),</a>
<a name="ln285">			HeightOf(text)</a>
<a name="ln286">		);</a>
<a name="ln287">	}</a>
<a name="ln288"> </a>
<a name="ln289">	/// &lt;summary&gt;</a>
<a name="ln290">	/// Calculates word-wrapping positions to fit the given text into the maximum line width</a>
<a name="ln291">	/// &lt;/summary&gt;</a>
<a name="ln292">	public List&lt;(int Start, int Length)&gt; WrapText(ReadOnlySpan&lt;char&gt; text, float maxLineWidth)</a>
<a name="ln293">	{</a>
<a name="ln294">		var lines = new List&lt;(int Start, int Length)&gt;();</a>
<a name="ln295">		WrapText(text, maxLineWidth, lines);</a>
<a name="ln296">		return lines;</a>
<a name="ln297">	}</a>
<a name="ln298"> </a>
<a name="ln299">	/// &lt;summary&gt;</a>
<a name="ln300">	/// Calculates and populates a list with word-wrapping positions to fit the given text into the maximum line width</a>
<a name="ln301">	/// &lt;/summary&gt;</a>
<a name="ln302">	public void WrapText(ReadOnlySpan&lt;char&gt; text, float maxLineWidth, List&lt;(int Start, int Length)&gt; writeLinesTo)</a>
<a name="ln303">	{</a>
<a name="ln304">		var lineWidth = 0.0f;</a>
<a name="ln305">		var start = 0;</a>
<a name="ln306">		for (int i = 0; i &lt; text.Length; i ++)</a>
<a name="ln307">		{</a>
<a name="ln308">			// mandatory line-break</a>
<a name="ln309">			if (NewlineCharacters.Contains(text[i]))</a>
<a name="ln310">			{</a>
<a name="ln311">				writeLinesTo.Add((start, i - start));</a>
<a name="ln312">				start = i + 1;</a>
<a name="ln313">				lineWidth = 0;</a>
<a name="ln314">				continue;</a>
<a name="ln315">			}</a>
<a name="ln316"> </a>
<a name="ln317">			var nextWordWidth = WidthOfWord(text[i..], out var nextWordLength);</a>
<a name="ln318"> </a>
<a name="ln319">			// split before the next word if the one being added is too long</a>
<a name="ln320">			if (lineWidth &gt; 0 &amp;&amp; lineWidth + nextWordWidth &gt; maxLineWidth)</a>
<a name="ln321">			{</a>
<a name="ln322">				writeLinesTo.Add((start, i - start));</a>
<a name="ln323">				start = i + 1;</a>
<a name="ln324">				lineWidth = 0;</a>
<a name="ln325">			}</a>
<a name="ln326"> </a>
<a name="ln327">			// append word</a>
<a name="ln328">			lineWidth += nextWordWidth;</a>
<a name="ln329">			i += nextWordLength - 1;</a>
<a name="ln330"> </a>
<a name="ln331">			// finished</a>
<a name="ln332">			if (i &gt;= text.Length - 1)</a>
<a name="ln333">			{</a>
<a name="ln334">				if (text.Length - start &gt; 0)</a>
<a name="ln335">					writeLinesTo.Add((start, text.Length - start));</a>
<a name="ln336">				break;</a>
<a name="ln337">			}</a>
<a name="ln338">		}</a>
<a name="ln339">	}</a>
<a name="ln340"> </a>
<a name="ln341">	/// &lt;summary&gt;</a>
<a name="ln342">	/// Prepares the given characters for rendering</a>
<a name="ln343">	/// &lt;/summary&gt;</a>
<a name="ln344">	/// &lt;param name=&quot;codepoints&quot;&gt;A list of characters to prepare&lt;/param&gt;</a>
<a name="ln345">	/// &lt;param name=&quot;waitForResults&quot;&gt;If the function should wait for all characters to be ready&lt;/param&gt;</a>
<a name="ln346">	public void PrepareCharacters(ReadOnlySpan&lt;int&gt; codepoints, bool waitForResults)</a>
<a name="ln347">	{</a>
<a name="ln348">		foreach (var codepoint in codepoints)</a>
<a name="ln349">			BlitEnqueue(codepoint, waitForResults, out _);</a>
<a name="ln350"> </a>
<a name="ln351">		if (waitForResults)</a>
<a name="ln352">			FlushPendingCharacters(true);</a>
<a name="ln353">	}</a>
<a name="ln354"> </a>
<a name="ln355">	/// &lt;summary&gt;</a>
<a name="ln356">	/// Prepares the given characters for rendering</a>
<a name="ln357">	/// &lt;/summary&gt;</a>
<a name="ln358">	/// &lt;param name=&quot;text&quot;&gt;A list of characters to prepare&lt;/param&gt;</a>
<a name="ln359">	/// &lt;param name=&quot;waitForResults&quot;&gt;If the function should wait for all characters to be ready&lt;/param&gt;</a>
<a name="ln360">	public void PrepareCharacters(ReadOnlySpan&lt;char&gt; text, bool waitForResults)</a>
<a name="ln361">	{</a>
<a name="ln362">		int index = 0;</a>
<a name="ln363">		while (index &lt; text.Length)</a>
<a name="ln364">		{</a>
<a name="ln365">			int codepoint;</a>
<a name="ln366">			if (index + 1 &lt; text.Length &amp;&amp; char.IsSurrogatePair(text[index], text[index + 1]))</a>
<a name="ln367">			{</a>
<a name="ln368">				codepoint = char.ConvertToUtf32(text[index], text[index + 1]);</a>
<a name="ln369">				index += 2;</a>
<a name="ln370">			}</a>
<a name="ln371">			else</a>
<a name="ln372">			{</a>
<a name="ln373">				codepoint = text[index];</a>
<a name="ln374">				index += 1;</a>
<a name="ln375">			}</a>
<a name="ln376"> </a>
<a name="ln377">			BlitEnqueue(codepoint, waitForResults, out _);</a>
<a name="ln378">		}</a>
<a name="ln379"> </a>
<a name="ln380">		if (waitForResults)</a>
<a name="ln381">			FlushPendingCharacters(true);</a>
<a name="ln382">	}</a>
<a name="ln383"> </a>
<a name="ln384">	/// &lt;summary&gt;</a>
<a name="ln385">	/// Adds a custom Character to the Sprite Font</a>
<a name="ln386">	/// &lt;/summary&gt;</a>
<a name="ln387">	public void AddCharacter(int codepoint, in float advance, in Vector2 offset, in Subtexture subtexture)</a>
<a name="ln388">	{</a>
<a name="ln389">		characters[codepoint] = new(codepoint, subtexture, advance, offset, true);</a>
<a name="ln390">	}</a>
<a name="ln391"> </a>
<a name="ln392">	/// &lt;summary&gt;</a>
<a name="ln393">	/// Adds a custom Character to the Sprite Font</a>
<a name="ln394">	/// &lt;/summary&gt;</a>
<a name="ln395">	public void AddCharacter(in Character character)</a>
<a name="ln396">	{</a>
<a name="ln397">		characters[character.Codepoint] = character;</a>
<a name="ln398">	}</a>
<a name="ln399"> </a>
<a name="ln400">	/// &lt;summary&gt;</a>
<a name="ln401">	/// Gets an existing Character from the SpriteFont.</a>
<a name="ln402">	/// Note that unless you have called &lt;see cref=&quot;PrepareCharacters(ReadOnlySpan{char}, bool)&quot;/&gt; and</a>
<a name="ln403">	/// wait for them to be rendered, they may not have textures yet.</a>
<a name="ln404">	/// &lt;/summary&gt;</a>
<a name="ln405">	public Character GetCharacter(int codepoint)</a>
<a name="ln406">	{</a>
<a name="ln407">		if (!characters.TryGetValue(codepoint, out var value))</a>
<a name="ln408">			BlitEnqueue(codepoint, false, out value);</a>
<a name="ln409">		return value;</a>
<a name="ln410">	}</a>
<a name="ln411"> </a>
<a name="ln412">	public bool TryGetCharacter(int codepoint, out Character character)</a>
<a name="ln413">	{</a>
<a name="ln414">		character = GetCharacter(codepoint);</a>
<a name="ln415">		return character.Exists;</a>
<a name="ln416">	}</a>
<a name="ln417"> </a>
<a name="ln418">	public bool TryGetCharacter(char ch, out Character character)</a>
<a name="ln419">		=&gt; TryGetCharacter((int)ch, out character);</a>
<a name="ln420"> </a>
<a name="ln421">	public bool TryGetCharacter(ReadOnlySpan&lt;char&gt; text, int index, out Character character, out int length)</a>
<a name="ln422">	{</a>
<a name="ln423">		if (index + 1 &lt; text.Length &amp;&amp; char.IsSurrogatePair(text[index], text[index + 1]))</a>
<a name="ln424">		{</a>
<a name="ln425">			length = 2;</a>
<a name="ln426">			return TryGetCharacter(char.ConvertToUtf32(text[index], text[index + 1]), out character);</a>
<a name="ln427">		}</a>
<a name="ln428">		else</a>
<a name="ln429">		{</a>
<a name="ln430">			length = 1;</a>
<a name="ln431">			return TryGetCharacter(text[index], out character);</a>
<a name="ln432">		}</a>
<a name="ln433">	}</a>
<a name="ln434"> </a>
<a name="ln435">	public void SetKerning(int codepointFirst, int codepointSecond, float advance)</a>
<a name="ln436">	{</a>
<a name="ln437">		kerning[new(codepointFirst, codepointSecond)] = advance;</a>
<a name="ln438">	}</a>
<a name="ln439"> </a>
<a name="ln440">	public float GetKerning(int codepointFirst, int codepointSecond)</a>
<a name="ln441">	{</a>
<a name="ln442">		var key = new KerningPair(codepointFirst, codepointSecond);</a>
<a name="ln443"> </a>
<a name="ln444">		if (!kerning.TryGetValue(key, out var value))</a>
<a name="ln445">		{</a>
<a name="ln446">			if (Font != null)</a>
<a name="ln447">				kerning[key] = value = Font.GetKerning(codepointFirst, codepointSecond, fontScale);</a>
<a name="ln448">			else</a>
<a name="ln449">				value = 0;</a>
<a name="ln450">		}</a>
<a name="ln451"> </a>
<a name="ln452">		return value;</a>
<a name="ln453">	}</a>
<a name="ln454"> </a>
<a name="ln455">	public void RenderText(Batcher batch, ReadOnlySpan&lt;char&gt; text, Vector2 position, Color color)</a>
<a name="ln456">	{</a>
<a name="ln457">		RenderText(batch, text, position, Vector2.Zero, color);</a>
<a name="ln458">	}</a>
<a name="ln459"> </a>
<a name="ln460">	public void RenderText(Batcher batch, ReadOnlySpan&lt;char&gt; text, Vector2 position, Vector2 justify, Color color)</a>
<a name="ln461">	{</a>
<a name="ln462">		var at = position + new Vector2(0, Ascent);</a>
<a name="ln463">		var last = 0;</a>
<a name="ln464"> </a>
<a name="ln465">		if (justify.X != 0)</a>
<a name="ln466">			at.X -= justify.X * WidthOfLine(text);</a>
<a name="ln467"> </a>
<a name="ln468">		if (justify.Y != 0)</a>
<a name="ln469">			at.Y -= justify.Y * HeightOf(text);</a>
<a name="ln470">		</a>
<a name="ln471">		// TODO:</a>
<a name="ln472">		// this is incorrect, this should only happen if the font is a pixel font.</a>
<a name="ln473">		// (otherwise using matrices and so on will not play nicely with this)</a>
<a name="ln474">		at.X = Calc.Round(at.X);</a>
<a name="ln475">		at.Y = Calc.Round(at.Y);</a>
<a name="ln476"> </a>
<a name="ln477">		// apply changes that we have so far that may have been generated off-thread</a>
<a name="ln478">		if (WaitForPendingCharacters)</a>
<a name="ln479">			PrepareCharacters(text, true);</a>
<a name="ln480">		else</a>
<a name="ln481">			BlitApplyChanges();</a>
<a name="ln482"> </a>
<a name="ln483">		for (int i = 0; i &lt; text.Length; i++)</a>
<a name="ln484">		{</a>
<a name="ln485">			if (text[i] == '\n')</a>
<a name="ln486">			{</a>
<a name="ln487">				at.X = position.X;</a>
<a name="ln488">				if (justify.X != 0 &amp;&amp; i &lt; text.Length - 1)</a>
<a name="ln489">					at.X -= justify.X * WidthOfLine(text[(i + 1)..]);</a>
<a name="ln490">				at.Y += LineHeight;</a>
<a name="ln491">				last = 0;</a>
<a name="ln492">				continue;</a>
<a name="ln493">			}</a>
<a name="ln494"> </a>
<a name="ln495">			if (TryGetCharacter(text, i, out var ch, out var step))</a>
<a name="ln496">			{</a>
<a name="ln497">				if (last != 0)</a>
<a name="ln498">					at.X += GetKerning(last, ch.Codepoint);</a>
<a name="ln499"> </a>
<a name="ln500">				if (ch.Subtexture.Texture != null)</a>
<a name="ln501">					batch.Image(ch.Subtexture, at + ch.Offset, color);</a>
<a name="ln502"> </a>
<a name="ln503">				last = ch.Codepoint;</a>
<a name="ln504">				at.X += ch.Advance;</a>
<a name="ln505">				i += step - 1;</a>
<a name="ln506">			}</a>
<a name="ln507">		}</a>
<a name="ln508">	}</a>
<a name="ln509"> </a>
<a name="ln510">	public void RenderText(Batcher batch, ReadOnlySpan&lt;char&gt; text, float maxLineWidth, Vector2 position, Vector2 justify, Color color)</a>
<a name="ln511">	{</a>
<a name="ln512">		var lines = Pool.Get&lt;List&lt;(int Start, int Length)&gt;&gt;();</a>
<a name="ln513">		lines.Clear();</a>
<a name="ln514"> </a>
<a name="ln515">		WrapText(text, maxLineWidth, lines);</a>
<a name="ln516"> </a>
<a name="ln517">		if (justify.Y != 0)</a>
<a name="ln518">			position.Y -= justify.Y * (Height * lines.Count + LineGap * (lines.Count - 1));</a>
<a name="ln519"> </a>
<a name="ln520">		foreach (var (Start, Length) in lines)</a>
<a name="ln521">		{</a>
<a name="ln522">			RenderText(batch, text[Start..(Start + Length)], position, new Vector2(justify.X, 0), color);</a>
<a name="ln523">			position.Y += LineHeight;</a>
<a name="ln524">		}</a>
<a name="ln525"> </a>
<a name="ln526">		Pool.Return(lines);</a>
<a name="ln527">	}</a>
<a name="ln528"> </a>
<a name="ln529">	public void FlushPendingCharacters(bool waitForResults)</a>
<a name="ln530">	{</a>
<a name="ln531">		if (waitForResults)</a>
<a name="ln532">			BlitQueued(ref blitBuffer);</a>
<a name="ln533">		BlitApplyChanges();</a>
<a name="ln534">	}</a>
<a name="ln535"> </a>
<a name="ln536">	/// &lt;summary&gt;</a>
<a name="ln537">	/// Enqueus a character to be blitted.</a>
<a name="ln538">	/// &lt;/summary&gt;</a>
<a name="ln539">	private bool BlitEnqueue(int codepoint, bool isWaitingForResults, out Character ch)</a>
<a name="ln540">	{</a>
<a name="ln541">		if (characters.TryGetValue(codepoint, out ch))</a>
<a name="ln542">			return false;</a>
<a name="ln543"> </a>
<a name="ln544">		var blitting = false;</a>
<a name="ln545"> </a>
<a name="ln546">		if (Font != null)</a>
<a name="ln547">		{</a>
<a name="ln548">			var scale = Font.GetScale(Size);</a>
<a name="ln549">			var glyph = Font.GetGlyphIndex(codepoint);</a>
<a name="ln550">			var metrics = Font.GetCharacterOfGlyph(glyph, scale);</a>
<a name="ln551">			</a>
<a name="ln552">			characters[codepoint] = ch = new(</a>
<a name="ln553">				codepoint,</a>
<a name="ln554">				new Subtexture(null, default, new(0, 0, metrics.Width, metrics.Height)),</a>
<a name="ln555">				metrics.Advance,</a>
<a name="ln556">				metrics.Offset,</a>
<a name="ln557">				glyph != 0</a>
<a name="ln558">			);</a>
<a name="ln559"> </a>
<a name="ln560">			if (metrics.Visible)</a>
<a name="ln561">			{</a>
<a name="ln562">				blittingQueue.Add((codepoint, metrics));</a>
<a name="ln563">				blitting = true;</a>
<a name="ln564">			}</a>
<a name="ln565">		}</a>
<a name="ln566">		else</a>
<a name="ln567">		{</a>
<a name="ln568">			characters[codepoint] = ch = new(</a>
<a name="ln569">				codepoint,</a>
<a name="ln570">				default,</a>
<a name="ln571">				0.0f,</a>
<a name="ln572">				Vector2.Zero,</a>
<a name="ln573">				false</a>
<a name="ln574">			);</a>
<a name="ln575">		}</a>
<a name="ln576"> </a>
<a name="ln577">		// make sure we have a blitting task if we want to do it offthread</a>
<a name="ln578">		if (!isWaitingForResults &amp;&amp; blitting &amp;&amp; blittingTask == null)</a>
<a name="ln579">		{</a>
<a name="ln580">			void BlittingTask()</a>
<a name="ln581">			{</a>
<a name="ln582">				var blitBuffer = new Color[64];</a>
<a name="ln583">				while (!blittingQueue.IsAddingCompleted)</a>
<a name="ln584">				{</a>
<a name="ln585">					int codepoint = 0;</a>
<a name="ln586">					Font.Character metrics = default;</a>
<a name="ln587"> </a>
<a name="ln588">					// in case it's emptied between the while loop and reaching this point</a>
<a name="ln589">					try { (codepoint, metrics) = blittingQueue.Take(); }</a>
<a name="ln590">					catch {}</a>
<a name="ln591"> </a>
<a name="ln592">					if (codepoint != 0)</a>
<a name="ln593">						BlitCharacter(ref blitBuffer, codepoint, metrics);</a>
<a name="ln594">				}</a>
<a name="ln595">			}</a>
<a name="ln596"> </a>
<a name="ln597">			blittingTask = Task.Run(BlittingTask);</a>
<a name="ln598">		}</a>
<a name="ln599"> </a>
<a name="ln600">		return blitting;</a>
<a name="ln601">	}</a>
<a name="ln602"> </a>
<a name="ln603">	/// &lt;summary&gt;</a>
<a name="ln604">	/// Blits the characters queued in &lt;see cref=&quot;blittingQueue&quot;/&gt; and waits for them to finish, populating &lt;see cref=&quot;blittingResults&quot;/&gt; </a>
<a name="ln605">	/// &lt;/summary&gt;</a>
<a name="ln606">	private void BlitQueued(ref Color[] blitBuffer)</a>
<a name="ln607">	{</a>
<a name="ln608">		while (blittingQueue.TryTake(out var entry))</a>
<a name="ln609">			BlitCharacter(ref blitBuffer, entry.Codepoint, entry.Metrics);</a>
<a name="ln610">	}</a>
<a name="ln611"> </a>
<a name="ln612">	/// &lt;summary&gt;</a>
<a name="ln613">	/// Blits a single character and waits for it to finish, populating &lt;see cref=&quot;blittingResults&quot;/&gt; </a>
<a name="ln614">	/// &lt;/summary&gt;</a>
<a name="ln615">	private void BlitCharacter(ref Color[] blitBuffer, int codepoint, in Font.Character ch)</a>
<a name="ln616">	{</a>
<a name="ln617">		var length = ch.Width * ch.Height;</a>
<a name="ln618">		if (blitBuffer.Length &lt;= length)</a>
<a name="ln619">			Array.Resize(ref blitBuffer, length);</a>
<a name="ln620"> </a>
<a name="ln621">		// render the actual character to a buffer</a>
<a name="ln622">		if (Font == null || !Font.GetPixels(ch, blitBuffer))</a>
<a name="ln623">			return;</a>
<a name="ln624"> </a>
<a name="ln625">		// premultiply if needed</a>
<a name="ln626">		if (PremultiplyAlpha)</a>
<a name="ln627">		{</a>
<a name="ln628">			for (int i = 0; i &lt; length; i ++)</a>
<a name="ln629">				blitBuffer[i] = blitBuffer[i].Premultiply();</a>
<a name="ln630">		}</a>
<a name="ln631"> </a>
<a name="ln632">		// TODO:</a>
<a name="ln633">		// Ideally the pages could expand if needed.</a>
<a name="ln634">		// When expanding, all character subtextures would need to be updated.</a>
<a name="ln635">		var pageSize = (int)Math.Min(4096, Size * 16);</a>
<a name="ln636"> </a>
<a name="ln637">		// unusual case where somehow the character is gigantic and can't fit into a</a>
<a name="ln638">		// texture page .... in this scenario, throw a warning and don't render it</a>
<a name="ln639">		if (ch.Width &gt; pageSize || ch.Height &gt; pageSize)</a>
<a name="ln640">		{</a>
<a name="ln641">			Log.Warning($&quot;SpriteFont Character was too large to render to a Texture!&quot;);</a>
<a name="ln642">			return;</a>
<a name="ln643">		}</a>
<a name="ln644"> </a>
<a name="ln645">		// pack into a page</a>
<a name="ln646">		lock (pages)</a>
<a name="ln647">		{</a>
<a name="ln648">			var page = 0;</a>
<a name="ln649">			while (true)</a>
<a name="ln650">			{</a>
<a name="ln651">				if (page &gt;= pages.Count)</a>
<a name="ln652">					pages.Add(new(GraphicsDevice, Name, pageSize));</a>
<a name="ln653">				if (pages[page].TryPack(blitBuffer, ch.Width, ch.Height, out var source, out var frame))</a>
<a name="ln654">				{</a>
<a name="ln655">					blittingResults.Add((codepoint, page, source, frame));</a>
<a name="ln656">					break;</a>
<a name="ln657">				}</a>
<a name="ln658">				page++;</a>
<a name="ln659">			}</a>
<a name="ln660">		}</a>
<a name="ln661">	}</a>
<a name="ln662"> </a>
<a name="ln663">	/// &lt;summary&gt;</a>
<a name="ln664">	/// Copies results from &lt;see cref=&quot;blittingResults&quot;/&gt; and applies them to the characters.</a>
<a name="ln665">	/// This also makes sure Texture Pages are updated.</a>
<a name="ln666">	/// &lt;/summary&gt;</a>
<a name="ln667">	private void BlitApplyChanges()</a>
<a name="ln668">	{</a>
<a name="ln669">		// update character subtextures</a>
<a name="ln670">		while (blittingResults.TryTake(out var result))</a>
<a name="ln671">		{</a>
<a name="ln672">			var page = pages[result.Page];</a>
<a name="ln673">			characters[result.Codepoint] = characters[result.Codepoint] with</a>
<a name="ln674">			{ </a>
<a name="ln675">				Subtexture = page.GetSubtexture(result.Source, result.Frame)</a>
<a name="ln676">			};</a>
<a name="ln677">		}</a>
<a name="ln678">	}</a>
<a name="ln679"> </a>
<a name="ln680">	private class Page(GraphicsDevice graphicsDevice, string fontName, int size)</a>
<a name="ln681">	{</a>
<a name="ln682">		private record struct Node(int Left, int Right, RectInt Bounds);</a>
<a name="ln683">		private readonly string fontName = fontName;</a>
<a name="ln684">		private readonly int size = size;</a>
<a name="ln685">		private readonly Image image = new(size, size);</a>
<a name="ln686">		private readonly List&lt;Node&gt; nodes = [ new() { Bounds = new(0, 0, size, size) } ];</a>
<a name="ln687">		private Texture? atlas;</a>
<a name="ln688">		private bool atlasDirty;</a>
<a name="ln689"> </a>
<a name="ln690">		public Subtexture GetSubtexture(in Rect source, in Rect frame)</a>
<a name="ln691">		{</a>
<a name="ln692">			// make sure we have the latest data before returning a subtexture</a>
<a name="ln693">			if (atlasDirty)</a>
<a name="ln694">			{</a>
<a name="ln695">				atlasDirty = false;</a>
<a name="ln696">				atlas ??= new(graphicsDevice, size, size, TextureFormat.Color, $&quot;SpriteFont[{fontName}]&quot;);</a>
<a name="ln697">				atlas.SetData&lt;Color&gt;(image.Data);</a>
<a name="ln698">			}</a>
<a name="ln699"> </a>
<a name="ln700">			// get the results</a>
<a name="ln701">			return new(atlas, source, frame);</a>
<a name="ln702">		}</a>
<a name="ln703"> </a>
<a name="ln704">		public bool TryPack(Color[] buffer, int width, int height, out Rect source, out Rect frame)</a>
<a name="ln705">		{</a>
<a name="ln706">			int index = TryPackNode(0, width + 2, height + 2);</a>
<a name="ln707"> </a>
<a name="ln708">			if (index &gt;= 0)</a>
<a name="ln709">			{</a>
<a name="ln710">				var node = nodes[index];</a>
<a name="ln711">				image.CopyPixels(buffer, width, height, new Point2(node.Bounds.X + 1, node.Bounds.Y + 1));</a>
<a name="ln712">				source = node.Bounds;</a>
<a name="ln713">				frame = new Rect(1, 1, width, height);</a>
<a name="ln714">				atlasDirty = true;</a>
<a name="ln715">				return true;</a>
<a name="ln716">			}</a>
<a name="ln717"> </a>
<a name="ln718">			source = frame = default;</a>
<a name="ln719">			return false;</a>
<a name="ln720">		}</a>
<a name="ln721"> </a>
<a name="ln722">		private int TryPackNode(int node, int width, int height)</a>
<a name="ln723">		{</a>
<a name="ln724">			var it = nodes[node];</a>
<a name="ln725"> </a>
<a name="ln726">			if (it.Left &gt; 0 || it.Right &gt; 0)</a>
<a name="ln727">			{</a>
<a name="ln728">				if (it.Left &gt; 0)</a>
<a name="ln729">				{</a>
<a name="ln730">					var fit = TryPackNode(it.Left, width, height);</a>
<a name="ln731">					if (fit &gt; 0)</a>
<a name="ln732">						return fit;</a>
<a name="ln733">				}</a>
<a name="ln734"> </a>
<a name="ln735">				if (it.Right &gt; 0)</a>
<a name="ln736">				{</a>
<a name="ln737">					var fit = TryPackNode(it.Right, width, height);</a>
<a name="ln738">					if (fit &gt; 0)</a>
<a name="ln739">						return fit;</a>
<a name="ln740">				}</a>
<a name="ln741"> </a>
<a name="ln742">				return -1;</a>
<a name="ln743">			}</a>
<a name="ln744"> </a>
<a name="ln745">			if (width &gt; it.Bounds.Width || height &gt; it.Bounds.Height)</a>
<a name="ln746">				return -1;</a>
<a name="ln747"> </a>
<a name="ln748">			var w = it.Bounds.Width - width;</a>
<a name="ln749">			var h = it.Bounds.Height - height;</a>
<a name="ln750"> </a>
<a name="ln751">			it.Left = nodes.Count;</a>
<a name="ln752">			nodes.Add(new());</a>
<a name="ln753">			it.Right = nodes.Count;</a>
<a name="ln754">			nodes.Add(new());</a>
<a name="ln755"> </a>
<a name="ln756">			if (w &lt;= h)</a>
<a name="ln757">			{</a>
<a name="ln758">				nodes[it.Left] = new() { Bounds = new(it.Bounds.X + width, it.Bounds.Y, w, height) };</a>
<a name="ln759">				nodes[it.Right] = new() { Bounds = new(it.Bounds.X, it.Bounds.Y + height, it.Bounds.Width, h) };</a>
<a name="ln760">			}</a>
<a name="ln761">			else</a>
<a name="ln762">			{</a>
<a name="ln763">				nodes[it.Left] = new() { Bounds = new(it.Bounds.X, it.Bounds.Y + height, width, h) };</a>
<a name="ln764">				nodes[it.Right] = new() { Bounds = new(it.Bounds.X + width, it.Bounds.Y, w, it.Bounds.Height) };</a>
<a name="ln765">			}</a>
<a name="ln766"> </a>
<a name="ln767">			it.Bounds = it.Bounds with { Width = width, Height = height };</a>
<a name="ln768">			nodes[node] = it;</a>
<a name="ln769">			return node;</a>
<a name="ln770">		}</a>
<a name="ln771">	}</a>
<a name="ln772">}</a>
<a name="ln773"> </a>
<a name="ln774">public static class SpriteFontBatcherExt</a>
<a name="ln775">{</a>
<a name="ln776">	public static void Text(this Batcher batch, SpriteFont font, ReadOnlySpan&lt;char&gt; text, Vector2 position, Color color)</a>
<a name="ln777">	{</a>
<a name="ln778">		font.RenderText(batch, text, position, Vector2.Zero, color);</a>
<a name="ln779">	}</a>
<a name="ln780"> </a>
<a name="ln781">	public static void Text(this Batcher batch, SpriteFont font, ReadOnlySpan&lt;char&gt; text, Vector2 position, Vector2 justify, Color color)</a>
<a name="ln782">	{</a>
<a name="ln783">		font.RenderText(batch, text, position, justify, color);</a>
<a name="ln784">	}</a>
<a name="ln785"> </a>
<a name="ln786">	public static void Text(this Batcher batch, SpriteFont font, ReadOnlySpan&lt;char&gt; text, float maxLineWidth, Vector2 position, Color color)</a>
<a name="ln787">	{</a>
<a name="ln788">		font.RenderText(batch, text, maxLineWidth, position, Vector2.Zero, color);</a>
<a name="ln789">	}</a>
<a name="ln790"> </a>
<a name="ln791">	public static void Text(this Batcher batch, SpriteFont font, ReadOnlySpan&lt;char&gt; text, float maxLineWidth, Vector2 position, Vector2 justify, Color color)</a>
<a name="ln792">	{</a>
<a name="ln793">		font.RenderText(batch, text, maxLineWidth, position, justify, color);</a>
<a name="ln794">	}</a>
<a name="ln795">}</a>
</code></pre>
<div class="balloon" rel="680"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3072/" target="_blank">V3072</a> The 'Page' class containing IDisposable members does not itself implement IDisposable. Inspect: image, atlas.</p></div>
<div class="balloon" rel="465"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3024/" target="_blank">V3024</a> An odd precise comparison: justify.X != 0. Consider using a comparison with defined precision: Math.Abs(A - B) &gt; Epsilon.</p></div>
<div class="balloon" rel="468"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3024/" target="_blank">V3024</a> An odd precise comparison: justify.Y != 0. Consider using a comparison with defined precision: Math.Abs(A - B) &gt; Epsilon.</p></div>
<div class="balloon" rel="488"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3024/" target="_blank">V3024</a> An odd precise comparison: justify.X != 0. Consider using a comparison with defined precision: Math.Abs(A - B) &gt; Epsilon.</p></div>
<div class="balloon" rel="517"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3024/" target="_blank">V3024</a> An odd precise comparison: justify.Y != 0. Consider using a comparison with defined precision: Math.Abs(A - B) &gt; Epsilon.</p></div>
<div class="balloon" rel="590"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v5606/" target="_blank">V5606</a> An empty exception handler. Silent suppression of exceptions may hide the presence of bugs or vulnerabilities.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>