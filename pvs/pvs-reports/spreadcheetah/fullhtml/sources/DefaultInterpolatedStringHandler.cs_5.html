<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>DefaultInterpolatedStringHandler.cs</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cs">
<a name="ln1">ï»¿// &lt;auto-generated /&gt;</a>
<a name="ln2">#pragma warning disable</a>
<a name="ln3"> </a>
<a name="ln4">#if FeatureMemory &amp;&amp; !NET6_0_OR_GREATER</a>
<a name="ln5"> </a>
<a name="ln6">#nullable enable</a>
<a name="ln7"> </a>
<a name="ln8">namespace System.Runtime.CompilerServices;</a>
<a name="ln9"> </a>
<a name="ln10">using System;</a>
<a name="ln11">using Buffers;</a>
<a name="ln12">using Diagnostics;</a>
<a name="ln13">using Diagnostics.CodeAnalysis;</a>
<a name="ln14">using Globalization;</a>
<a name="ln15">using Link = ComponentModel.DescriptionAttribute;</a>
<a name="ln16"> </a>
<a name="ln17">/// &lt;summary&gt;Provides a handler used by the language compiler to process interpolated strings into &lt;see cref=&quot;string&quot;/&gt; instances.&lt;/summary&gt;</a>
<a name="ln18">[InterpolatedStringHandler]</a>
<a name="ln19">[ExcludeFromCodeCoverage]</a>
<a name="ln20">[DebuggerNonUserCode]</a>
<a name="ln21">//Link: https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.defaultinterpolatedstringhandler</a>
<a name="ln22">#if PolyPublic</a>
<a name="ln23">public</a>
<a name="ln24">#endif</a>
<a name="ln25">ref struct DefaultInterpolatedStringHandler</a>
<a name="ln26">{</a>
<a name="ln27">    // Implementation note:</a>
<a name="ln28">    // As this type lives in CompilerServices and is only intended to be targeted by the compiler,</a>
<a name="ln29">    // public APIs eschew argument validation logic in a variety of places, e.g. allowing a null input</a>
<a name="ln30">    // when one isn't expected to produce a NullReferenceException rather than an ArgumentNullException.</a>
<a name="ln31"> </a>
<a name="ln32">    /// &lt;summary&gt;Expected average length of formatted data used for an individual interpolation expression result.&lt;/summary&gt;</a>
<a name="ln33">    const int GuessedLengthPerHole = 11;</a>
<a name="ln34">    /// &lt;summary&gt;Minimum size array to rent from the pool.&lt;/summary&gt;</a>
<a name="ln35">    const int MinimumArrayPoolLength = 256;</a>
<a name="ln36"> </a>
<a name="ln37">    /// &lt;summary&gt;Maximum length allowed for a string.&lt;/summary&gt;</a>
<a name="ln38">    const int StringMaxLength = 0x3FFFFFDF;</a>
<a name="ln39"> </a>
<a name="ln40">    /// &lt;summary&gt;Optional provider to pass to IFormattable.ToString or ISpanFormattable.TryFormat calls.&lt;/summary&gt;</a>
<a name="ln41">    readonly IFormatProvider? _provider;</a>
<a name="ln42">    /// &lt;summary&gt;Array rented from the array pool and used to back &lt;see cref=&quot;_chars&quot;/&gt;.&lt;/summary&gt;</a>
<a name="ln43">    char[]? _arrayToReturnToPool;</a>
<a name="ln44">    /// &lt;summary&gt;The span to write into.&lt;/summary&gt;</a>
<a name="ln45">    Span&lt;char&gt; _chars;</a>
<a name="ln46">    /// &lt;summary&gt;Position at which to write the next character.&lt;/summary&gt;</a>
<a name="ln47">    int _pos;</a>
<a name="ln48">    /// &lt;summary&gt;Whether &lt;see cref=&quot;_provider&quot;/&gt; provides an ICustomFormatter.&lt;/summary&gt;</a>
<a name="ln49">    bool _hasCustomFormatter;</a>
<a name="ln50"> </a>
<a name="ln51">    /// &lt;summary&gt;Creates a handler used to translate an interpolated string into a &lt;see cref=&quot;string&quot;/&gt;.&lt;/summary&gt;</a>
<a name="ln52">    /// &lt;param name=&quot;literalLength&quot;&gt;The number of constant characters outside of interpolation expressions in the interpolated string.&lt;/param&gt;</a>
<a name="ln53">    /// &lt;param name=&quot;formattedCount&quot;&gt;The number of interpolation expressions in the interpolated string.&lt;/param&gt;</a>
<a name="ln54">    public DefaultInterpolatedStringHandler(int literalLength, int formattedCount)</a>
<a name="ln55">    {</a>
<a name="ln56">        _provider = null;</a>
<a name="ln57">        _chars = _arrayToReturnToPool = ArrayPool&lt;char&gt;.Shared.Rent(GetDefaultLength(literalLength, formattedCount));</a>
<a name="ln58">        _pos = 0;</a>
<a name="ln59">        _hasCustomFormatter = false;</a>
<a name="ln60">    }</a>
<a name="ln61"> </a>
<a name="ln62">    /// &lt;summary&gt;Creates a handler used to translate an interpolated string into a &lt;see cref=&quot;string&quot;/&gt;.&lt;/summary&gt;</a>
<a name="ln63">    /// &lt;param name=&quot;literalLength&quot;&gt;The number of constant characters outside of interpolation expressions in the interpolated string.&lt;/param&gt;</a>
<a name="ln64">    /// &lt;param name=&quot;formattedCount&quot;&gt;The number of interpolation expressions in the interpolated string.&lt;/param&gt;</a>
<a name="ln65">    /// &lt;param name=&quot;provider&quot;&gt;An object that supplies culture-specific formatting information.&lt;/param&gt;</a>
<a name="ln66">    public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, IFormatProvider? provider)</a>
<a name="ln67">    {</a>
<a name="ln68">        _provider = provider;</a>
<a name="ln69">        _chars = _arrayToReturnToPool = ArrayPool&lt;char&gt;.Shared.Rent(GetDefaultLength(literalLength, formattedCount));</a>
<a name="ln70">        _pos = 0;</a>
<a name="ln71">        _hasCustomFormatter = provider is not null &amp;&amp; HasCustomFormatter(provider);</a>
<a name="ln72">    }</a>
<a name="ln73"> </a>
<a name="ln74">    /// &lt;summary&gt;Creates a handler used to translate an interpolated string into a &lt;see cref=&quot;string&quot;/&gt;.&lt;/summary&gt;</a>
<a name="ln75">    /// &lt;param name=&quot;literalLength&quot;&gt;The number of constant characters outside of interpolation expressions in the interpolated string.&lt;/param&gt;</a>
<a name="ln76">    /// &lt;param name=&quot;formattedCount&quot;&gt;The number of interpolation expressions in the interpolated string.&lt;/param&gt;</a>
<a name="ln77">    /// &lt;param name=&quot;provider&quot;&gt;An object that supplies culture-specific formatting information.&lt;/param&gt;</a>
<a name="ln78">    /// &lt;param name=&quot;initialBuffer&quot;&gt;A buffer temporarily transferred to the handler for use as part of its formatting.  Contents may be overwritten.&lt;/param&gt;</a>
<a name="ln79">    public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, IFormatProvider? provider, Span&lt;char&gt; initialBuffer)</a>
<a name="ln80">    {</a>
<a name="ln81">        _provider = provider;</a>
<a name="ln82">        _chars = initialBuffer;</a>
<a name="ln83">        _arrayToReturnToPool = null;</a>
<a name="ln84">        _pos = 0;</a>
<a name="ln85">        _hasCustomFormatter = provider is not null &amp;&amp; HasCustomFormatter(provider);</a>
<a name="ln86">    }</a>
<a name="ln87"> </a>
<a name="ln88">    /// &lt;summary&gt;Derives a default length with which to seed the handler.&lt;/summary&gt;</a>
<a name="ln89">    /// &lt;param name=&quot;literalLength&quot;&gt;The number of constant characters outside of interpolation expressions in the interpolated string.&lt;/param&gt;</a>
<a name="ln90">    /// &lt;param name=&quot;formattedCount&quot;&gt;The number of interpolation expressions in the interpolated string.&lt;/param&gt;</a>
<a name="ln91">    [MethodImpl(MethodImplOptions.AggressiveInlining)] // becomes a constant when inputs are constant</a>
<a name="ln92">    internal static int GetDefaultLength(int literalLength, int formattedCount) =&gt;</a>
<a name="ln93">        Math.Max(MinimumArrayPoolLength, literalLength + formattedCount * GuessedLengthPerHole);</a>
<a name="ln94"> </a>
<a name="ln95">    /// &lt;summary&gt;Gets the built &lt;see cref=&quot;string&quot;/&gt;.&lt;/summary&gt;</a>
<a name="ln96">    public override string ToString() =&gt; Text.ToString();</a>
<a name="ln97"> </a>
<a name="ln98">    /// &lt;summary&gt;Gets the built &lt;see cref=&quot;string&quot;/&gt; and clears the handler.&lt;/summary&gt;</a>
<a name="ln99">    public string ToStringAndClear()</a>
<a name="ln100">    {</a>
<a name="ln101">        var result = Text.ToString();</a>
<a name="ln102">        Clear();</a>
<a name="ln103">        return result;</a>
<a name="ln104">    }</a>
<a name="ln105"> </a>
<a name="ln106">    /// &lt;summary&gt;Clears the handler, returning any rented array to the pool.&lt;/summary&gt;</a>
<a name="ln107">    [MethodImpl(MethodImplOptions.AggressiveInlining)] // used only on a few hot paths</a>
<a name="ln108">    internal void Clear()</a>
<a name="ln109">    {</a>
<a name="ln110">        var toReturn = _arrayToReturnToPool;</a>
<a name="ln111">        this = default; // defensive clear</a>
<a name="ln112">        if (toReturn is not null)</a>
<a name="ln113">        {</a>
<a name="ln114">            ArrayPool&lt;char&gt;.Shared.Return(toReturn);</a>
<a name="ln115">        }</a>
<a name="ln116">    }</a>
<a name="ln117"> </a>
<a name="ln118">    /// &lt;summary&gt;Gets a span of the written characters thus far.&lt;/summary&gt;</a>
<a name="ln119">    internal ReadOnlySpan&lt;char&gt; Text =&gt; _chars.Slice(0, _pos);</a>
<a name="ln120"> </a>
<a name="ln121">    /// &lt;summary&gt;Writes the specified string to the handler.&lt;/summary&gt;</a>
<a name="ln122">    /// &lt;param name=&quot;value&quot;&gt;The string to write.&lt;/param&gt;</a>
<a name="ln123">    [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln124">    public void AppendLiteral(string value)</a>
<a name="ln125">    {</a>
<a name="ln126">        if (value.TryCopyTo(_chars.Slice(_pos)))</a>
<a name="ln127">        {</a>
<a name="ln128">            _pos += value.Length;</a>
<a name="ln129">        }</a>
<a name="ln130">        else</a>
<a name="ln131">        {</a>
<a name="ln132">            GrowThenCopyString(value);</a>
<a name="ln133">        }</a>
<a name="ln134">    }</a>
<a name="ln135"> </a>
<a name="ln136">    #region AppendFormatted</a>
<a name="ln137">    // Design note:</a>
<a name="ln138">    // The compiler requires a AppendFormatted overload for anything that might be within an interpolation expression;</a>
<a name="ln139">    // if it can't find an appropriate overload, for handlers in general it'll simply fail to compile.</a>
<a name="ln140">    // (For target-typing to string where it uses DefaultInterpolatedStringHandler implicitly, it'll instead fall back to</a>
<a name="ln141">    // its other mechanisms, e.g. using string.Format.  This fallback has the benefit that if we miss a case,</a>
<a name="ln142">    // interpolated strings will still work, but it has the downside that a developer generally won't know</a>
<a name="ln143">    // if the fallback is happening and they're paying more.)</a>
<a name="ln144">    //</a>
<a name="ln145">    // At a minimum, then, we would need an overload that accepts:</a>
<a name="ln146">    //     (object value, int alignment = 0, string? format = null)</a>
<a name="ln147">    // Such an overload would provide the same expressiveness as string.Format.  However, this has several</a>
<a name="ln148">    // shortcomings:</a>
<a name="ln149">    // - Every value type in an interpolation expression would be boxed.</a>
<a name="ln150">    // - ReadOnlySpan&lt;char&gt; could not be used in interpolation expressions.</a>
<a name="ln151">    // - Every AppendFormatted call would have three arguments at the call site, bloating the IL further.</a>
<a name="ln152">    // - Every invocation would be more expensive, due to lack of specialization, every call needing to account</a>
<a name="ln153">    //   for alignment and format, etc.</a>
<a name="ln154">    //</a>
<a name="ln155">    // To address that, we could just have overloads for T and ReadOnlySpan&lt;char&gt;:</a>
<a name="ln156">    //     (T)</a>
<a name="ln157">    //     (T, int alignment)</a>
<a name="ln158">    //     (T, string? format)</a>
<a name="ln159">    //     (T, int alignment, string? format)</a>
<a name="ln160">    //     (ReadOnlySpan&lt;char&gt;)</a>
<a name="ln161">    //     (ReadOnlySpan&lt;char&gt;, int alignment)</a>
<a name="ln162">    //     (ReadOnlySpan&lt;char&gt;, string? format)</a>
<a name="ln163">    //     (ReadOnlySpan&lt;char&gt;, int alignment, string? format)</a>
<a name="ln164">    // but this also has shortcomings:</a>
<a name="ln165">    // - Some expressions that would have worked with an object overload will now force a fallback to string.Format</a>
<a name="ln166">    //   (or fail to compile if the handler is used in places where the fallback isn't provided), because the compiler</a>
<a name="ln167">    //   can't always target type to T, e.g. `b switch { true =&gt; 1, false =&gt; null }` where `b` is a bool can successfully</a>
<a name="ln168">    //   be passed as an argument of type `object` but not of type `T`.</a>
<a name="ln169">    // - Reference types get no benefit from going through the generic code paths, and actually incur some overheads</a>
<a name="ln170">    //   from doing so.</a>
<a name="ln171">    // - Nullable value types also pay a heavy price, in particular around interface checks that would generally evaporate</a>
<a name="ln172">    //   at compile time for value types but don't (currently) if the Nullable&lt;T&gt; goes through the same code paths</a>
<a name="ln173">    //   (see https://github.com/dotnet/runtime/issues/50915).</a>
<a name="ln174">    //</a>
<a name="ln175">    // We could try to take a more elaborate approach for DefaultInterpolatedStringHandler, since it is the most common</a>
<a name="ln176">    // handler and we want to minimize overheads both at runtime and in IL size, e.g. have a complete set of overloads</a>
<a name="ln177">    // for each of:</a>
<a name="ln178">    //     (T, ...) where T : struct</a>
<a name="ln179">    //     (T?, ...) where T : struct</a>
<a name="ln180">    //     (object, ...)</a>
<a name="ln181">    //     (ReadOnlySpan&lt;char&gt;, ...)</a>
<a name="ln182">    //     (string, ...)</a>
<a name="ln183">    // but this also has shortcomings, most importantly:</a>
<a name="ln184">    // - If you have an unconstrained T that happens to be a value type, it'll now end up getting boxed to use the object</a>
<a name="ln185">    //   overload. This also necessitates the T? overload, since nullable value types don't meet a T : struct constraint,</a>
<a name="ln186">    //   so without those they'd all map to the object overloads as well.</a>
<a name="ln187">    // - Any reference type with an implicit cast to ROS&lt;char&gt; will fail to compile due to ambiguities between the</a>
<a name="ln188">    //   overloads. string is one such type, hence needing dedicated overloads for it that can be bound to more tightly.</a>
<a name="ln189">    //</a>
<a name="ln190">    // A middle ground we've settled on, which is likely to be the right approach for most other handlers as well,</a>
<a name="ln191">    //   would be the set:</a>
<a name="ln192">    //     (T, ...) with no constraint</a>
<a name="ln193">    //     (ReadOnlySpan&lt;char&gt;) and (ReadOnlySpan&lt;char&gt;, int)</a>
<a name="ln194">    //     (object, int alignment = 0, string? format = null)</a>
<a name="ln195">    //     (string) and (string, int)</a>
<a name="ln196">    // This would address most of the concerns, at the expense of:</a>
<a name="ln197">    // - Most reference types going through the generic code paths and so being a bit more expensive.</a>
<a name="ln198">    // - Nullable types being more expensive until https://github.com/dotnet/runtime/issues/50915 is addressed.</a>
<a name="ln199">    //   We could choose to add a T? where T : struct set of overloads if necessary.</a>
<a name="ln200">    // Strings don't require their own overloads here, but as they're expected to be very common and as we can</a>
<a name="ln201">    // optimize them in several ways (can copy the contents directly, don't need to do any interface checks, don't</a>
<a name="ln202">    // need to pay the shared generic overheads, etc.) we can add overloads specifically to optimize for them.</a>
<a name="ln203">    //</a>
<a name="ln204">    // Hole values are formatted according to the following policy:</a>
<a name="ln205">    // 1. If an IFormatProvider was supplied and it provides an ICustomFormatter, use ICustomFormatter.Format (even if</a>
<a name="ln206">    //   the value is null).</a>
<a name="ln207">    // 2. If the type implements ISpanFormattable, use ISpanFormattable.TryFormat.</a>
<a name="ln208">    // 3. If the type implements IFormattable, use IFormattable.ToString.</a>
<a name="ln209">    // 4. Otherwise, use object.ToString.</a>
<a name="ln210">    // This matches the behavior of string.Format, StringBuilder.AppendFormat, etc.  The only overloads for which this</a>
<a name="ln211">    // doesn't apply is ReadOnlySpan&lt;char&gt;, which isn't supported by either string.Format nor StringBuilder.AppendFormat,</a>
<a name="ln212">    // but more importantly which can't be boxed to be passed to ICustomFormatter.Format.</a>
<a name="ln213"> </a>
<a name="ln214">    #region AppendFormatted T</a>
<a name="ln215">    /// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;</a>
<a name="ln216">    /// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;</a>
<a name="ln217">    /// &lt;typeparam name=&quot;T&quot;&gt;The type of the value to write.&lt;/typeparam&gt;</a>
<a name="ln218">    public void AppendFormatted&lt;T&gt;(T value)</a>
<a name="ln219">    {</a>
<a name="ln220">        // This method could delegate to AppendFormatted with a null format, but explicitly passing</a>
<a name="ln221">        // default as the format to TryFormat helps to improve code quality in some cases when TryFormat is inlined,</a>
<a name="ln222">        // e.g. for Int32 it enables the JIT to eliminate code in the inlined method based on a length check on the format.</a>
<a name="ln223"> </a>
<a name="ln224">        // If there's a custom formatter, always use it.</a>
<a name="ln225">        if (_hasCustomFormatter)</a>
<a name="ln226">        {</a>
<a name="ln227">            AppendCustomFormatter(value, format: null);</a>
<a name="ln228">            return;</a>
<a name="ln229">        }</a>
<a name="ln230"> </a>
<a name="ln231">        // Check first for IFormattable, even though we'll prefer to use ISpanFormattable, as the latter</a>
<a name="ln232">        // requires the former.  For value types, it won't matter as the type checks devolve into</a>
<a name="ln233">        // JIT-time constants.  For reference types, they're more likely to implement IFormattable</a>
<a name="ln234">        // than they are to implement ISpanFormattable: if they don't implement either, we save an</a>
<a name="ln235">        // interface check over first checking for ISpanFormattable and then for IFormattable, and</a>
<a name="ln236">        // if it only implements IFormattable, we come out even: only if it implements both do we</a>
<a name="ln237">        // end up paying for an extra interface check.</a>
<a name="ln238">        string? s;</a>
<a name="ln239">        if (value is IFormattable fValue)</a>
<a name="ln240">        {</a>
<a name="ln241">            // If the value can format itself directly into our buffer, do so.</a>
<a name="ln242"> </a>
<a name="ln243">            if (TryFormatWithExtensions(value, default))</a>
<a name="ln244">            {</a>
<a name="ln245">                return;</a>
<a name="ln246">            }</a>
<a name="ln247">            else if (fValue is ISpanFormattable sfValue)</a>
<a name="ln248">            {</a>
<a name="ln249">                int charsWritten;</a>
<a name="ln250">                // constrained call avoiding boxing for value types</a>
<a name="ln251">                while (!sfValue.TryFormat(_chars.Slice(_pos), out charsWritten, default, _provider))</a>
<a name="ln252">                {</a>
<a name="ln253">                    Grow();</a>
<a name="ln254">                }</a>
<a name="ln255"> </a>
<a name="ln256">                _pos += charsWritten;</a>
<a name="ln257">                return;</a>
<a name="ln258">            }</a>
<a name="ln259"> </a>
<a name="ln260">            s = fValue.ToString(format: null, _provider); // constrained call avoiding boxing for value types</a>
<a name="ln261">        }</a>
<a name="ln262">        else</a>
<a name="ln263">        {</a>
<a name="ln264">            s = value?.ToString();</a>
<a name="ln265">        }</a>
<a name="ln266"> </a>
<a name="ln267">        if (s is not null)</a>
<a name="ln268">        {</a>
<a name="ln269">            AppendLiteral(s);</a>
<a name="ln270">        }</a>
<a name="ln271">    }</a>
<a name="ln272"> </a>
<a name="ln273">    /// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;</a>
<a name="ln274">    /// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;</a>
<a name="ln275">    /// &lt;param name=&quot;format&quot;&gt;The format string.&lt;/param&gt;</a>
<a name="ln276">    /// &lt;typeparam name=&quot;T&quot;&gt;The type of the value to write.&lt;/typeparam&gt;</a>
<a name="ln277">    public void AppendFormatted&lt;T&gt;(T value, string? format)</a>
<a name="ln278">    {</a>
<a name="ln279">        // If there's a custom formatter, always use it.</a>
<a name="ln280">        if (_hasCustomFormatter)</a>
<a name="ln281">        {</a>
<a name="ln282">            AppendCustomFormatter(value, format);</a>
<a name="ln283">            return;</a>
<a name="ln284">        }</a>
<a name="ln285"> </a>
<a name="ln286">        // Check first for IFormattable, even though we'll prefer to use ISpanFormattable, as the latter</a>
<a name="ln287">        // requires the former.  For value types, it won't matter as the type checks devolve into</a>
<a name="ln288">        // JIT-time constants.  For reference types, they're more likely to implement IFormattable</a>
<a name="ln289">        // than they are to implement ISpanFormattable: if they don't implement either, we save an</a>
<a name="ln290">        // interface check over first checking for ISpanFormattable and then for IFormattable, and</a>
<a name="ln291">        // if it only implements IFormattable, we come out even: only if it implements both do we</a>
<a name="ln292">        // end up paying for an extra interface check.</a>
<a name="ln293">        string? s;</a>
<a name="ln294">        if (value is IFormattable fValue)</a>
<a name="ln295">        {</a>
<a name="ln296">            // If the value can format itself directly into our buffer, do so.</a>
<a name="ln297"> </a>
<a name="ln298">            if (TryFormatWithExtensions(value, format.AsSpan()))</a>
<a name="ln299">            {</a>
<a name="ln300">                return;</a>
<a name="ln301">            }</a>
<a name="ln302">            else if (fValue is ISpanFormattable sfValue)</a>
<a name="ln303">            {</a>
<a name="ln304">                int charsWritten;</a>
<a name="ln305">                // constrained call avoiding boxing for value types</a>
<a name="ln306">                while (!sfValue.TryFormat(_chars.Slice(_pos), out charsWritten, format.AsSpan(), _provider))</a>
<a name="ln307">                {</a>
<a name="ln308">                    Grow();</a>
<a name="ln309">                }</a>
<a name="ln310"> </a>
<a name="ln311">                _pos += charsWritten;</a>
<a name="ln312">                return;</a>
<a name="ln313">            }</a>
<a name="ln314"> </a>
<a name="ln315">            s = fValue.ToString(format, _provider); // constrained call avoiding boxing for value types</a>
<a name="ln316">        }</a>
<a name="ln317">        else</a>
<a name="ln318">        {</a>
<a name="ln319">            s = value?.ToString();</a>
<a name="ln320">        }</a>
<a name="ln321"> </a>
<a name="ln322">        if (s is not null)</a>
<a name="ln323">        {</a>
<a name="ln324">            AppendLiteral(s);</a>
<a name="ln325">        }</a>
<a name="ln326">    }</a>
<a name="ln327"> </a>
<a name="ln328">    /// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;</a>
<a name="ln329">    /// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;</a>
<a name="ln330">    /// &lt;param name=&quot;alignment&quot;&gt;</a>
<a name="ln331">    /// Minimum number of characters that should be written for this value.  If the value is negative, it indicates</a>
<a name="ln332">    /// left-aligned and the required minimum is the absolute value.</a>
<a name="ln333">    /// &lt;/param&gt;</a>
<a name="ln334">    /// &lt;typeparam name=&quot;T&quot;&gt;The type of the value to write.&lt;/typeparam&gt;</a>
<a name="ln335">    public void AppendFormatted&lt;T&gt;(T value, int alignment)</a>
<a name="ln336">    {</a>
<a name="ln337">        var startingPos = _pos;</a>
<a name="ln338">        AppendFormatted(value);</a>
<a name="ln339">        if (alignment != 0)</a>
<a name="ln340">        {</a>
<a name="ln341">            AppendOrInsertAlignmentIfNeeded(startingPos, alignment);</a>
<a name="ln342">        }</a>
<a name="ln343">    }</a>
<a name="ln344"> </a>
<a name="ln345">    /// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;</a>
<a name="ln346">    /// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;</a>
<a name="ln347">    /// &lt;param name=&quot;format&quot;&gt;The format string.&lt;/param&gt;</a>
<a name="ln348">    /// &lt;param name=&quot;alignment&quot;&gt;</a>
<a name="ln349">    /// Minimum number of characters that should be written for this value.  If the value is negative, it indicates</a>
<a name="ln350">    /// left-aligned and the required minimum is the absolute value.</a>
<a name="ln351">    /// &lt;/param&gt;</a>
<a name="ln352">    /// &lt;typeparam name=&quot;T&quot;&gt;The type of the value to write.&lt;/typeparam&gt;</a>
<a name="ln353">    public void AppendFormatted&lt;T&gt;(T value, int alignment, string? format)</a>
<a name="ln354">    {</a>
<a name="ln355">        var startingPos = _pos;</a>
<a name="ln356">        AppendFormatted(value, format);</a>
<a name="ln357">        if (alignment != 0)</a>
<a name="ln358">        {</a>
<a name="ln359">            AppendOrInsertAlignmentIfNeeded(startingPos, alignment);</a>
<a name="ln360">        }</a>
<a name="ln361">    }</a>
<a name="ln362">    #endregion</a>
<a name="ln363"> </a>
<a name="ln364">    #region AppendFormatted ReadOnlySpan&lt;char&gt;</a>
<a name="ln365">    /// &lt;summary&gt;Writes the specified character span to the handler.&lt;/summary&gt;</a>
<a name="ln366">    /// &lt;param name=&quot;value&quot;&gt;The span to write.&lt;/param&gt;</a>
<a name="ln367">    public void AppendFormatted(scoped ReadOnlySpan&lt;char&gt; value)</a>
<a name="ln368">    {</a>
<a name="ln369">        // Fast path for when the value fits in the current buffer</a>
<a name="ln370">        if (value.TryCopyTo(_chars.Slice(_pos)))</a>
<a name="ln371">        {</a>
<a name="ln372">            _pos += value.Length;</a>
<a name="ln373">        }</a>
<a name="ln374">        else</a>
<a name="ln375">        {</a>
<a name="ln376">            GrowThenCopySpan(value);</a>
<a name="ln377">        }</a>
<a name="ln378">    }</a>
<a name="ln379"> </a>
<a name="ln380">    /// &lt;summary&gt;Writes the specified string of chars to the handler.&lt;/summary&gt;</a>
<a name="ln381">    /// &lt;param name=&quot;value&quot;&gt;The span to write.&lt;/param&gt;</a>
<a name="ln382">    /// &lt;param name=&quot;alignment&quot;&gt;</a>
<a name="ln383">    /// Minimum number of characters that should be written for this value.  If the value is negative, it indicates</a>
<a name="ln384">    /// left-aligned and the required minimum is the absolute value.</a>
<a name="ln385">    /// &lt;/param&gt;</a>
<a name="ln386">    /// &lt;param name=&quot;format&quot;&gt;The format string.&lt;/param&gt;</a>
<a name="ln387">    public void AppendFormatted(scoped ReadOnlySpan&lt;char&gt; value, int alignment = 0, string? format = null)</a>
<a name="ln388">    {</a>
<a name="ln389">        var leftAlign = false;</a>
<a name="ln390">        if (alignment &lt; 0)</a>
<a name="ln391">        {</a>
<a name="ln392">            leftAlign = true;</a>
<a name="ln393">            alignment = -alignment;</a>
<a name="ln394">        }</a>
<a name="ln395"> </a>
<a name="ln396">        var paddingRequired = alignment - value.Length;</a>
<a name="ln397">        if (paddingRequired &lt;= 0)</a>
<a name="ln398">        {</a>
<a name="ln399">            // The value is as large or larger than the required amount of padding,</a>
<a name="ln400">            // so just write the value.</a>
<a name="ln401">            AppendFormatted(value);</a>
<a name="ln402">            return;</a>
<a name="ln403">        }</a>
<a name="ln404"> </a>
<a name="ln405">        // Write the value along with the appropriate padding.</a>
<a name="ln406">        EnsureCapacityForAdditionalChars(value.Length + paddingRequired);</a>
<a name="ln407">        if (leftAlign)</a>
<a name="ln408">        {</a>
<a name="ln409">            value.CopyTo(_chars.Slice(_pos));</a>
<a name="ln410">            _pos += value.Length;</a>
<a name="ln411">            _chars.Slice(_pos, paddingRequired).Fill(' ');</a>
<a name="ln412">            _pos += paddingRequired;</a>
<a name="ln413">        }</a>
<a name="ln414">        else</a>
<a name="ln415">        {</a>
<a name="ln416">            _chars.Slice(_pos, paddingRequired).Fill(' ');</a>
<a name="ln417">            _pos += paddingRequired;</a>
<a name="ln418">            value.CopyTo(_chars.Slice(_pos));</a>
<a name="ln419">            _pos += value.Length;</a>
<a name="ln420">        }</a>
<a name="ln421">    }</a>
<a name="ln422">    #endregion</a>
<a name="ln423"> </a>
<a name="ln424">    #region AppendFormatted string</a>
<a name="ln425">    /// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;</a>
<a name="ln426">    /// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;</a>
<a name="ln427">    public void AppendFormatted(string? value)</a>
<a name="ln428">    {</a>
<a name="ln429">        // Fast-path for no custom formatter and a non-null string that fits in the current destination buffer.</a>
<a name="ln430">        if (!_hasCustomFormatter &amp;&amp;</a>
<a name="ln431">            value is not null &amp;&amp;</a>
<a name="ln432">            value.TryCopyTo(_chars.Slice(_pos)))</a>
<a name="ln433">        {</a>
<a name="ln434">            _pos += value.Length;</a>
<a name="ln435">        }</a>
<a name="ln436">        else</a>
<a name="ln437">        {</a>
<a name="ln438">            AppendFormattedSlow(value);</a>
<a name="ln439">        }</a>
<a name="ln440">    }</a>
<a name="ln441"> </a>
<a name="ln442">    /// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;</a>
<a name="ln443">    /// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;</a>
<a name="ln444">    [MethodImpl(MethodImplOptions.NoInlining)]</a>
<a name="ln445">    void AppendFormattedSlow(string? value)</a>
<a name="ln446">    {</a>
<a name="ln447">        if (_hasCustomFormatter)</a>
<a name="ln448">        {</a>
<a name="ln449">            AppendCustomFormatter(value, format: null);</a>
<a name="ln450">        }</a>
<a name="ln451">        else if (value is not null)</a>
<a name="ln452">        {</a>
<a name="ln453">            EnsureCapacityForAdditionalChars(value.Length);</a>
<a name="ln454">            value.CopyTo(_chars.Slice(_pos));</a>
<a name="ln455">            _pos += value.Length;</a>
<a name="ln456">        }</a>
<a name="ln457">    }</a>
<a name="ln458"> </a>
<a name="ln459">    /// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;</a>
<a name="ln460">    /// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;</a>
<a name="ln461">    /// &lt;param name=&quot;alignment&quot;&gt;</a>
<a name="ln462">    /// Minimum number of characters that should be written for this value.  If the value is negative, it indicates</a>
<a name="ln463">    /// left-aligned and the required minimum is the absolute value.</a>
<a name="ln464">    /// &lt;/param&gt;</a>
<a name="ln465">    /// &lt;param name=&quot;format&quot;&gt;The format string.&lt;/param&gt;</a>
<a name="ln466">    public void AppendFormatted(string? value, int alignment = 0, string? format = null) =&gt;</a>
<a name="ln467">        // Format is meaningless for strings and doesn't make sense for someone to specify.  We have the overload</a>
<a name="ln468">        // simply to disambiguate between ROS&lt;char&gt; and object, just in case someone does specify a format, as</a>
<a name="ln469">        // string is implicitly convertible to both. Just delegate to the T-based implementation.</a>
<a name="ln470">        AppendFormatted&lt;string?&gt;(value, alignment, format);</a>
<a name="ln471">    #endregion</a>
<a name="ln472"> </a>
<a name="ln473">    #region AppendFormatted object</a>
<a name="ln474">    /// &lt;summary&gt;Writes the specified value to the handler.&lt;/summary&gt;</a>
<a name="ln475">    /// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;</a>
<a name="ln476">    /// &lt;param name=&quot;alignment&quot;&gt;</a>
<a name="ln477">    /// Minimum number of characters that should be written for this value.  If the value is negative, it indicates</a>
<a name="ln478">    /// left-aligned and the required minimum is the absolute value.</a>
<a name="ln479">    /// &lt;/param&gt;</a>
<a name="ln480">    /// &lt;param name=&quot;format&quot;&gt;The format string.&lt;/param&gt;</a>
<a name="ln481">    public void AppendFormatted(object? value, int alignment = 0, string? format = null) =&gt;</a>
<a name="ln482">        // This overload is expected to be used rarely, only if either a) something strongly typed as object is</a>
<a name="ln483">        // formatted with both an alignment and a format, or b) the compiler is unable to target type to T. It</a>
<a name="ln484">        // exists purely to help make cases from (b) compile. Just delegate to the T-based implementation.</a>
<a name="ln485">        AppendFormatted&lt;object?&gt;(value, alignment, format);</a>
<a name="ln486">    #endregion</a>
<a name="ln487">    #endregion</a>
<a name="ln488"> </a>
<a name="ln489">    /// &lt;summary&gt;Gets whether the provider provides a custom formatter.&lt;/summary&gt;</a>
<a name="ln490">    [MethodImpl(MethodImplOptions.AggressiveInlining)] // only used in a few hot path call sites</a>
<a name="ln491">    internal static bool HasCustomFormatter(IFormatProvider provider)</a>
<a name="ln492">    {</a>
<a name="ln493">        Debug.Assert(provider is not null);</a>
<a name="ln494">        Debug.Assert(</a>
<a name="ln495">            provider is not CultureInfo || provider.GetFormat(typeof(ICustomFormatter)) is null,</a>
<a name="ln496">            &quot;Expected CultureInfo to not provide a custom formatter&quot;);</a>
<a name="ln497"> </a>
<a name="ln498">        return</a>
<a name="ln499">            provider!.GetType() != typeof(CultureInfo) &amp;&amp; // optimization to avoid GetFormat in the majority case</a>
<a name="ln500">            provider.GetFormat(typeof(ICustomFormatter)) != null;</a>
<a name="ln501">    }</a>
<a name="ln502"> </a>
<a name="ln503">    /// &lt;summary&gt;Formats the value using the custom formatter from the provider.&lt;/summary&gt;</a>
<a name="ln504">    /// &lt;param name=&quot;value&quot;&gt;The value to write.&lt;/param&gt;</a>
<a name="ln505">    /// &lt;param name=&quot;format&quot;&gt;The format string.&lt;/param&gt;</a>
<a name="ln506">    /// &lt;typeparam name=&quot;T&quot;&gt;The type of the value to write.&lt;/typeparam&gt;</a>
<a name="ln507">    [MethodImpl(MethodImplOptions.NoInlining)]</a>
<a name="ln508">    void AppendCustomFormatter&lt;T&gt;(T value, string? format)</a>
<a name="ln509">    {</a>
<a name="ln510">        // This case is very rare, but we need to handle it prior to the other checks in case</a>
<a name="ln511">        // a provider was used that supplied an ICustomFormatter which wanted to intercept the particular value.</a>
<a name="ln512">        // We do the cast here rather than in the ctor, even though this could be executed multiple times per</a>
<a name="ln513">        // formatting, to make the cast pay for play.</a>
<a name="ln514">        Debug.Assert(_hasCustomFormatter);</a>
<a name="ln515">        Debug.Assert(_provider != null);</a>
<a name="ln516"> </a>
<a name="ln517">        var formatter = (ICustomFormatter?)_provider!.GetFormat(typeof(ICustomFormatter));</a>
<a name="ln518">        Debug.Assert(</a>
<a name="ln519">            formatter != null,</a>
<a name="ln520">            &quot;An incorrectly written provider said it implemented ICustomFormatter, and then didn't&quot;);</a>
<a name="ln521"> </a>
<a name="ln522">        if (formatter?.Format(format, value, _provider) is { } customFormatted)</a>
<a name="ln523">        {</a>
<a name="ln524">            AppendLiteral(customFormatted);</a>
<a name="ln525">        }</a>
<a name="ln526">    }</a>
<a name="ln527"> </a>
<a name="ln528">    /// &lt;summary&gt;Handles adding any padding required for aligning a formatted value in an interpolation expression.&lt;/summary&gt;</a>
<a name="ln529">    /// &lt;param name=&quot;startingPos&quot;&gt;The position at which the written value started.&lt;/param&gt;</a>
<a name="ln530">    /// &lt;param name=&quot;alignment&quot;&gt;</a>
<a name="ln531">    /// Non-zero minimum number of characters that should be written for this value.  If the value is negative, it</a>
<a name="ln532">    /// indicates left-aligned and the required minimum is the absolute value.</a>
<a name="ln533">    /// &lt;/param&gt;</a>
<a name="ln534">    void AppendOrInsertAlignmentIfNeeded(int startingPos, int alignment)</a>
<a name="ln535">    {</a>
<a name="ln536">        Debug.Assert(startingPos &gt;= 0 &amp;&amp; startingPos &lt;= _pos);</a>
<a name="ln537">        Debug.Assert(alignment != 0);</a>
<a name="ln538"> </a>
<a name="ln539">        var charsWritten = _pos - startingPos;</a>
<a name="ln540"> </a>
<a name="ln541">        var leftAlign = false;</a>
<a name="ln542">        if (alignment &lt; 0)</a>
<a name="ln543">        {</a>
<a name="ln544">            leftAlign = true;</a>
<a name="ln545">            alignment = -alignment;</a>
<a name="ln546">        }</a>
<a name="ln547"> </a>
<a name="ln548">        var paddingNeeded = alignment - charsWritten;</a>
<a name="ln549">        if (paddingNeeded &gt; 0)</a>
<a name="ln550">        {</a>
<a name="ln551">            EnsureCapacityForAdditionalChars(paddingNeeded);</a>
<a name="ln552"> </a>
<a name="ln553">            if (leftAlign)</a>
<a name="ln554">            {</a>
<a name="ln555">                _chars.Slice(_pos, paddingNeeded).Fill(' ');</a>
<a name="ln556">            }</a>
<a name="ln557">            else</a>
<a name="ln558">            {</a>
<a name="ln559">                _chars.Slice(startingPos, charsWritten).CopyTo(_chars.Slice(startingPos + paddingNeeded));</a>
<a name="ln560">                _chars.Slice(startingPos, paddingNeeded).Fill(' ');</a>
<a name="ln561">            }</a>
<a name="ln562"> </a>
<a name="ln563">            _pos += paddingNeeded;</a>
<a name="ln564">        }</a>
<a name="ln565">    }</a>
<a name="ln566"> </a>
<a name="ln567">    /// &lt;summary&gt;</a>
<a name="ln568">    /// Ensures &lt;see cref=&quot;_chars&quot;/&gt; has the capacity to store &lt;paramref name=&quot;additionalChars&quot;/&gt; beyond &lt;see cref=&quot;_pos&quot;/&gt;.</a>
<a name="ln569">    /// &lt;/summary&gt;</a>
<a name="ln570">    [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln571">    void EnsureCapacityForAdditionalChars(int additionalChars)</a>
<a name="ln572">    {</a>
<a name="ln573">        if (_chars.Length - _pos &lt; additionalChars)</a>
<a name="ln574">        {</a>
<a name="ln575">            Grow(additionalChars);</a>
<a name="ln576">        }</a>
<a name="ln577">    }</a>
<a name="ln578"> </a>
<a name="ln579">    /// &lt;summary&gt;</a>
<a name="ln580">    /// Fallback for fast path in &lt;see cref=&quot;AppendLiteral(string)&quot;/&gt; when there's not enough space in the destination.</a>
<a name="ln581">    /// &lt;/summary&gt;</a>
<a name="ln582">    /// &lt;param name=&quot;value&quot;&gt;The string to write.&lt;/param&gt;</a>
<a name="ln583">    [MethodImpl(MethodImplOptions.NoInlining)]</a>
<a name="ln584">    void GrowThenCopyString(string value)</a>
<a name="ln585">    {</a>
<a name="ln586">        Grow(value.Length);</a>
<a name="ln587">        value.CopyTo(_chars.Slice(_pos));</a>
<a name="ln588">        _pos += value.Length;</a>
<a name="ln589">    }</a>
<a name="ln590"> </a>
<a name="ln591">    /// &lt;summary&gt;</a>
<a name="ln592">    /// Fallback for &lt;see cref=&quot;AppendFormatted(ReadOnlySpan{char})&quot;/&gt; for when not enough space exists in the current buffer.</a>
<a name="ln593">    /// &lt;/summary&gt;</a>
<a name="ln594">    /// &lt;param name=&quot;value&quot;&gt;The span to write.&lt;/param&gt;</a>
<a name="ln595">    [MethodImpl(MethodImplOptions.NoInlining)]</a>
<a name="ln596">    void GrowThenCopySpan(scoped ReadOnlySpan&lt;char&gt; value)</a>
<a name="ln597">    {</a>
<a name="ln598">        Grow(value.Length);</a>
<a name="ln599">        value.CopyTo(_chars.Slice(_pos));</a>
<a name="ln600">        _pos += value.Length;</a>
<a name="ln601">    }</a>
<a name="ln602"> </a>
<a name="ln603">    /// &lt;summary&gt;</a>
<a name="ln604">    /// Grows &lt;see cref=&quot;_chars&quot;/&gt; to have the capacity to store at least &lt;paramref name=&quot;additionalChars&quot;/&gt;</a>
<a name="ln605">    /// beyond &lt;see cref=&quot;_pos&quot;/&gt;.</a>
<a name="ln606">    /// &lt;/summary&gt;</a>
<a name="ln607">    [MethodImpl(MethodImplOptions.NoInlining)] // keep consumers as streamlined as possible</a>
<a name="ln608">    void Grow(int additionalChars)</a>
<a name="ln609">    {</a>
<a name="ln610">        // This method is called when the remaining space (_chars.Length - _pos) is</a>
<a name="ln611">        // insufficient to store a specific number of additional characters.  Thus, we</a>
<a name="ln612">        // need to grow to at least that new total. GrowCore will handle growing by more</a>
<a name="ln613">        // than that if possible.</a>
<a name="ln614">        Debug.Assert(additionalChars &gt; _chars.Length - _pos);</a>
<a name="ln615">        GrowCore((uint)_pos + (uint)additionalChars);</a>
<a name="ln616">    }</a>
<a name="ln617"> </a>
<a name="ln618">    /// &lt;summary&gt;Grows the size of &lt;see cref=&quot;_chars&quot;/&gt;.&lt;/summary&gt;</a>
<a name="ln619">    [MethodImpl(MethodImplOptions.NoInlining)] // keep consumers as streamlined as possible</a>
<a name="ln620">    void Grow() =&gt;</a>
<a name="ln621">        // This method is called when the remaining space in _chars isn't sufficient to continue</a>
<a name="ln622">        // the operation.  Thus, we need at least one character beyond _chars.Length.  GrowCore</a>
<a name="ln623">        // will handle growing by more than that if possible.</a>
<a name="ln624">        GrowCore((uint)_chars.Length + 1);</a>
<a name="ln625"> </a>
<a name="ln626">    /// &lt;summary&gt;</a>
<a name="ln627">    /// Grow the size of &lt;see cref=&quot;_chars&quot;/&gt; to at least the specified &lt;paramref name=&quot;requiredMinCapacity&quot;/&gt;.</a>
<a name="ln628">    /// &lt;/summary&gt;</a>
<a name="ln629">    [MethodImpl(MethodImplOptions.AggressiveInlining)] // but reuse this grow logic directly in both of the above grow routines</a>
<a name="ln630">    void GrowCore(uint requiredMinCapacity)</a>
<a name="ln631">    {</a>
<a name="ln632">        // We want the max of how much space we actually required and doubling our capacity (without going beyond</a>
<a name="ln633">        // the max allowed length). We also want to avoid asking for small arrays, to reduce the number of times we</a>
<a name="ln634">        // need to grow, and since we're working with unsigned ints that could technically overflow if someone tried</a>
<a name="ln635">        // to, for example, append a huge string to a huge string, we also clamp to int.MaxValue.</a>
<a name="ln636">        // Even if the array creation fails in such a case, we may later fail in ToStringAndClear.</a>
<a name="ln637"> </a>
<a name="ln638">        var newCapacity = Math.Max(requiredMinCapacity, Math.Min((uint)_chars.Length * 2, StringMaxLength));</a>
<a name="ln639">        var arraySize = (int)InternalMath.Clamp(newCapacity, MinimumArrayPoolLength, int.MaxValue);</a>
<a name="ln640"> </a>
<a name="ln641">        var newArray = ArrayPool&lt;char&gt;.Shared.Rent(arraySize);</a>
<a name="ln642">        _chars.Slice(0, _pos).CopyTo(newArray);</a>
<a name="ln643"> </a>
<a name="ln644">        var toReturn = _arrayToReturnToPool;</a>
<a name="ln645">        _chars = _arrayToReturnToPool = newArray;</a>
<a name="ln646"> </a>
<a name="ln647">        if (toReturn is not null)</a>
<a name="ln648">        {</a>
<a name="ln649">            ArrayPool&lt;char&gt;.Shared.Return(toReturn);</a>
<a name="ln650">        }</a>
<a name="ln651">    }</a>
<a name="ln652"> </a>
<a name="ln653">    bool TryFormatWithExtensions&lt;T&gt;(T value, ReadOnlySpan&lt;char&gt; format)</a>
<a name="ln654">    {</a>
<a name="ln655">        int charsWritten;</a>
<a name="ln656">        switch (value)</a>
<a name="ln657">        {</a>
<a name="ln658">            case int cval:</a>
<a name="ln659">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln660">                {</a>
<a name="ln661">                    Grow();</a>
<a name="ln662">                }</a>
<a name="ln663">                break;</a>
<a name="ln664">            case bool cval:</a>
<a name="ln665">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten))</a>
<a name="ln666">                {</a>
<a name="ln667">                    Grow();</a>
<a name="ln668">                }</a>
<a name="ln669">                break;</a>
<a name="ln670">            case byte cval:</a>
<a name="ln671">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln672">                {</a>
<a name="ln673">                    Grow();</a>
<a name="ln674">                }</a>
<a name="ln675">                break;</a>
<a name="ln676">            case float cval:</a>
<a name="ln677">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln678">                {</a>
<a name="ln679">                    Grow();</a>
<a name="ln680">                }</a>
<a name="ln681">                break;</a>
<a name="ln682">            case double cval:</a>
<a name="ln683">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln684">                {</a>
<a name="ln685">                    Grow();</a>
<a name="ln686">                }</a>
<a name="ln687">                break;</a>
<a name="ln688">            case DateTime cval:</a>
<a name="ln689">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln690">                {</a>
<a name="ln691">                    Grow();</a>
<a name="ln692">                }</a>
<a name="ln693">                break;</a>
<a name="ln694">            case DateTimeOffset cval:</a>
<a name="ln695">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln696">                {</a>
<a name="ln697">                    Grow();</a>
<a name="ln698">                }</a>
<a name="ln699">                break;</a>
<a name="ln700">            case decimal cval:</a>
<a name="ln701">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln702">                {</a>
<a name="ln703">                    Grow();</a>
<a name="ln704">                }</a>
<a name="ln705">                break;</a>
<a name="ln706">            case long cval:</a>
<a name="ln707">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln708">                {</a>
<a name="ln709">                    Grow();</a>
<a name="ln710">                }</a>
<a name="ln711">                break;</a>
<a name="ln712">            case short cval:</a>
<a name="ln713">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln714">                {</a>
<a name="ln715">                    Grow();</a>
<a name="ln716">                }</a>
<a name="ln717">                break;</a>
<a name="ln718">            case ushort cval:</a>
<a name="ln719">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln720">                {</a>
<a name="ln721">                    Grow();</a>
<a name="ln722">                }</a>
<a name="ln723">                break;</a>
<a name="ln724">            case uint cval:</a>
<a name="ln725">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln726">                {</a>
<a name="ln727">                    Grow();</a>
<a name="ln728">                }</a>
<a name="ln729">                break;</a>
<a name="ln730">            case ulong cval:</a>
<a name="ln731">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln732">                {</a>
<a name="ln733">                    Grow();</a>
<a name="ln734">                }</a>
<a name="ln735">                break;</a>
<a name="ln736">            case sbyte cval:</a>
<a name="ln737">                while (!cval.TryFormat(_chars.Slice(_pos), out charsWritten, format, _provider))</a>
<a name="ln738">                {</a>
<a name="ln739">                    Grow();</a>
<a name="ln740">                }</a>
<a name="ln741">                break;</a>
<a name="ln742">            default:</a>
<a name="ln743">                return false;</a>
<a name="ln744">        }</a>
<a name="ln745"> </a>
<a name="ln746">        _pos += charsWritten;</a>
<a name="ln747">        return true;</a>
<a name="ln748">    }</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">[ExcludeFromCodeCoverage]</a>
<a name="ln752">static file class InternalMath</a>
<a name="ln753">{</a>
<a name="ln754">    [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln755">    public static uint Clamp(uint value, uint min, uint max)</a>
<a name="ln756">    {</a>
<a name="ln757">        if (min &gt; max)</a>
<a name="ln758">        {</a>
<a name="ln759">            ThrowMinMaxException(min, max);</a>
<a name="ln760">        }</a>
<a name="ln761"> </a>
<a name="ln762">        if (value &lt; min)</a>
<a name="ln763">        {</a>
<a name="ln764">            return min;</a>
<a name="ln765">        }</a>
<a name="ln766">        else if (value &gt; max)</a>
<a name="ln767">        {</a>
<a name="ln768">            return max;</a>
<a name="ln769">        }</a>
<a name="ln770"> </a>
<a name="ln771">        return value;</a>
<a name="ln772">    }</a>
<a name="ln773"> </a>
<a name="ln774">    [DoesNotReturn]</a>
<a name="ln775">    static void ThrowMinMaxException&lt;T&gt;(T min, T max) =&gt;</a>
<a name="ln776">        throw new ArgumentException(string.Format(SR.Argument_MinMaxValue, min, max));</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779">[ExcludeFromCodeCoverage]</a>
<a name="ln780">static file class SR</a>
<a name="ln781">{</a>
<a name="ln782">    public const string Argument_MinMaxValue = &quot;'{0}' cannot be greater than {1}.&quot;;</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785">#endif</a>
</code></pre>
<div class="balloon" rel="79"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3117/" target="_blank">V3117</a> Constructor parameters 'literalLength', 'formattedCount' are not used.</p></div>
<div class="balloon" rel="264"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="319"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value' for null will always return false when generic type is instantiated with a value type.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>