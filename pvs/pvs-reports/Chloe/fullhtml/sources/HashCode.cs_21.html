<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>HashCode.cs</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cs">
<a name="ln1">﻿// Licensed to the .NET Foundation under one or more agreements.</a>
<a name="ln2">// The .NET Foundation licenses this file to you under the MIT license.</a>
<a name="ln3"> </a>
<a name="ln4">/*</a>
<a name="ln5"> </a>
<a name="ln6">The xxHash32 implementation is based on the code published by Yann Collet:</a>
<a name="ln7">https://raw.githubusercontent.com/Cyan4973/xxHash/5c174cfa4e45a42f94082dc0d4539b39696afea1/xxhash.c</a>
<a name="ln8"> </a>
<a name="ln9">  xxHash - Fast Hash algorithm</a>
<a name="ln10">  Copyright (C) 2012-2016, Yann Collet</a>
<a name="ln11"> </a>
<a name="ln12">  BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)</a>
<a name="ln13"> </a>
<a name="ln14">  Redistribution and use in source and binary forms, with or without</a>
<a name="ln15">  modification, are permitted provided that the following conditions are</a>
<a name="ln16">  met:</a>
<a name="ln17"> </a>
<a name="ln18">  * Redistributions of source code must retain the above copyright</a>
<a name="ln19">  notice, this list of conditions and the following disclaimer.</a>
<a name="ln20">  * Redistributions in binary form must reproduce the above</a>
<a name="ln21">  copyright notice, this list of conditions and the following disclaimer</a>
<a name="ln22">  in the documentation and/or other materials provided with the</a>
<a name="ln23">  distribution.</a>
<a name="ln24"> </a>
<a name="ln25">  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln26">  &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln27">  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln28">  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln29">  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln30">  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</a>
<a name="ln31">  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</a>
<a name="ln32">  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</a>
<a name="ln33">  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</a>
<a name="ln34">  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</a>
<a name="ln35">  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln36"> </a>
<a name="ln37">  You can contact the author at :</a>
<a name="ln38">  - xxHash homepage: http://www.xxhash.com</a>
<a name="ln39">  - xxHash source repository : https://github.com/Cyan4973/xxHash</a>
<a name="ln40"> </a>
<a name="ln41">*/</a>
<a name="ln42"> </a>
<a name="ln43">#if NETFX || NETSTANDARD2</a>
<a name="ln44"> </a>
<a name="ln45">//注：此文件代码来源 .net 6 以上版本</a>
<a name="ln46"> </a>
<a name="ln47">using Chloe.Numerics;</a>
<a name="ln48">using System.Collections.Generic;</a>
<a name="ln49">using System.ComponentModel;</a>
<a name="ln50">using System.Diagnostics;</a>
<a name="ln51">using System.Numerics;</a>
<a name="ln52">using System.Runtime.CompilerServices;</a>
<a name="ln53">using System.Runtime.InteropServices;</a>
<a name="ln54"> </a>
<a name="ln55">#pragma warning disable CA1066 // Implement IEquatable when overriding Object.Equals</a>
<a name="ln56"> </a>
<a name="ln57">namespace Chloe</a>
<a name="ln58">{</a>
<a name="ln59">    // xxHash32 is used for the hash code.</a>
<a name="ln60">    // https://github.com/Cyan4973/xxHash</a>
<a name="ln61"> </a>
<a name="ln62">    public struct HashCode</a>
<a name="ln63">    {</a>
<a name="ln64">        private static readonly uint s_seed = GenerateGlobalSeed();</a>
<a name="ln65"> </a>
<a name="ln66">        private const uint Prime1 = 2654435761U;</a>
<a name="ln67">        private const uint Prime2 = 2246822519U;</a>
<a name="ln68">        private const uint Prime3 = 3266489917U;</a>
<a name="ln69">        private const uint Prime4 = 668265263U;</a>
<a name="ln70">        private const uint Prime5 = 374761393U;</a>
<a name="ln71"> </a>
<a name="ln72">        private uint _v1, _v2, _v3, _v4;</a>
<a name="ln73">        private uint _queue1, _queue2, _queue3;</a>
<a name="ln74">        private uint _length;</a>
<a name="ln75"> </a>
<a name="ln76">        private static unsafe uint GenerateGlobalSeed()</a>
<a name="ln77">        {</a>
<a name="ln78">            Random rnd = new Random();</a>
<a name="ln79">            Byte[] bytes = new Byte[sizeof(uint)];</a>
<a name="ln80">            rnd.NextBytes(bytes);</a>
<a name="ln81">            return BitConverter.ToUInt32(bytes, 0);</a>
<a name="ln82"> </a>
<a name="ln83">            //C# 6 7 8 官方实现</a>
<a name="ln84">            //uint result;</a>
<a name="ln85">            //Interop.GetRandomBytes((byte*)&amp;result, sizeof(uint));</a>
<a name="ln86">            //return result;</a>
<a name="ln87">        }</a>
<a name="ln88"> </a>
<a name="ln89">        public static int Combine&lt;T1&gt;(T1 value1)</a>
<a name="ln90">        {</a>
<a name="ln91">            // Provide a way of diffusing bits from something with a limited</a>
<a name="ln92">            // input hash space. For example, many enums only have a few</a>
<a name="ln93">            // possible hashes, only using the bottom few bits of the code. Some</a>
<a name="ln94">            // collections are built on the assumption that hashes are spread</a>
<a name="ln95">            // over a larger space, so diffusing the bits may help the</a>
<a name="ln96">            // collection work more efficiently.</a>
<a name="ln97"> </a>
<a name="ln98">            uint hc1 = (uint)(value1?.GetHashCode() ?? 0);</a>
<a name="ln99"> </a>
<a name="ln100">            uint hash = MixEmptyState();</a>
<a name="ln101">            hash += 4;</a>
<a name="ln102"> </a>
<a name="ln103">            hash = QueueRound(hash, hc1);</a>
<a name="ln104"> </a>
<a name="ln105">            hash = MixFinal(hash);</a>
<a name="ln106">            return (int)hash;</a>
<a name="ln107">        }</a>
<a name="ln108"> </a>
<a name="ln109">        public static int Combine&lt;T1, T2&gt;(T1 value1, T2 value2)</a>
<a name="ln110">        {</a>
<a name="ln111">            uint hc1 = (uint)(value1?.GetHashCode() ?? 0);</a>
<a name="ln112">            uint hc2 = (uint)(value2?.GetHashCode() ?? 0);</a>
<a name="ln113"> </a>
<a name="ln114">            uint hash = MixEmptyState();</a>
<a name="ln115">            hash += 8;</a>
<a name="ln116"> </a>
<a name="ln117">            hash = QueueRound(hash, hc1);</a>
<a name="ln118">            hash = QueueRound(hash, hc2);</a>
<a name="ln119"> </a>
<a name="ln120">            hash = MixFinal(hash);</a>
<a name="ln121">            return (int)hash;</a>
<a name="ln122">        }</a>
<a name="ln123"> </a>
<a name="ln124">        public static int Combine&lt;T1, T2, T3&gt;(T1 value1, T2 value2, T3 value3)</a>
<a name="ln125">        {</a>
<a name="ln126">            uint hc1 = (uint)(value1?.GetHashCode() ?? 0);</a>
<a name="ln127">            uint hc2 = (uint)(value2?.GetHashCode() ?? 0);</a>
<a name="ln128">            uint hc3 = (uint)(value3?.GetHashCode() ?? 0);</a>
<a name="ln129"> </a>
<a name="ln130">            uint hash = MixEmptyState();</a>
<a name="ln131">            hash += 12;</a>
<a name="ln132"> </a>
<a name="ln133">            hash = QueueRound(hash, hc1);</a>
<a name="ln134">            hash = QueueRound(hash, hc2);</a>
<a name="ln135">            hash = QueueRound(hash, hc3);</a>
<a name="ln136"> </a>
<a name="ln137">            hash = MixFinal(hash);</a>
<a name="ln138">            return (int)hash;</a>
<a name="ln139">        }</a>
<a name="ln140"> </a>
<a name="ln141">        public static int Combine&lt;T1, T2, T3, T4&gt;(T1 value1, T2 value2, T3 value3, T4 value4)</a>
<a name="ln142">        {</a>
<a name="ln143">            uint hc1 = (uint)(value1?.GetHashCode() ?? 0);</a>
<a name="ln144">            uint hc2 = (uint)(value2?.GetHashCode() ?? 0);</a>
<a name="ln145">            uint hc3 = (uint)(value3?.GetHashCode() ?? 0);</a>
<a name="ln146">            uint hc4 = (uint)(value4?.GetHashCode() ?? 0);</a>
<a name="ln147"> </a>
<a name="ln148">            Initialize(out uint v1, out uint v2, out uint v3, out uint v4);</a>
<a name="ln149"> </a>
<a name="ln150">            v1 = Round(v1, hc1);</a>
<a name="ln151">            v2 = Round(v2, hc2);</a>
<a name="ln152">            v3 = Round(v3, hc3);</a>
<a name="ln153">            v4 = Round(v4, hc4);</a>
<a name="ln154"> </a>
<a name="ln155">            uint hash = MixState(v1, v2, v3, v4);</a>
<a name="ln156">            hash += 16;</a>
<a name="ln157"> </a>
<a name="ln158">            hash = MixFinal(hash);</a>
<a name="ln159">            return (int)hash;</a>
<a name="ln160">        }</a>
<a name="ln161"> </a>
<a name="ln162">        public static int Combine&lt;T1, T2, T3, T4, T5&gt;(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5)</a>
<a name="ln163">        {</a>
<a name="ln164">            uint hc1 = (uint)(value1?.GetHashCode() ?? 0);</a>
<a name="ln165">            uint hc2 = (uint)(value2?.GetHashCode() ?? 0);</a>
<a name="ln166">            uint hc3 = (uint)(value3?.GetHashCode() ?? 0);</a>
<a name="ln167">            uint hc4 = (uint)(value4?.GetHashCode() ?? 0);</a>
<a name="ln168">            uint hc5 = (uint)(value5?.GetHashCode() ?? 0);</a>
<a name="ln169"> </a>
<a name="ln170">            Initialize(out uint v1, out uint v2, out uint v3, out uint v4);</a>
<a name="ln171"> </a>
<a name="ln172">            v1 = Round(v1, hc1);</a>
<a name="ln173">            v2 = Round(v2, hc2);</a>
<a name="ln174">            v3 = Round(v3, hc3);</a>
<a name="ln175">            v4 = Round(v4, hc4);</a>
<a name="ln176"> </a>
<a name="ln177">            uint hash = MixState(v1, v2, v3, v4);</a>
<a name="ln178">            hash += 20;</a>
<a name="ln179"> </a>
<a name="ln180">            hash = QueueRound(hash, hc5);</a>
<a name="ln181"> </a>
<a name="ln182">            hash = MixFinal(hash);</a>
<a name="ln183">            return (int)hash;</a>
<a name="ln184">        }</a>
<a name="ln185"> </a>
<a name="ln186">        public static int Combine&lt;T1, T2, T3, T4, T5, T6&gt;(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6)</a>
<a name="ln187">        {</a>
<a name="ln188">            uint hc1 = (uint)(value1?.GetHashCode() ?? 0);</a>
<a name="ln189">            uint hc2 = (uint)(value2?.GetHashCode() ?? 0);</a>
<a name="ln190">            uint hc3 = (uint)(value3?.GetHashCode() ?? 0);</a>
<a name="ln191">            uint hc4 = (uint)(value4?.GetHashCode() ?? 0);</a>
<a name="ln192">            uint hc5 = (uint)(value5?.GetHashCode() ?? 0);</a>
<a name="ln193">            uint hc6 = (uint)(value6?.GetHashCode() ?? 0);</a>
<a name="ln194"> </a>
<a name="ln195">            Initialize(out uint v1, out uint v2, out uint v3, out uint v4);</a>
<a name="ln196"> </a>
<a name="ln197">            v1 = Round(v1, hc1);</a>
<a name="ln198">            v2 = Round(v2, hc2);</a>
<a name="ln199">            v3 = Round(v3, hc3);</a>
<a name="ln200">            v4 = Round(v4, hc4);</a>
<a name="ln201"> </a>
<a name="ln202">            uint hash = MixState(v1, v2, v3, v4);</a>
<a name="ln203">            hash += 24;</a>
<a name="ln204"> </a>
<a name="ln205">            hash = QueueRound(hash, hc5);</a>
<a name="ln206">            hash = QueueRound(hash, hc6);</a>
<a name="ln207"> </a>
<a name="ln208">            hash = MixFinal(hash);</a>
<a name="ln209">            return (int)hash;</a>
<a name="ln210">        }</a>
<a name="ln211"> </a>
<a name="ln212">        public static int Combine&lt;T1, T2, T3, T4, T5, T6, T7&gt;(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7)</a>
<a name="ln213">        {</a>
<a name="ln214">            uint hc1 = (uint)(value1?.GetHashCode() ?? 0);</a>
<a name="ln215">            uint hc2 = (uint)(value2?.GetHashCode() ?? 0);</a>
<a name="ln216">            uint hc3 = (uint)(value3?.GetHashCode() ?? 0);</a>
<a name="ln217">            uint hc4 = (uint)(value4?.GetHashCode() ?? 0);</a>
<a name="ln218">            uint hc5 = (uint)(value5?.GetHashCode() ?? 0);</a>
<a name="ln219">            uint hc6 = (uint)(value6?.GetHashCode() ?? 0);</a>
<a name="ln220">            uint hc7 = (uint)(value7?.GetHashCode() ?? 0);</a>
<a name="ln221"> </a>
<a name="ln222">            Initialize(out uint v1, out uint v2, out uint v3, out uint v4);</a>
<a name="ln223"> </a>
<a name="ln224">            v1 = Round(v1, hc1);</a>
<a name="ln225">            v2 = Round(v2, hc2);</a>
<a name="ln226">            v3 = Round(v3, hc3);</a>
<a name="ln227">            v4 = Round(v4, hc4);</a>
<a name="ln228"> </a>
<a name="ln229">            uint hash = MixState(v1, v2, v3, v4);</a>
<a name="ln230">            hash += 28;</a>
<a name="ln231"> </a>
<a name="ln232">            hash = QueueRound(hash, hc5);</a>
<a name="ln233">            hash = QueueRound(hash, hc6);</a>
<a name="ln234">            hash = QueueRound(hash, hc7);</a>
<a name="ln235"> </a>
<a name="ln236">            hash = MixFinal(hash);</a>
<a name="ln237">            return (int)hash;</a>
<a name="ln238">        }</a>
<a name="ln239"> </a>
<a name="ln240">        public static int Combine&lt;T1, T2, T3, T4, T5, T6, T7, T8&gt;(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8)</a>
<a name="ln241">        {</a>
<a name="ln242">            uint hc1 = (uint)(value1?.GetHashCode() ?? 0);</a>
<a name="ln243">            uint hc2 = (uint)(value2?.GetHashCode() ?? 0);</a>
<a name="ln244">            uint hc3 = (uint)(value3?.GetHashCode() ?? 0);</a>
<a name="ln245">            uint hc4 = (uint)(value4?.GetHashCode() ?? 0);</a>
<a name="ln246">            uint hc5 = (uint)(value5?.GetHashCode() ?? 0);</a>
<a name="ln247">            uint hc6 = (uint)(value6?.GetHashCode() ?? 0);</a>
<a name="ln248">            uint hc7 = (uint)(value7?.GetHashCode() ?? 0);</a>
<a name="ln249">            uint hc8 = (uint)(value8?.GetHashCode() ?? 0);</a>
<a name="ln250"> </a>
<a name="ln251">            Initialize(out uint v1, out uint v2, out uint v3, out uint v4);</a>
<a name="ln252"> </a>
<a name="ln253">            v1 = Round(v1, hc1);</a>
<a name="ln254">            v2 = Round(v2, hc2);</a>
<a name="ln255">            v3 = Round(v3, hc3);</a>
<a name="ln256">            v4 = Round(v4, hc4);</a>
<a name="ln257"> </a>
<a name="ln258">            v1 = Round(v1, hc5);</a>
<a name="ln259">            v2 = Round(v2, hc6);</a>
<a name="ln260">            v3 = Round(v3, hc7);</a>
<a name="ln261">            v4 = Round(v4, hc8);</a>
<a name="ln262"> </a>
<a name="ln263">            uint hash = MixState(v1, v2, v3, v4);</a>
<a name="ln264">            hash += 32;</a>
<a name="ln265"> </a>
<a name="ln266">            hash = MixFinal(hash);</a>
<a name="ln267">            return (int)hash;</a>
<a name="ln268">        }</a>
<a name="ln269"> </a>
<a name="ln270">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln271">        private static void Initialize(out uint v1, out uint v2, out uint v3, out uint v4)</a>
<a name="ln272">        {</a>
<a name="ln273">            v1 = s_seed + Prime1 + Prime2;</a>
<a name="ln274">            v2 = s_seed + Prime2;</a>
<a name="ln275">            v3 = s_seed;</a>
<a name="ln276">            v4 = s_seed - Prime1;</a>
<a name="ln277">        }</a>
<a name="ln278"> </a>
<a name="ln279">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln280">        private static uint Round(uint hash, uint input)</a>
<a name="ln281">        {</a>
<a name="ln282">            return BitOperations.RotateLeft(hash + input * Prime2, 13) * Prime1;</a>
<a name="ln283">        }</a>
<a name="ln284"> </a>
<a name="ln285">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln286">        private static uint QueueRound(uint hash, uint queuedValue)</a>
<a name="ln287">        {</a>
<a name="ln288">            return BitOperations.RotateLeft(hash + queuedValue * Prime3, 17) * Prime4;</a>
<a name="ln289">        }</a>
<a name="ln290"> </a>
<a name="ln291">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln292">        private static uint MixState(uint v1, uint v2, uint v3, uint v4)</a>
<a name="ln293">        {</a>
<a name="ln294">            return BitOperations.RotateLeft(v1, 1) + BitOperations.RotateLeft(v2, 7) + BitOperations.RotateLeft(v3, 12) + BitOperations.RotateLeft(v4, 18);</a>
<a name="ln295">        }</a>
<a name="ln296"> </a>
<a name="ln297">        private static uint MixEmptyState()</a>
<a name="ln298">        {</a>
<a name="ln299">            return s_seed + Prime5;</a>
<a name="ln300">        }</a>
<a name="ln301"> </a>
<a name="ln302">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln303">        private static uint MixFinal(uint hash)</a>
<a name="ln304">        {</a>
<a name="ln305">            hash ^= hash &gt;&gt; 15;</a>
<a name="ln306">            hash *= Prime2;</a>
<a name="ln307">            hash ^= hash &gt;&gt; 13;</a>
<a name="ln308">            hash *= Prime3;</a>
<a name="ln309">            hash ^= hash &gt;&gt; 16;</a>
<a name="ln310">            return hash;</a>
<a name="ln311">        }</a>
<a name="ln312"> </a>
<a name="ln313">        public void Add&lt;T&gt;(T value)</a>
<a name="ln314">        {</a>
<a name="ln315">            Add(value?.GetHashCode() ?? 0);</a>
<a name="ln316">        }</a>
<a name="ln317"> </a>
<a name="ln318">        public void Add&lt;T&gt;(T value, IEqualityComparer&lt;T&gt;? comparer)</a>
<a name="ln319">        {</a>
<a name="ln320">            Add(value is null ? 0 : (comparer?.GetHashCode(value) ?? value.GetHashCode()));</a>
<a name="ln321">        }</a>
<a name="ln322"> </a>
<a name="ln323">        ///// &lt;summary&gt;Adds a span of bytes to the hash code.&lt;/summary&gt;</a>
<a name="ln324">        ///// &lt;param name=&quot;value&quot;&gt;The span.&lt;/param&gt;</a>
<a name="ln325">        ///// &lt;remarks&gt;</a>
<a name="ln326">        ///// This method does not guarantee that the result of adding a span of bytes will match</a>
<a name="ln327">        ///// the result of adding the same bytes individually.</a>
<a name="ln328">        ///// &lt;/remarks&gt;</a>
<a name="ln329">        //public void AddBytes(ReadOnlySpan&lt;byte&gt; value)</a>
<a name="ln330">        //{</a>
<a name="ln331">        //    ref byte pos = ref MemoryMarshal.GetReference(value);</a>
<a name="ln332">        //    ref byte end = ref Unsafe.Add(ref pos, value.Length);</a>
<a name="ln333"> </a>
<a name="ln334">        //    if (value.Length &lt; (sizeof(int) * 4))</a>
<a name="ln335">        //    {</a>
<a name="ln336">        //        goto Small;</a>
<a name="ln337">        //    }</a>
<a name="ln338"> </a>
<a name="ln339">        //    // Usually Add calls Initialize but if we haven't used HashCode before it won't have been called.</a>
<a name="ln340">        //    if (_length == 0)</a>
<a name="ln341">        //    {</a>
<a name="ln342">        //        Initialize(out _v1, out _v2, out _v3, out _v4);</a>
<a name="ln343">        //    }</a>
<a name="ln344">        //    else</a>
<a name="ln345">        //    {</a>
<a name="ln346">        //        // If we have at least 16 bytes to hash, we can add them in 16-byte batches,</a>
<a name="ln347">        //        // but we first have to add enough data to flush any queued values.</a>
<a name="ln348">        //        switch (_length % 4)</a>
<a name="ln349">        //        {</a>
<a name="ln350">        //            case 1:</a>
<a name="ln351">        //                Debug.Assert(Unsafe.ByteOffset(ref pos, ref end) &gt;= sizeof(int));</a>
<a name="ln352">        //                Add(Unsafe.ReadUnaligned&lt;int&gt;(ref pos));</a>
<a name="ln353">        //                pos = ref Unsafe.Add(ref pos, sizeof(int));</a>
<a name="ln354">        //                goto case 2;</a>
<a name="ln355">        //            case 2:</a>
<a name="ln356">        //                Debug.Assert(Unsafe.ByteOffset(ref pos, ref end) &gt;= sizeof(int));</a>
<a name="ln357">        //                Add(Unsafe.ReadUnaligned&lt;int&gt;(ref pos));</a>
<a name="ln358">        //                pos = ref Unsafe.Add(ref pos, sizeof(int));</a>
<a name="ln359">        //                goto case 3;</a>
<a name="ln360">        //            case 3:</a>
<a name="ln361">        //                Debug.Assert(Unsafe.ByteOffset(ref pos, ref end) &gt;= sizeof(int));</a>
<a name="ln362">        //                Add(Unsafe.ReadUnaligned&lt;int&gt;(ref pos));</a>
<a name="ln363">        //                pos = ref Unsafe.Add(ref pos, sizeof(int));</a>
<a name="ln364">        //                break;</a>
<a name="ln365">        //        }</a>
<a name="ln366">        //    }</a>
<a name="ln367"> </a>
<a name="ln368">        //    // With the queue clear, we add sixteen bytes at a time until the input has fewer than sixteen bytes remaining.</a>
<a name="ln369">        //    // We first have to round the end pointer to the nearest 16-byte block from the offset. This makes the loop's condition simpler.</a>
<a name="ln370">        //    ref byte blockEnd = ref Unsafe.Subtract(ref end, Unsafe.ByteOffset(ref pos, ref end) % (sizeof(int) * 4));</a>
<a name="ln371">        //    while (Unsafe.IsAddressLessThan(ref pos, ref blockEnd))</a>
<a name="ln372">        //    {</a>
<a name="ln373">        //        Debug.Assert(Unsafe.ByteOffset(ref pos, ref blockEnd) &gt;= (sizeof(int) * 4));</a>
<a name="ln374">        //        uint v1 = Unsafe.ReadUnaligned&lt;uint&gt;(ref pos);</a>
<a name="ln375">        //        _v1 = Round(_v1, v1);</a>
<a name="ln376">        //        uint v2 = Unsafe.ReadUnaligned&lt;uint&gt;(ref Unsafe.Add(ref pos, sizeof(int) * 1));</a>
<a name="ln377">        //        _v2 = Round(_v2, v2);</a>
<a name="ln378">        //        uint v3 = Unsafe.ReadUnaligned&lt;uint&gt;(ref Unsafe.Add(ref pos, sizeof(int) * 2));</a>
<a name="ln379">        //        _v3 = Round(_v3, v3);</a>
<a name="ln380">        //        uint v4 = Unsafe.ReadUnaligned&lt;uint&gt;(ref Unsafe.Add(ref pos, sizeof(int) * 3));</a>
<a name="ln381">        //        _v4 = Round(_v4, v4);</a>
<a name="ln382"> </a>
<a name="ln383">        //        _length += 4;</a>
<a name="ln384">        //        pos = ref Unsafe.Add(ref pos, sizeof(int) * 4);</a>
<a name="ln385">        //    }</a>
<a name="ln386"> </a>
<a name="ln387">        //Small:</a>
<a name="ln388">        //    // Add four bytes at a time until the input has fewer than four bytes remaining.</a>
<a name="ln389">        //    while (Unsafe.ByteOffset(ref pos, ref end) &gt;= sizeof(int))</a>
<a name="ln390">        //    {</a>
<a name="ln391">        //        Add(Unsafe.ReadUnaligned&lt;int&gt;(ref pos));</a>
<a name="ln392">        //        pos = ref Unsafe.Add(ref pos, sizeof(int));</a>
<a name="ln393">        //    }</a>
<a name="ln394"> </a>
<a name="ln395">        //    // Add the remaining bytes a single byte at a time.</a>
<a name="ln396">        //    while (Unsafe.IsAddressLessThan(ref pos, ref end))</a>
<a name="ln397">        //    {</a>
<a name="ln398">        //        Add((int)pos);</a>
<a name="ln399">        //        pos = ref Unsafe.Add(ref pos, 1);</a>
<a name="ln400">        //    }</a>
<a name="ln401">        //}</a>
<a name="ln402"> </a>
<a name="ln403">        private void Add(int value)</a>
<a name="ln404">        {</a>
<a name="ln405">            // The original xxHash works as follows:</a>
<a name="ln406">            // 0. Initialize immediately. We can't do this in a struct (no</a>
<a name="ln407">            //    default ctor).</a>
<a name="ln408">            // 1. Accumulate blocks of length 16 (4 uints) into 4 accumulators.</a>
<a name="ln409">            // 2. Accumulate remaining blocks of length 4 (1 uint) into the</a>
<a name="ln410">            //    hash.</a>
<a name="ln411">            // 3. Accumulate remaining blocks of length 1 into the hash.</a>
<a name="ln412"> </a>
<a name="ln413">            // There is no need for #3 as this type only accepts ints. _queue1,</a>
<a name="ln414">            // _queue2 and _queue3 are basically a buffer so that when</a>
<a name="ln415">            // ToHashCode is called we can execute #2 correctly.</a>
<a name="ln416"> </a>
<a name="ln417">            // We need to initialize the xxHash32 state (_v1 to _v4) lazily (see</a>
<a name="ln418">            // #0) nd the last place that can be done if you look at the</a>
<a name="ln419">            // original code is just before the first block of 16 bytes is mixed</a>
<a name="ln420">            // in. The xxHash32 state is never used for streams containing fewer</a>
<a name="ln421">            // than 16 bytes.</a>
<a name="ln422"> </a>
<a name="ln423">            // To see what's really going on here, have a look at the Combine</a>
<a name="ln424">            // methods.</a>
<a name="ln425"> </a>
<a name="ln426">            uint val = (uint)value;</a>
<a name="ln427"> </a>
<a name="ln428">            // Storing the value of _length locally shaves of quite a few bytes</a>
<a name="ln429">            // in the resulting machine code.</a>
<a name="ln430">            uint previousLength = _length++;</a>
<a name="ln431">            uint position = previousLength % 4;</a>
<a name="ln432"> </a>
<a name="ln433">            // Switch can't be inlined.</a>
<a name="ln434"> </a>
<a name="ln435">            if (position == 0)</a>
<a name="ln436">                _queue1 = val;</a>
<a name="ln437">            else if (position == 1)</a>
<a name="ln438">                _queue2 = val;</a>
<a name="ln439">            else if (position == 2)</a>
<a name="ln440">                _queue3 = val;</a>
<a name="ln441">            else // position == 3</a>
<a name="ln442">            {</a>
<a name="ln443">                if (previousLength == 3)</a>
<a name="ln444">                    Initialize(out _v1, out _v2, out _v3, out _v4);</a>
<a name="ln445"> </a>
<a name="ln446">                _v1 = Round(_v1, _queue1);</a>
<a name="ln447">                _v2 = Round(_v2, _queue2);</a>
<a name="ln448">                _v3 = Round(_v3, _queue3);</a>
<a name="ln449">                _v4 = Round(_v4, val);</a>
<a name="ln450">            }</a>
<a name="ln451">        }</a>
<a name="ln452"> </a>
<a name="ln453">        public int ToHashCode()</a>
<a name="ln454">        {</a>
<a name="ln455">            // Storing the value of _length locally shaves of quite a few bytes</a>
<a name="ln456">            // in the resulting machine code.</a>
<a name="ln457">            uint length = _length;</a>
<a name="ln458"> </a>
<a name="ln459">            // position refers to the *next* queue position in this method, so</a>
<a name="ln460">            // position == 1 means that _queue1 is populated; _queue2 would have</a>
<a name="ln461">            // been populated on the next call to Add.</a>
<a name="ln462">            uint position = length % 4;</a>
<a name="ln463"> </a>
<a name="ln464">            // If the length is less than 4, _v1 to _v4 don't contain anything</a>
<a name="ln465">            // yet. xxHash32 treats this differently.</a>
<a name="ln466"> </a>
<a name="ln467">            uint hash = length &lt; 4 ? MixEmptyState() : MixState(_v1, _v2, _v3, _v4);</a>
<a name="ln468"> </a>
<a name="ln469">            // _length is incremented once per Add(Int32) and is therefore 4</a>
<a name="ln470">            // times too small (xxHash length is in bytes, not ints).</a>
<a name="ln471"> </a>
<a name="ln472">            hash += length * 4;</a>
<a name="ln473"> </a>
<a name="ln474">            // Mix what remains in the queue</a>
<a name="ln475"> </a>
<a name="ln476">            // Switch can't be inlined right now, so use as few branches as</a>
<a name="ln477">            // possible by manually excluding impossible scenarios (position &gt; 1</a>
<a name="ln478">            // is always false if position is not &gt; 0).</a>
<a name="ln479">            if (position &gt; 0)</a>
<a name="ln480">            {</a>
<a name="ln481">                hash = QueueRound(hash, _queue1);</a>
<a name="ln482">                if (position &gt; 1)</a>
<a name="ln483">                {</a>
<a name="ln484">                    hash = QueueRound(hash, _queue2);</a>
<a name="ln485">                    if (position &gt; 2)</a>
<a name="ln486">                        hash = QueueRound(hash, _queue3);</a>
<a name="ln487">                }</a>
<a name="ln488">            }</a>
<a name="ln489"> </a>
<a name="ln490">            hash = MixFinal(hash);</a>
<a name="ln491">            return (int)hash;</a>
<a name="ln492">        }</a>
<a name="ln493"> </a>
<a name="ln494">#pragma warning disable 0809</a>
<a name="ln495">        // Obsolete member 'memberA' overrides non-obsolete member 'memberB'.</a>
<a name="ln496">        // Disallowing GetHashCode and Equals is by design</a>
<a name="ln497"> </a>
<a name="ln498">        // * We decided to not override GetHashCode() to produce the hash code</a>
<a name="ln499">        //   as this would be weird, both naming-wise as well as from a</a>
<a name="ln500">        //   behavioral standpoint (GetHashCode() should return the object's</a>
<a name="ln501">        //   hash code, not the one being computed).</a>
<a name="ln502"> </a>
<a name="ln503">        // * Even though ToHashCode() can be called safely multiple times on</a>
<a name="ln504">        //   this implementation, it is not part of the contract. If the</a>
<a name="ln505">        //   implementation has to change in the future we don't want to worry</a>
<a name="ln506">        //   about people who might have incorrectly used this type.</a>
<a name="ln507"> </a>
<a name="ln508">        [Obsolete(&quot;HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.&quot;, error: true)]</a>
<a name="ln509">        [EditorBrowsable(EditorBrowsableState.Never)]</a>
<a name="ln510">        public override int GetHashCode() =&gt; throw new NotSupportedException(&quot;SR.HashCode_HashCodeNotSupported&quot;);</a>
<a name="ln511"> </a>
<a name="ln512">        [Obsolete(&quot;HashCode is a mutable struct and should not be compared with other HashCodes.&quot;, error: true)]</a>
<a name="ln513">        [EditorBrowsable(EditorBrowsableState.Never)]</a>
<a name="ln514">        public override bool Equals(object? obj) =&gt; throw new NotSupportedException(&quot;SR.HashCode_EqualityNotSupported&quot;);</a>
<a name="ln515">#pragma warning restore 0809</a>
<a name="ln516">    }</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">#endif</a>
</code></pre>
<div class="balloon" rel="273"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3056/" target="_blank">V3056</a> Consider reviewing the correctness of 'Prime2' item's usage.</p></div>
<div class="balloon" rel="98"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value1' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="111"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value1' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="112"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value2' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="126"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value1' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="127"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value2' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="128"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value3' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="143"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value1' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="144"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value2' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="145"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value3' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="146"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value4' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="164"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value1' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="165"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value2' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="166"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value3' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="167"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value4' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="168"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value5' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="188"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value1' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="189"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value2' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="190"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value3' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="191"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value4' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="192"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value5' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="193"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value6' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="214"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value1' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="215"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value2' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="216"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value3' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="217"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value4' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="218"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value5' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="219"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value6' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="220"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value7' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="242"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value1' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="243"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value2' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="244"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value3' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="245"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value4' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="246"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value5' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="247"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value6' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="248"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value7' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="249"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value8' for null will always return false when generic type is instantiated with a value type.</p></div>
<div class="balloon" rel="315"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3111/" target="_blank">V3111</a> Checking value of 'value' for null will always return false when generic type is instantiated with a value type.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>