<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>DrawingCanvas.cs</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cs">
<a name="ln1">using System;</a>
<a name="ln2">using System.Collections.Generic;</a>
<a name="ln3">using System.ComponentModel;</a>
<a name="ln4">using System.Linq;</a>
<a name="ln5">using System.Windows;</a>
<a name="ln6">using System.Windows.Controls;</a>
<a name="ln7">using System.Windows.Documents;</a>
<a name="ln8">using System.Windows.Ink;</a>
<a name="ln9">using System.Windows.Input;</a>
<a name="ln10">using System.Windows.Media;</a>
<a name="ln11">using System.Windows.Shapes;</a>
<a name="ln12">using ScreenToGif.Controls.Shapes;</a>
<a name="ln13">using ScreenToGif.Domain.Events;</a>
<a name="ln14"> </a>
<a name="ln15">namespace ScreenToGif.Controls;</a>
<a name="ln16"> </a>
<a name="ln17">internal class DrawingCanvas : Control</a>
<a name="ln18">{</a>
<a name="ln19">    internal enum DrawingModes</a>
<a name="ln20">    {</a>
<a name="ln21">        None = 0,</a>
<a name="ln22">        Ink,</a>
<a name="ln23">        Select,</a>
<a name="ln24">        EraseByPoint,</a>
<a name="ln25">        EraseByObject,</a>
<a name="ln26">        Shape</a>
<a name="ln27">    }</a>
<a name="ln28"> </a>
<a name="ln29">    internal enum Shapes</a>
<a name="ln30">    {</a>
<a name="ln31">        Rectangle,</a>
<a name="ln32">        Ellipse,</a>
<a name="ln33">        Triangle,</a>
<a name="ln34">        Arrow,</a>
<a name="ln35">        Line,</a>
<a name="ln36">    }</a>
<a name="ln37"> </a>
<a name="ln38"> </a>
<a name="ln39">    #region Variables</a>
<a name="ln40"> </a>
<a name="ln41">    private Canvas _mainCanvas;</a>
<a name="ln42">    private InkCanvas _mainInkCanvas;</a>
<a name="ln43"> </a>
<a name="ln44">    private AdornerLayer _adornerLayer;</a>
<a name="ln45"> </a>
<a name="ln46">    /// &lt;summary&gt;</a>
<a name="ln47">    /// The start point for the drag operation.</a>
<a name="ln48">    /// &lt;/summary&gt;</a>
<a name="ln49">    private Point _startPoint;</a>
<a name="ln50"> </a>
<a name="ln51">    /// &lt;summary&gt;</a>
<a name="ln52">    /// The list of currently selected shapes. All selected shapes will have their own element adorner.</a>
<a name="ln53">    /// &lt;/summary&gt;</a>
<a name="ln54">    private readonly List&lt;Shape&gt; _selectedShapes = new List&lt;Shape&gt;();</a>
<a name="ln55"> </a>
<a name="ln56">    /// &lt;summary&gt;</a>
<a name="ln57">    /// The current shape being drawn.</a>
<a name="ln58">    /// &lt;/summary&gt;</a>
<a name="ln59">    private Shape _currentShape;</a>
<a name="ln60"> </a>
<a name="ln61">    /// &lt;summary&gt;</a>
<a name="ln62">    /// The most distant point within the shape's boundary for the resize operation.</a>
<a name="ln63">    /// &lt;/summary&gt;</a>
<a name="ln64">    private Point _mostDistantPoint;</a>
<a name="ln65"> </a>
<a name="ln66">    /// &lt;summary&gt;</a>
<a name="ln67">    /// The less distant point (current point) within the shape's boundary for the resize operation.</a>
<a name="ln68">    /// &lt;/summary&gt;</a>
<a name="ln69">    private Point _currentPoint;</a>
<a name="ln70"> </a>
<a name="ln71">    /// &lt;summary&gt;</a>
<a name="ln72">    /// Horizontal orientation of the resize operation.</a>
<a name="ln73">    /// &lt;/summary&gt;</a>
<a name="ln74">    private bool _isRightToLeft;</a>
<a name="ln75"> </a>
<a name="ln76">    /// &lt;summary&gt;</a>
<a name="ln77">    /// Vertical orientation of the resize operation.</a>
<a name="ln78">    /// &lt;/summary&gt;</a>
<a name="ln79">    private bool _isBottomToTop;</a>
<a name="ln80"> </a>
<a name="ln81">    #endregion</a>
<a name="ln82"> </a>
<a name="ln83">    #region Dependency properties</a>
<a name="ln84"> </a>
<a name="ln85">    internal static readonly DependencyProperty DrawingModeProperty = DependencyProperty.Register(nameof(DrawingMode), typeof(DrawingModes), typeof(DrawingCanvas), new PropertyMetadata(default(DrawingModes), DrawingMode_PropertyChanged));</a>
<a name="ln86"> </a>
<a name="ln87">    internal static readonly DependencyProperty CurrentShapeProperty = DependencyProperty.Register(nameof(CurrentShape), typeof(Shapes), typeof(DrawingCanvas), new PropertyMetadata(default(Shapes)));</a>
<a name="ln88"> </a>
<a name="ln89">    internal static readonly DependencyProperty SelectionProperty = DependencyProperty.Register(nameof(Selection), typeof(Rect), typeof(DrawingCanvas), new PropertyMetadata(default(Rect)));</a>
<a name="ln90"> </a>
<a name="ln91">    internal static readonly DependencyProperty RenderRegionProperty = DependencyProperty.Register(nameof(RenderRegion), typeof(Rect), typeof(DrawingCanvas), new PropertyMetadata(default(Rect)));</a>
<a name="ln92"> </a>
<a name="ln93">    internal static readonly DependencyProperty IsDrawingProperty = DependencyProperty.Register(nameof(IsDrawing), typeof(bool), typeof(DrawingCanvas), new PropertyMetadata(false));</a>
<a name="ln94"> </a>
<a name="ln95">    internal static readonly DependencyProperty ControlsZIndexProperty = DependencyProperty.Register(nameof(ControlsZIndex), typeof(long), typeof(DrawingCanvas), new PropertyMetadata(1L));</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">    internal static readonly DependencyProperty StrokeThicknessProperty = DependencyProperty.Register(nameof(StrokeThickness), typeof(double), typeof(DrawingCanvas), new PropertyMetadata(2d, Visual_PropertyChanged));</a>
<a name="ln99"> </a>
<a name="ln100">    internal static readonly DependencyProperty StrokeProperty = DependencyProperty.Register(nameof(Stroke), typeof(Brush), typeof(DrawingCanvas), new PropertyMetadata(Brushes.Black, Visual_PropertyChanged));</a>
<a name="ln101"> </a>
<a name="ln102">    internal static readonly DependencyProperty FillProperty = DependencyProperty.Register(nameof(Fill), typeof(Brush), typeof(DrawingCanvas), new PropertyMetadata(Brushes.Transparent, Visual_PropertyChanged));</a>
<a name="ln103"> </a>
<a name="ln104">    internal static readonly DependencyProperty RadiusProperty = DependencyProperty.Register(nameof(Radius), typeof(double), typeof(DrawingCanvas),</a>
<a name="ln105">        new FrameworkPropertyMetadata(0d, FrameworkPropertyMetadataOptions.AffectsRender, Visual_PropertyChanged));</a>
<a name="ln106"> </a>
<a name="ln107">    public static readonly DependencyProperty StrokeDashArrayProperty = DependencyProperty.Register(nameof(StrokeDashArray), typeof(DoubleCollection), typeof(DrawingCanvas),</a>
<a name="ln108">        new FrameworkPropertyMetadata(new DoubleCollection(), FrameworkPropertyMetadataOptions.AffectsMeasure | FrameworkPropertyMetadataOptions.AffectsRender, Visual_PropertyChanged));</a>
<a name="ln109"> </a>
<a name="ln110">    #endregion</a>
<a name="ln111"> </a>
<a name="ln112">    #region Properties</a>
<a name="ln113"> </a>
<a name="ln114">    internal DrawingModes DrawingMode</a>
<a name="ln115">    {</a>
<a name="ln116">        get =&gt; (DrawingModes)GetValue(DrawingModeProperty);</a>
<a name="ln117">        set =&gt; SetValue(DrawingModeProperty, value);</a>
<a name="ln118">    }</a>
<a name="ln119"> </a>
<a name="ln120">    internal Shapes CurrentShape</a>
<a name="ln121">    {</a>
<a name="ln122">        get =&gt; (Shapes)GetValue(CurrentShapeProperty);</a>
<a name="ln123">        set =&gt; SetValue(CurrentShapeProperty, value);</a>
<a name="ln124">    }</a>
<a name="ln125"> </a>
<a name="ln126">    internal Rect Selection</a>
<a name="ln127">    {</a>
<a name="ln128">        get =&gt; (Rect)GetValue(SelectionProperty);</a>
<a name="ln129">        set =&gt; SetValue(SelectionProperty, value);</a>
<a name="ln130">    }</a>
<a name="ln131"> </a>
<a name="ln132">    internal Rect RenderRegion</a>
<a name="ln133">    {</a>
<a name="ln134">        get =&gt; (Rect)GetValue(RenderRegionProperty);</a>
<a name="ln135">        set =&gt; SetValue(RenderRegionProperty, value);</a>
<a name="ln136">    }</a>
<a name="ln137"> </a>
<a name="ln138">    internal bool IsDrawing</a>
<a name="ln139">    {</a>
<a name="ln140">        get =&gt; (bool)GetValue(IsDrawingProperty);</a>
<a name="ln141">        set =&gt; SetValue(IsDrawingProperty, value);</a>
<a name="ln142">    }</a>
<a name="ln143"> </a>
<a name="ln144">    internal long ControlsZIndex</a>
<a name="ln145">    {</a>
<a name="ln146">        get =&gt; (long)GetValue(ControlsZIndexProperty);</a>
<a name="ln147">        set =&gt; SetValue(ControlsZIndexProperty, value);</a>
<a name="ln148">    }</a>
<a name="ln149"> </a>
<a name="ln150">    [TypeConverter(typeof(LengthConverter))]</a>
<a name="ln151">    public double StrokeThickness</a>
<a name="ln152">    {</a>
<a name="ln153">        get =&gt; (double)GetValue(StrokeThicknessProperty);</a>
<a name="ln154">        set =&gt; SetValue(StrokeThicknessProperty, value);</a>
<a name="ln155">    }</a>
<a name="ln156"> </a>
<a name="ln157">    public Brush Stroke</a>
<a name="ln158">    {</a>
<a name="ln159">        get =&gt; (Brush)GetValue(StrokeProperty);</a>
<a name="ln160">        set =&gt; SetValue(StrokeProperty, value);</a>
<a name="ln161">    }</a>
<a name="ln162"> </a>
<a name="ln163">    public Brush Fill</a>
<a name="ln164">    {</a>
<a name="ln165">        get =&gt; (Brush)GetValue(FillProperty);</a>
<a name="ln166">        set =&gt; SetValue(FillProperty, value);</a>
<a name="ln167">    }</a>
<a name="ln168"> </a>
<a name="ln169">    [TypeConverter(typeof(LengthConverter))]</a>
<a name="ln170">    public double Radius</a>
<a name="ln171">    {</a>
<a name="ln172">        get =&gt; (double)GetValue(RadiusProperty);</a>
<a name="ln173">        set =&gt; SetValue(RadiusProperty, value);</a>
<a name="ln174">    }</a>
<a name="ln175"> </a>
<a name="ln176">    public DoubleCollection StrokeDashArray</a>
<a name="ln177">    {</a>
<a name="ln178">        get =&gt; (DoubleCollection)GetValue(StrokeDashArrayProperty);</a>
<a name="ln179">        set =&gt; SetValue(StrokeDashArrayProperty, value);</a>
<a name="ln180">    }</a>
<a name="ln181"> </a>
<a name="ln182">    public int ShapesCount =&gt; _mainCanvas?.Children.Count ?? 0;</a>
<a name="ln183"> </a>
<a name="ln184">    #endregion</a>
<a name="ln185"> </a>
<a name="ln186">    static DrawingCanvas()</a>
<a name="ln187">    {</a>
<a name="ln188">        DefaultStyleKeyProperty.OverrideMetadata(typeof(DrawingCanvas), new FrameworkPropertyMetadata(typeof(DrawingCanvas)));</a>
<a name="ln189">    }</a>
<a name="ln190"> </a>
<a name="ln191">    #region Overrides</a>
<a name="ln192"> </a>
<a name="ln193">    public override void OnApplyTemplate()</a>
<a name="ln194">    {</a>
<a name="ln195">        base.OnApplyTemplate();</a>
<a name="ln196"> </a>
<a name="ln197">        _mainCanvas = Template.FindName(&quot;MainCanvas&quot;, this) as Canvas;</a>
<a name="ln198">        _mainInkCanvas = Template.FindName(&quot;MainInkCanvas&quot;, this) as InkCanvas;</a>
<a name="ln199"> </a>
<a name="ln200">        if (_mainInkCanvas != null)</a>
<a name="ln201">        {</a>
<a name="ln202">            _mainInkCanvas.PreviewMouseLeftButtonDown += MainInkCanvas_MouseLeftButtonDown;</a>
<a name="ln203">            _mainInkCanvas.StrokeCollected += MainInkCanvas_StrokeCollected;</a>
<a name="ln204">        }</a>
<a name="ln205"> </a>
<a name="ln206">        _adornerLayer = AdornerLayer.GetAdornerLayer(this);</a>
<a name="ln207">    }</a>
<a name="ln208"> </a>
<a name="ln209">    protected override void OnMouseLeftButtonDown(MouseButtonEventArgs e)</a>
<a name="ln210">    {</a>
<a name="ln211">        Keyboard.Focus(this);</a>
<a name="ln212"> </a>
<a name="ln213">        _startPoint = e.GetPosition(this);</a>
<a name="ln214"> </a>
<a name="ln215">        switch (DrawingMode)</a>
<a name="ln216">        {</a>
<a name="ln217">            case DrawingModes.Select:</a>
<a name="ln218">            {</a>
<a name="ln219">                if ((Keyboard.Modifiers &amp; ModifierKeys.Control) == 0)</a>
<a name="ln220">                {</a>
<a name="ln221">                    RemoveAllAdorners();</a>
<a name="ln222">                    _selectedShapes.Clear();</a>
<a name="ln223">                }</a>
<a name="ln224"> </a>
<a name="ln225">                //When the user clicks exactly on top of a shape, it will be selected.</a>
<a name="ln226">                var hitTest = _mainCanvas.Children.OfType&lt;Shape&gt;().Where(w =&gt; w.Tag == null).FirstOrDefault(f =&gt; f.RenderedGeometry.FillContains(e.GetPosition(f)));</a>
<a name="ln227"> </a>
<a name="ln228">                if (hitTest != null)</a>
<a name="ln229">                {</a>
<a name="ln230">                    SelectShape(hitTest);</a>
<a name="ln231">                }</a>
<a name="ln232">                else</a>
<a name="ln233">                {</a>
<a name="ln234">                    //Starts drawing selection retangle.</a>
<a name="ln235">                    Selection = new Rect(_startPoint, new Size(0, 0));</a>
<a name="ln236"> </a>
<a name="ln237">                    CaptureMouse();</a>
<a name="ln238">                }</a>
<a name="ln239"> </a>
<a name="ln240">                break;</a>
<a name="ln241">            }</a>
<a name="ln242">            case DrawingModes.Shape:</a>
<a name="ln243">            {</a>
<a name="ln244">                RemoveAllAdorners();</a>
<a name="ln245"> </a>
<a name="ln246">                RenderRegion = new Rect(_startPoint, new Size(0, 0));</a>
<a name="ln247">                IsDrawing = true;</a>
<a name="ln248"> </a>
<a name="ln249">                CaptureMouse();</a>
<a name="ln250"> </a>
<a name="ln251">                CalculateOrientation(_startPoint, _startPoint);</a>
<a name="ln252">                RenderShape();</a>
<a name="ln253"> </a>
<a name="ln254">                break;</a>
<a name="ln255">            }</a>
<a name="ln256">        }</a>
<a name="ln257"> </a>
<a name="ln258">        e.Handled = true;</a>
<a name="ln259">        base.OnMouseLeftButtonDown(e);</a>
<a name="ln260">    }</a>
<a name="ln261"> </a>
<a name="ln262">    protected override void OnMouseMove(MouseEventArgs e)</a>
<a name="ln263">    {</a>
<a name="ln264">        if (!IsMouseCaptured || e.LeftButton != MouseButtonState.Pressed)</a>
<a name="ln265">            return;</a>
<a name="ln266"> </a>
<a name="ln267">        if (DrawingMode == DrawingModes.Select &amp;&amp; ((_selectedShapes?.Count ?? 0) == 0 || (Keyboard.Modifiers &amp; ModifierKeys.Control) != 0))</a>
<a name="ln268">        {</a>
<a name="ln269">            var current = GetBoundedCoordinates(e);</a>
<a name="ln270"> </a>
<a name="ln271">            Selection = new Rect(Math.Min(current.X, _startPoint.X), Math.Min(current.Y, _startPoint.Y), Math.Abs(current.X - _startPoint.X), Math.Abs(current.Y - _startPoint.Y));</a>
<a name="ln272">        }</a>
<a name="ln273">        else if (DrawingMode == DrawingModes.Shape)</a>
<a name="ln274">        {</a>
<a name="ln275">            var current = GetBoundedCoordinates(e);</a>
<a name="ln276"> </a>
<a name="ln277">            RenderRegion = Rect.Inflate(new Rect(Math.Min(current.X, _startPoint.X), Math.Min(current.Y, _startPoint.Y), Math.Abs(current.X - _startPoint.X), Math.Abs(current.Y - _startPoint.Y)), -0.6d, -0.6d);</a>
<a name="ln278"> </a>
<a name="ln279">            CalculateOrientation(_startPoint, current);</a>
<a name="ln280">            RenderShape();</a>
<a name="ln281">        }</a>
<a name="ln282"> </a>
<a name="ln283">        base.OnMouseMove(e);</a>
<a name="ln284">    }</a>
<a name="ln285"> </a>
<a name="ln286">    protected override void OnMouseLeftButtonUp(MouseButtonEventArgs e)</a>
<a name="ln287">    {</a>
<a name="ln288">        if (DrawingMode == DrawingModes.Select)</a>
<a name="ln289">        {</a>
<a name="ln290">            if ((Keyboard.Modifiers &amp; ModifierKeys.Control) == 0)</a>
<a name="ln291">            {</a>
<a name="ln292">                RemoveAllAdorners();</a>
<a name="ln293">                _selectedShapes.Clear();</a>
<a name="ln294">            }</a>
<a name="ln295"> </a>
<a name="ln296">            var selectedShapes = GetSelectedShapes(_mainCanvas, new RectangleGeometry(Selection)); //_mainCanvas.Children.OfType&lt;Shape&gt;().Where(w =&gt; Selection.Contains(w.)).ToList();</a>
<a name="ln297"> </a>
<a name="ln298">            if (selectedShapes.Any())</a>
<a name="ln299">            {</a>
<a name="ln300">                foreach (var shape in selectedShapes)</a>
<a name="ln301">                    SelectShape(shape);</a>
<a name="ln302">            }</a>
<a name="ln303"> </a>
<a name="ln304">            Selection = Rect.Empty;</a>
<a name="ln305">            ReleaseMouseCapture();</a>
<a name="ln306">        }</a>
<a name="ln307">        else if (DrawingMode == DrawingModes.Shape)</a>
<a name="ln308">        {</a>
<a name="ln309">            ReleaseMouseCapture();</a>
<a name="ln310"> </a>
<a name="ln311">            RenderShape();</a>
<a name="ln312">            RemoveIfTooSmall();</a>
<a name="ln313"> </a>
<a name="ln314">            IsDrawing = false;</a>
<a name="ln315"> </a>
<a name="ln316">            _selectedShapes?.Clear();</a>
<a name="ln317">            SelectShape(_currentShape);</a>
<a name="ln318"> </a>
<a name="ln319">            _currentShape = null;</a>
<a name="ln320">        }</a>
<a name="ln321"> </a>
<a name="ln322">        base.OnMouseLeftButtonUp(e);</a>
<a name="ln323">    }</a>
<a name="ln324"> </a>
<a name="ln325">    protected override void OnPreviewKeyDown(KeyEventArgs e)</a>
<a name="ln326">    {</a>
<a name="ln327">        switch (e.Key)</a>
<a name="ln328">        {</a>
<a name="ln329">            case Key.Back:</a>
<a name="ln330">            case Key.Delete:</a>
<a name="ln331">                RemoveAllAdorners();</a>
<a name="ln332">                RemoveAllSelectedShapes();</a>
<a name="ln333"> </a>
<a name="ln334">                if (_selectedShapes.Count &gt; 0)</a>
<a name="ln335">                    e.Handled = true;</a>
<a name="ln336">                break;</a>
<a name="ln337"> </a>
<a name="ln338">            //TODO: Cntrl + C, Ctrl + V,</a>
<a name="ln339">        }</a>
<a name="ln340"> </a>
<a name="ln341">        base.OnPreviewKeyDown(e);</a>
<a name="ln342">    }</a>
<a name="ln343"> </a>
<a name="ln344">    protected override void OnMouseWheel(MouseWheelEventArgs e)</a>
<a name="ln345">    {</a>
<a name="ln346">        double step;</a>
<a name="ln347"> </a>
<a name="ln348">        switch (Keyboard.Modifiers)</a>
<a name="ln349">        {</a>
<a name="ln350">            case ModifierKeys.Alt:</a>
<a name="ln351">                step = 90;</a>
<a name="ln352">                break;</a>
<a name="ln353">            case ModifierKeys.Control:</a>
<a name="ln354">                step = 1;</a>
<a name="ln355">                break;</a>
<a name="ln356">            case ModifierKeys.Shift:</a>
<a name="ln357">                step = 20;</a>
<a name="ln358">                break;</a>
<a name="ln359">            default:</a>
<a name="ln360">                return;</a>
<a name="ln361">        }</a>
<a name="ln362"> </a>
<a name="ln363">        RotateAllSelectedShapes(e.Delta &gt; 0 ? step : step * -1);</a>
<a name="ln364"> </a>
<a name="ln365">        base.OnMouseWheel(e);</a>
<a name="ln366">    }</a>
<a name="ln367"> </a>
<a name="ln368">    #endregion</a>
<a name="ln369"> </a>
<a name="ln370">    #region Methods</a>
<a name="ln371"> </a>
<a name="ln372">    private Point GetBoundedCoordinates(MouseEventArgs e)</a>
<a name="ln373">    {</a>
<a name="ln374">        var current = e.GetPosition(this);</a>
<a name="ln375"> </a>
<a name="ln376">        if (current.X &lt; -1)</a>
<a name="ln377">            current.X = -1;</a>
<a name="ln378"> </a>
<a name="ln379">        if (current.Y &lt; -1)</a>
<a name="ln380">            current.Y = -1;</a>
<a name="ln381"> </a>
<a name="ln382">        if (current.X &gt; ActualWidth)</a>
<a name="ln383">            current.X = ActualWidth;</a>
<a name="ln384"> </a>
<a name="ln385">        if (current.Y &gt; ActualHeight)</a>
<a name="ln386">            current.Y = ActualHeight;</a>
<a name="ln387"> </a>
<a name="ln388">        return current;</a>
<a name="ln389">    }</a>
<a name="ln390"> </a>
<a name="ln391">    private void RemoveAllAdorners()</a>
<a name="ln392">    {</a>
<a name="ln393">        if (_selectedShapes == null)</a>
<a name="ln394">            return;</a>
<a name="ln395"> </a>
<a name="ln396">        foreach (var shape in _selectedShapes.Where(w =&gt; w != null))</a>
<a name="ln397">        {</a>
<a name="ln398">            foreach (var adorner in _adornerLayer?.GetAdorners(shape)?.OfType&lt;ElementAdorner&gt;() ?? new List&lt;ElementAdorner&gt;())</a>
<a name="ln399">                _adornerLayer?.Remove(adorner);</a>
<a name="ln400">        }</a>
<a name="ln401">    }</a>
<a name="ln402"> </a>
<a name="ln403">    private void RemoveAllSelectedShapes()</a>
<a name="ln404">    {</a>
<a name="ln405">        if (_selectedShapes == null)</a>
<a name="ln406">            return;</a>
<a name="ln407"> </a>
<a name="ln408">        foreach (var shape in _selectedShapes)</a>
<a name="ln409">            _mainCanvas.Children.Remove(shape);</a>
<a name="ln410"> </a>
<a name="ln411">        _selectedShapes.Clear();</a>
<a name="ln412">    }</a>
<a name="ln413"> </a>
<a name="ln414">    private void RotateAllSelectedShapes(double angleDifference)</a>
<a name="ln415">    {</a>
<a name="ln416">        if (_selectedShapes == null)</a>
<a name="ln417">            return;</a>
<a name="ln418"> </a>
<a name="ln419">        foreach (var shape in _selectedShapes)</a>
<a name="ln420">            if (_adornerLayer.GetAdorners(shape)?[0] is ElementAdorner ad)</a>
<a name="ln421">                ad.Angle += angleDifference;</a>
<a name="ln422">    }</a>
<a name="ln423"> </a>
<a name="ln424">    private void CalculateOrientation(Point start, Point current)</a>
<a name="ln425">    {</a>
<a name="ln426">        _isBottomToTop = start.Y &lt; current.Y;</a>
<a name="ln427">        _isRightToLeft = start.X &lt; current.X;</a>
<a name="ln428">        _mostDistantPoint = start;</a>
<a name="ln429">        _currentPoint = current;</a>
<a name="ln430">    }</a>
<a name="ln431"> </a>
<a name="ln432">    private void RenderShape()</a>
<a name="ln433">    {</a>
<a name="ln434">        if (RenderRegion.IsEmpty)</a>
<a name="ln435">        {</a>
<a name="ln436">            if (_currentShape != null)</a>
<a name="ln437">                _mainCanvas.Children.Remove(_currentShape);</a>
<a name="ln438"> </a>
<a name="ln439">            return;</a>
<a name="ln440">        }</a>
<a name="ln441"> </a>
<a name="ln442">        if (_currentShape != null)</a>
<a name="ln443">        {</a>
<a name="ln444">            Canvas.SetTop(_currentShape, RenderRegion.Top);</a>
<a name="ln445">            Canvas.SetLeft(_currentShape, RenderRegion.Left);</a>
<a name="ln446">            _currentShape.Width = RenderRegion.Width;</a>
<a name="ln447">            _currentShape.Height = RenderRegion.Height;</a>
<a name="ln448"> </a>
<a name="ln449">            if (_currentShape is Arrow arrow)</a>
<a name="ln450">            {</a>
<a name="ln451">                arrow.X1 = RenderRegion.Left - _mostDistantPoint.X;</a>
<a name="ln452">                arrow.X2 = RenderRegion.Left - Math.Abs(_isRightToLeft ? _mostDistantPoint.X - _currentPoint.X : _currentPoint.X - _mostDistantPoint.X);</a>
<a name="ln453">                arrow.Y1 = RenderRegion.Top - _mostDistantPoint.Y;</a>
<a name="ln454">                arrow.Y2 = RenderRegion.Top - Math.Abs(_mostDistantPoint.Y - _currentPoint.Y);</a>
<a name="ln455">            }</a>
<a name="ln456">            return;</a>
<a name="ln457">        }</a>
<a name="ln458"> </a>
<a name="ln459">        switch (CurrentShape)</a>
<a name="ln460">        {</a>
<a name="ln461">            case Shapes.Rectangle:</a>
<a name="ln462">                _currentShape = new Rectangle</a>
<a name="ln463">                {</a>
<a name="ln464">                    Width = RenderRegion.Width,</a>
<a name="ln465">                    Height = RenderRegion.Height,</a>
<a name="ln466">                    Stroke = Stroke,</a>
<a name="ln467">                    StrokeThickness = StrokeThickness,</a>
<a name="ln468">                    StrokeDashArray = StrokeDashArray,</a>
<a name="ln469">                    Fill = Fill,</a>
<a name="ln470">                    RadiusX = Radius,</a>
<a name="ln471">                    RadiusY = Radius</a>
<a name="ln472">                };</a>
<a name="ln473">                break;</a>
<a name="ln474">            case Shapes.Ellipse:</a>
<a name="ln475">                _currentShape = new Ellipse</a>
<a name="ln476">                {</a>
<a name="ln477">                    Width = RenderRegion.Width,</a>
<a name="ln478">                    Height = RenderRegion.Height,</a>
<a name="ln479">                    Stroke = Stroke,</a>
<a name="ln480">                    StrokeThickness = StrokeThickness,</a>
<a name="ln481">                    StrokeDashArray = StrokeDashArray,</a>
<a name="ln482">                    Fill = Fill,</a>
<a name="ln483">                };</a>
<a name="ln484">                break;</a>
<a name="ln485">            case Shapes.Triangle:</a>
<a name="ln486">                _currentShape = new Triangle</a>
<a name="ln487">                {</a>
<a name="ln488">                    Width = RenderRegion.Width,</a>
<a name="ln489">                    Height = RenderRegion.Height,</a>
<a name="ln490">                    Stroke = Stroke,</a>
<a name="ln491">                    StrokeThickness = StrokeThickness,</a>
<a name="ln492">                    StrokeDashArray = StrokeDashArray,</a>
<a name="ln493">                    Fill = Fill,</a>
<a name="ln494">                    //RadiusX = Radius,</a>
<a name="ln495">                    //RadiusY = Radius</a>
<a name="ln496">                };</a>
<a name="ln497">                break;</a>
<a name="ln498">            case Shapes.Arrow:</a>
<a name="ln499">                _currentShape = new Arrow</a>
<a name="ln500">                {</a>
<a name="ln501">                    Width = RenderRegion.Width,</a>
<a name="ln502">                    Height = RenderRegion.Height,</a>
<a name="ln503">                    Stroke = Stroke,</a>
<a name="ln504">                    StrokeThickness = StrokeThickness,</a>
<a name="ln505">                    StrokeDashArray = StrokeDashArray,</a>
<a name="ln506">                    Fill = Fill,</a>
<a name="ln507">                    Stretch = Stretch.Fill,</a>
<a name="ln508">                    HeadHeight = 10,</a>
<a name="ln509">                    HeadWidth = 10,</a>
<a name="ln510">                    X1 = RenderRegion.Left - _mostDistantPoint.X,</a>
<a name="ln511">                    X2 = RenderRegion.Left - Math.Abs(_isRightToLeft ? _mostDistantPoint.X - _currentPoint.X : _currentPoint.X - _mostDistantPoint.X),</a>
<a name="ln512">                    Y1 = RenderRegion.Top - _mostDistantPoint.Y,</a>
<a name="ln513">                    Y2 = RenderRegion.Top - Math.Abs(_mostDistantPoint.Y - _currentPoint.Y)</a>
<a name="ln514">                };</a>
<a name="ln515">                break;</a>
<a name="ln516">        }</a>
<a name="ln517"> </a>
<a name="ln518">        if (_currentShape == null)</a>
<a name="ln519">            return;</a>
<a name="ln520"> </a>
<a name="ln521">        _mainCanvas.Children.Add(_currentShape);</a>
<a name="ln522"> </a>
<a name="ln523">        Canvas.SetLeft(_currentShape, RenderRegion.Left);</a>
<a name="ln524">        Canvas.SetTop(_currentShape, RenderRegion.Top);</a>
<a name="ln525">        Panel.SetZIndex(_currentShape, _mainCanvas.Children.OfType&lt;Shape&gt;().Where(w =&gt; w.Tag == null).Max(Panel.GetZIndex) + 1);</a>
<a name="ln526">    }</a>
<a name="ln527"> </a>
<a name="ln528">    private void RemoveIfTooSmall()</a>
<a name="ln529">    {</a>
<a name="ln530">        if (!(RenderRegion.Width + RenderRegion.Height &lt; 10))</a>
<a name="ln531">            return;</a>
<a name="ln532"> </a>
<a name="ln533">        _mainCanvas.Children.Remove(_currentShape);</a>
<a name="ln534">    }</a>
<a name="ln535"> </a>
<a name="ln536">    private List&lt;Shape&gt; GetSelectedShapes(Visual element, Geometry geometry)</a>
<a name="ln537">    {</a>
<a name="ln538">        var shapes = new List&lt;Shape&gt;();</a>
<a name="ln539"> </a>
<a name="ln540">        VisualTreeHelper.HitTest(element, null, result =&gt;</a>
<a name="ln541">            {</a>
<a name="ln542">                if (result.VisualHit is Shape shape &amp;&amp; shape.Tag == null)</a>
<a name="ln543">                    shapes.Add(shape);</a>
<a name="ln544"> </a>
<a name="ln545">                return HitTestResultBehavior.Continue;</a>
<a name="ln546">            },</a>
<a name="ln547">            new GeometryHitTestParameters(geometry));</a>
<a name="ln548"> </a>
<a name="ln549">        return shapes;</a>
<a name="ln550">    }</a>
<a name="ln551"> </a>
<a name="ln552">    private void SelectShape(Shape shape)</a>
<a name="ln553">    {</a>
<a name="ln554">        if (shape == null)</a>
<a name="ln555">            return;</a>
<a name="ln556"> </a>
<a name="ln557">        if (!_selectedShapes.Contains(shape))</a>
<a name="ln558">            _selectedShapes.Add(shape);</a>
<a name="ln559"> </a>
<a name="ln560">        AdjustDepth();</a>
<a name="ln561"> </a>
<a name="ln562">        var adorner = new ElementAdorner(shape, true, true, true, _mainCanvas, _startPoint);</a>
<a name="ln563">        adorner.Manipulated += Adorner_Manipulated;</a>
<a name="ln564">        adorner.RotationResetRequested += Adorner_RotationResetRequested;</a>
<a name="ln565">        adorner.Removed += Adorner_Removed;</a>
<a name="ln566">        adorner.MouseLeftButtonDown += Adorner_MouseLeftButtonDown;</a>
<a name="ln567">        _adornerLayer.Add(adorner);</a>
<a name="ln568">    }</a>
<a name="ln569"> </a>
<a name="ln570">    private void DeselectShape(Shape shape)</a>
<a name="ln571">    {</a>
<a name="ln572">        if (shape == null)</a>
<a name="ln573">            return;</a>
<a name="ln574"> </a>
<a name="ln575">        if (!_selectedShapes.Contains(shape))</a>
<a name="ln576">            return;</a>
<a name="ln577"> </a>
<a name="ln578">        _selectedShapes.Remove(shape);</a>
<a name="ln579"> </a>
<a name="ln580">        foreach (var adorner in _adornerLayer?.GetAdorners(shape)?.OfType&lt;ElementAdorner&gt;() ?? new List&lt;ElementAdorner&gt;())</a>
<a name="ln581">            _adornerLayer?.Remove(adorner);</a>
<a name="ln582">    }</a>
<a name="ln583"> </a>
<a name="ln584">    private void AdjustDepth()</a>
<a name="ln585">    {</a>
<a name="ln586">        //0 = Further behind.</a>
<a name="ln587">        //999 = Further in front.</a>
<a name="ln588">        var indexes = _mainCanvas.Children.OfType&lt;Shape&gt;().Where(w =&gt; w.Tag == null).Select(Panel.GetZIndex).OrderBy(o =&gt; o).ToList();</a>
<a name="ln589"> </a>
<a name="ln590">        if (indexes.Count == 0)</a>
<a name="ln591">            return;</a>
<a name="ln592"> </a>
<a name="ln593">        //Make all shapes go 1 step behind.</a>
<a name="ln594">        foreach (var shape in _mainCanvas.Children.OfType&lt;Shape&gt;().Where(w =&gt; w.Tag == null))</a>
<a name="ln595">            Panel.SetZIndex(shape, indexes.IndexOf(Panel.GetZIndex(shape)));</a>
<a name="ln596"> </a>
<a name="ln597">        //In order to show the selected shapes in front, the Z order should be greater than the rest of the shapes.</a>
<a name="ln598">        var max = _mainCanvas.Children.OfType&lt;Shape&gt;().Where(w =&gt; w.Tag == null).Max(Panel.GetZIndex);</a>
<a name="ln599"> </a>
<a name="ln600">        //Make all selected shapes go 1 step to the front, making sure to respect the current Z order.</a>
<a name="ln601">        foreach (var shape in _selectedShapes.OrderBy(Panel.GetZIndex))</a>
<a name="ln602">            Panel.SetZIndex(shape, ++max);</a>
<a name="ln603"> </a>
<a name="ln604">        //All design controls should be at the top.</a>
<a name="ln605">        ControlsZIndex = ++max;</a>
<a name="ln606">    }</a>
<a name="ln607"> </a>
<a name="ln608">    public void DeselectAll()</a>
<a name="ln609">    {</a>
<a name="ln610">        RemoveAllAdorners();</a>
<a name="ln611"> </a>
<a name="ln612">        _selectedShapes?.Clear();</a>
<a name="ln613">    }</a>
<a name="ln614"> </a>
<a name="ln615">    public void RemoveAllShapes()</a>
<a name="ln616">    {</a>
<a name="ln617">        DeselectAll();</a>
<a name="ln618"> </a>
<a name="ln619">        _mainCanvas.Children.Clear();</a>
<a name="ln620">    }</a>
<a name="ln621"> </a>
<a name="ln622">    #endregion</a>
<a name="ln623"> </a>
<a name="ln624">    #region Events</a>
<a name="ln625"> </a>
<a name="ln626">    private static void DrawingMode_PropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)</a>
<a name="ln627">    {</a>
<a name="ln628">        if (d is not DrawingCanvas canvas || canvas._mainInkCanvas == null)</a>
<a name="ln629">            return;</a>
<a name="ln630"> </a>
<a name="ln631">        canvas._mainInkCanvas.Visibility = canvas.DrawingMode == DrawingModes.Ink ? Visibility.Visible : Visibility.Collapsed;</a>
<a name="ln632">    }</a>
<a name="ln633"> </a>
<a name="ln634">    private static void Visual_PropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)</a>
<a name="ln635">    {</a>
<a name="ln636">        if (d is not DrawingCanvas canvas)</a>
<a name="ln637">            return;</a>
<a name="ln638"> </a>
<a name="ln639">        if (canvas._mainInkCanvas != null)</a>
<a name="ln640">        {</a>
<a name="ln641">            canvas._mainInkCanvas.DefaultDrawingAttributes = new DrawingAttributes</a>
<a name="ln642">            {</a>
<a name="ln643">                Color = canvas.Stroke is SolidColorBrush color ? color.Color : Colors.Black,</a>
<a name="ln644">                Height = Math.Max(canvas.StrokeThickness, 1),</a>
<a name="ln645">                Width = Math.Max(canvas.StrokeThickness, 1),</a>
<a name="ln646">            };</a>
<a name="ln647">        }</a>
<a name="ln648"> </a>
<a name="ln649">        if (canvas._selectedShapes == null)</a>
<a name="ln650">            return;</a>
<a name="ln651"> </a>
<a name="ln652">        //Change the settings of the selected shapes.</a>
<a name="ln653">        foreach (var shape in canvas._selectedShapes)</a>
<a name="ln654">        {</a>
<a name="ln655">            shape.Stroke = canvas.Stroke;</a>
<a name="ln656">            shape.StrokeThickness = canvas.StrokeThickness;</a>
<a name="ln657">            shape.StrokeDashArray = canvas.StrokeDashArray;</a>
<a name="ln658">            shape.Fill = canvas.Fill;</a>
<a name="ln659"> </a>
<a name="ln660">            if (shape is Rectangle rect)</a>
<a name="ln661">                rect.RadiusX = rect.RadiusY = canvas.Radius;</a>
<a name="ln662">        }</a>
<a name="ln663">    }</a>
<a name="ln664"> </a>
<a name="ln665">    private void Adorner_Manipulated(object sender, ManipulatedEventArgs args)</a>
<a name="ln666">    {</a>
<a name="ln667">        if (sender is not ElementAdorner adorner)</a>
<a name="ln668">            return;</a>
<a name="ln669"> </a>
<a name="ln670">        foreach (var shape in _selectedShapes)</a>
<a name="ln671">        {</a>
<a name="ln672">            if (Equals(shape, adorner.AdornedElement)) continue;</a>
<a name="ln673"> </a>
<a name="ln674">            if (_adornerLayer.GetAdorners(shape)?[0] is ElementAdorner ad)</a>
<a name="ln675">                ad.Angle += args.AngleDifference;</a>
<a name="ln676"> </a>
<a name="ln677">            if (Math.Abs(args.HeightDifference) &gt; 0.1 &amp;&amp; shape.ActualHeight + args.HeightDifference &gt; 10 &amp;&amp; shape.ActualHeight + args.HeightDifference &lt;= _mainCanvas.ActualHeight)</a>
<a name="ln678">                shape.Height += args.HeightDifference;</a>
<a name="ln679">            //shape.Height = shape.ActualHeight + args.HeightDifference;</a>
<a name="ln680"> </a>
<a name="ln681">            if (Math.Abs(args.WidthDifference) &gt; 0.1 &amp;&amp; shape.ActualWidth + args.WidthDifference &gt; 10 &amp;&amp; shape.ActualWidth + args.WidthDifference &lt;= _mainCanvas.ActualWidth)</a>
<a name="ln682">                shape.Width += args.WidthDifference;</a>
<a name="ln683">            //shape.Width = shape.ActualWidth + args.WidthDifference;</a>
<a name="ln684"> </a>
<a name="ln685">            if (Canvas.GetTop(shape) + args.TopDifference &gt;= 0 &amp;&amp; Canvas.GetTop(shape) + args.TopDifference + shape.ActualHeight &lt; _mainCanvas.ActualHeight)</a>
<a name="ln686">                Canvas.SetTop(shape, Canvas.GetTop(shape) + args.TopDifference);</a>
<a name="ln687"> </a>
<a name="ln688">            if (Canvas.GetLeft(shape) + args.LeftDifference &gt;= 0 &amp;&amp; Canvas.GetLeft(shape) + args.LeftDifference + shape.ActualWidth &lt; _mainCanvas.ActualWidth)</a>
<a name="ln689">                Canvas.SetLeft(shape, Canvas.GetLeft(shape) + args.LeftDifference);</a>
<a name="ln690">        }</a>
<a name="ln691">    }</a>
<a name="ln692"> </a>
<a name="ln693">    private void Adorner_RotationResetRequested(object sender, RoutedEventArgs e)</a>
<a name="ln694">    {</a>
<a name="ln695">        if (sender is not ElementAdorner adorner)</a>
<a name="ln696">            return;</a>
<a name="ln697"> </a>
<a name="ln698">        foreach (var shape in _selectedShapes)</a>
<a name="ln699">        {</a>
<a name="ln700">            if (_adornerLayer.GetAdorners(shape)?[0] is ElementAdorner ad)</a>
<a name="ln701">                ad.Angle = 0;</a>
<a name="ln702">        }</a>
<a name="ln703">    }</a>
<a name="ln704"> </a>
<a name="ln705">    private void Adorner_Removed(object sender, RoutedEventArgs e)</a>
<a name="ln706">    {</a>
<a name="ln707">        RemoveAllAdorners();</a>
<a name="ln708">        RemoveAllSelectedShapes();</a>
<a name="ln709">    }</a>
<a name="ln710"> </a>
<a name="ln711">    private void Adorner_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)</a>
<a name="ln712">    {</a>
<a name="ln713">        if ((Keyboard.Modifiers &amp; ModifierKeys.Control) == 0)</a>
<a name="ln714">            return;</a>
<a name="ln715"> </a>
<a name="ln716">        var adorner = sender as ElementAdorner;</a>
<a name="ln717">        var shape = adorner?.AdornedElement as Shape;</a>
<a name="ln718"> </a>
<a name="ln719">        if (_selectedShapes.Contains(shape))</a>
<a name="ln720">            DeselectShape(shape);</a>
<a name="ln721">    }</a>
<a name="ln722"> </a>
<a name="ln723">    private void MainInkCanvas_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)</a>
<a name="ln724">    {</a>
<a name="ln725">        RemoveAllAdorners();</a>
<a name="ln726">        _selectedShapes.Clear();</a>
<a name="ln727">    }</a>
<a name="ln728"> </a>
<a name="ln729">    private void MainInkCanvas_StrokeCollected(object sender, InkCanvasStrokeCollectedEventArgs e)</a>
<a name="ln730">    {</a>
<a name="ln731">        foreach (var stroke in _mainInkCanvas.Strokes)</a>
<a name="ln732">        {</a>
<a name="ln733">            if (stroke.GetBounds().Width &lt; 12 || stroke.GetBounds().Height &lt; 12)</a>
<a name="ln734">                continue;</a>
<a name="ln735"> </a>
<a name="ln736">            var shape = new Polyline</a>
<a name="ln737">            {</a>
<a name="ln738">                Stroke = new SolidColorBrush(stroke.DrawingAttributes.Color),</a>
<a name="ln739">                StrokeThickness = StrokeThickness, //How? These strokes can receive pressure info.</a>
<a name="ln740">                StrokeDashArray = StrokeDashArray,</a>
<a name="ln741">                FillRule = FillRule.EvenOdd,</a>
<a name="ln742">                Stretch = Stretch.Fill</a>
<a name="ln743">            };</a>
<a name="ln744"> </a>
<a name="ln745">            var points = new PointCollection();</a>
<a name="ln746">            var minTop = stroke.StylusPoints.Min(m =&gt; m.Y);</a>
<a name="ln747">            var minLeft = stroke.StylusPoints.Min(m =&gt; m.X);</a>
<a name="ln748"> </a>
<a name="ln749">            foreach (var point in stroke.StylusPoints)</a>
<a name="ln750">            {</a>
<a name="ln751">                var x = point.X - minLeft;</a>
<a name="ln752">                var y = point.Y - minTop;</a>
<a name="ln753"> </a>
<a name="ln754">                points.Add(new Point(x, y));</a>
<a name="ln755">            }</a>
<a name="ln756"> </a>
<a name="ln757">            shape.Points = points;</a>
<a name="ln758"> </a>
<a name="ln759">            _mainCanvas.Children.Add(shape);</a>
<a name="ln760">            SelectShape(shape);</a>
<a name="ln761"> </a>
<a name="ln762">            Canvas.SetLeft(shape, minLeft);</a>
<a name="ln763">            Canvas.SetTop(shape, minTop);</a>
<a name="ln764"> </a>
<a name="ln765">            AdjustDepth();</a>
<a name="ln766">        }</a>
<a name="ln767"> </a>
<a name="ln768">        _mainInkCanvas.Strokes.Clear();</a>
<a name="ln769"> </a>
<a name="ln770">        Keyboard.Focus(this);</a>
<a name="ln771">    }</a>
<a name="ln772"> </a>
<a name="ln773">    #endregion</a>
<a name="ln774">}</a>
</code></pre>
<div class="balloon" rel="459"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3002/" target="_blank">V3002</a> The switch statement does not cover all values of the 'Shapes' enum: Line.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>