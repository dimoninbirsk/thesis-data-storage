<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>DataGridHeaderBorder.cs</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cs">
<a name="ln1">using System;</a>
<a name="ln2">using System.Collections.Generic;</a>
<a name="ln3">using System.ComponentModel;</a>
<a name="ln4">using System.Diagnostics;</a>
<a name="ln5">using System.Windows;</a>
<a name="ln6">using System.Windows.Controls;</a>
<a name="ln7">using System.Windows.Media;</a>
<a name="ln8"> </a>
<a name="ln9">namespace ScreenToGif.Controls;</a>
<a name="ln10"> </a>
<a name="ln11">/// &lt;summary&gt;</a>
<a name="ln12">/// A Border used to provide the default look of DataGrid headers.</a>
<a name="ln13">/// When Background or BorderBrush are set, the rendering will revert back to the default Border implementation.</a>
<a name="ln14">/// &lt;/summary&gt;</a>
<a name="ln15">public sealed class DataGridHeaderBorder : Border</a>
<a name="ln16">{</a>
<a name="ln17">    static DataGridHeaderBorder()</a>
<a name="ln18">    {</a>
<a name="ln19">        //We always set this to true on these borders, so just default it to true here.</a>
<a name="ln20">        SnapsToDevicePixelsProperty.OverrideMetadata(typeof(DataGridHeaderBorder), new FrameworkPropertyMetadata(true));</a>
<a name="ln21">    }</a>
<a name="ln22"> </a>
<a name="ln23">    #region Header Appearance Properties</a>
<a name="ln24"> </a>
<a name="ln25">    /// &lt;summary&gt;</a>
<a name="ln26">    ///     Whether the hover look should be applied.</a>
<a name="ln27">    /// &lt;/summary&gt;</a>
<a name="ln28">    public bool IsHovered</a>
<a name="ln29">    {</a>
<a name="ln30">        get =&gt; (bool)GetValue(IsHoveredProperty);</a>
<a name="ln31">        set =&gt; SetValue(IsHoveredProperty, value);</a>
<a name="ln32">    }</a>
<a name="ln33"> </a>
<a name="ln34">    /// &lt;summary&gt;</a>
<a name="ln35">    ///     DependencyProperty for IsHovered.</a>
<a name="ln36">    /// &lt;/summary&gt;</a>
<a name="ln37">    public static readonly DependencyProperty IsHoveredProperty =</a>
<a name="ln38">        DependencyProperty.Register(&quot;IsHovered&quot;, typeof(bool), typeof(DataGridHeaderBorder), new FrameworkPropertyMetadata(false, FrameworkPropertyMetadataOptions.AffectsRender));</a>
<a name="ln39"> </a>
<a name="ln40">    /// &lt;summary&gt;</a>
<a name="ln41">    ///     Whether the pressed look should be applied.</a>
<a name="ln42">    /// &lt;/summary&gt;</a>
<a name="ln43">    public bool IsPressed</a>
<a name="ln44">    {</a>
<a name="ln45">        get =&gt; (bool)GetValue(IsPressedProperty);</a>
<a name="ln46">        set =&gt; SetValue(IsPressedProperty, value);</a>
<a name="ln47">    }</a>
<a name="ln48"> </a>
<a name="ln49">    /// &lt;summary&gt;</a>
<a name="ln50">    ///     DependencyProperty for IsPressed.</a>
<a name="ln51">    /// &lt;/summary&gt;</a>
<a name="ln52">    public static readonly DependencyProperty IsPressedProperty =</a>
<a name="ln53">        DependencyProperty.Register(&quot;IsPressed&quot;, typeof(bool), typeof(DataGridHeaderBorder), new FrameworkPropertyMetadata(false, FrameworkPropertyMetadataOptions.AffectsRender | FrameworkPropertyMetadataOptions.AffectsArrange));</a>
<a name="ln54"> </a>
<a name="ln55">    /// &lt;summary&gt;</a>
<a name="ln56">    ///     When false, will not apply the hover look even when IsHovered is true.</a>
<a name="ln57">    /// &lt;/summary&gt;</a>
<a name="ln58">    public bool IsClickable</a>
<a name="ln59">    {</a>
<a name="ln60">        get =&gt; (bool)GetValue(IsClickableProperty);</a>
<a name="ln61">        set =&gt; SetValue(IsClickableProperty, value);</a>
<a name="ln62">    }</a>
<a name="ln63"> </a>
<a name="ln64">    /// &lt;summary&gt;</a>
<a name="ln65">    ///     DependencyProperty for IsClickable.</a>
<a name="ln66">    /// &lt;/summary&gt;</a>
<a name="ln67">    public static readonly DependencyProperty IsClickableProperty =</a>
<a name="ln68">        DependencyProperty.Register(&quot;IsClickable&quot;, typeof(bool), typeof(DataGridHeaderBorder), new FrameworkPropertyMetadata(true, FrameworkPropertyMetadataOptions.AffectsRender | FrameworkPropertyMetadataOptions.AffectsArrange));</a>
<a name="ln69"> </a>
<a name="ln70">    /// &lt;summary&gt;</a>
<a name="ln71">    ///     Whether to appear sorted.</a>
<a name="ln72">    /// &lt;/summary&gt;</a>
<a name="ln73">    public ListSortDirection? SortDirection</a>
<a name="ln74">    {</a>
<a name="ln75">        get =&gt; (ListSortDirection?)GetValue(SortDirectionProperty);</a>
<a name="ln76">        set =&gt; SetValue(SortDirectionProperty, value);</a>
<a name="ln77">    }</a>
<a name="ln78"> </a>
<a name="ln79">    /// &lt;summary&gt;</a>
<a name="ln80">    ///     DependencyProperty for SortDirection.</a>
<a name="ln81">    /// &lt;/summary&gt;</a>
<a name="ln82">    public static readonly DependencyProperty SortDirectionProperty =</a>
<a name="ln83">        DependencyProperty.Register(&quot;SortDirection&quot;, typeof(ListSortDirection?), typeof(DataGridHeaderBorder), new FrameworkPropertyMetadata(null, FrameworkPropertyMetadataOptions.AffectsRender));</a>
<a name="ln84"> </a>
<a name="ln85">    /// &lt;summary&gt;</a>
<a name="ln86">    ///     Whether to appear selected.</a>
<a name="ln87">    /// &lt;/summary&gt;</a>
<a name="ln88">    public bool IsSelected</a>
<a name="ln89">    {</a>
<a name="ln90">        get =&gt; (bool)GetValue(IsSelectedProperty);</a>
<a name="ln91">        set =&gt; SetValue(IsSelectedProperty, value);</a>
<a name="ln92">    }</a>
<a name="ln93"> </a>
<a name="ln94">    /// &lt;summary&gt;</a>
<a name="ln95">    ///     DependencyProperty for IsSelected.</a>
<a name="ln96">    /// &lt;/summary&gt;</a>
<a name="ln97">    public static readonly DependencyProperty IsSelectedProperty =</a>
<a name="ln98">        DependencyProperty.Register(&quot;IsSelected&quot;, typeof(bool), typeof(DataGridHeaderBorder), new FrameworkPropertyMetadata(false, FrameworkPropertyMetadataOptions.AffectsRender));</a>
<a name="ln99"> </a>
<a name="ln100">    /// &lt;summary&gt;</a>
<a name="ln101">    ///     Vertical = column header</a>
<a name="ln102">    ///     Horizontal = row header</a>
<a name="ln103">    /// &lt;/summary&gt;</a>
<a name="ln104">    public Orientation Orientation</a>
<a name="ln105">    {</a>
<a name="ln106">        get =&gt; (Orientation)GetValue(OrientationProperty);</a>
<a name="ln107">        set =&gt; SetValue(OrientationProperty, value);</a>
<a name="ln108">    }</a>
<a name="ln109"> </a>
<a name="ln110">    /// &lt;summary&gt;</a>
<a name="ln111">    ///     DependencyProperty for Orientation.</a>
<a name="ln112">    /// &lt;/summary&gt;</a>
<a name="ln113">    public static readonly DependencyProperty OrientationProperty =</a>
<a name="ln114">        DependencyProperty.Register(&quot;Orientation&quot;, typeof(Orientation), typeof(DataGridHeaderBorder), new FrameworkPropertyMetadata(Orientation.Vertical, FrameworkPropertyMetadataOptions.AffectsRender));</a>
<a name="ln115"> </a>
<a name="ln116">    /// &lt;summary&gt;</a>
<a name="ln117">    ///     When there is a Background or BorderBrush, revert to the Border implementation.</a>
<a name="ln118">    /// &lt;/summary&gt;</a>
<a name="ln119">    private bool UsingBorderImplementation =&gt; (Background != null) || (BorderBrush != null);</a>
<a name="ln120"> </a>
<a name="ln121">    /// &lt;summary&gt;</a>
<a name="ln122">    ///     Property that indicates the brush to use when drawing separators between headers.</a>
<a name="ln123">    /// &lt;/summary&gt;</a>
<a name="ln124">    public Brush SeparatorBrush</a>
<a name="ln125">    {</a>
<a name="ln126">        get =&gt; (Brush)GetValue(SeparatorBrushProperty);</a>
<a name="ln127">        set =&gt; SetValue(SeparatorBrushProperty, value);</a>
<a name="ln128">    }</a>
<a name="ln129"> </a>
<a name="ln130">    /// &lt;summary&gt;</a>
<a name="ln131">    ///     DependencyProperty for SeparatorBrush.</a>
<a name="ln132">    /// &lt;/summary&gt;</a>
<a name="ln133">    public static readonly DependencyProperty SeparatorBrushProperty =</a>
<a name="ln134">        DependencyProperty.Register(&quot;SeparatorBrush&quot;, typeof(Brush), typeof(DataGridHeaderBorder), new FrameworkPropertyMetadata(null));</a>
<a name="ln135"> </a>
<a name="ln136">    /// &lt;summary&gt;</a>
<a name="ln137">    ///     Property that indicates the Visibility for the header separators.</a>
<a name="ln138">    /// &lt;/summary&gt;</a>
<a name="ln139">    public Visibility SeparatorVisibility</a>
<a name="ln140">    {</a>
<a name="ln141">        get =&gt; (Visibility)GetValue(SeparatorVisibilityProperty);</a>
<a name="ln142">        set =&gt; SetValue(SeparatorVisibilityProperty, value);</a>
<a name="ln143">    }</a>
<a name="ln144"> </a>
<a name="ln145">    /// &lt;summary&gt;</a>
<a name="ln146">    ///     DependencyProperty for SeparatorBrush.</a>
<a name="ln147">    /// &lt;/summary&gt;</a>
<a name="ln148">    public static readonly DependencyProperty SeparatorVisibilityProperty =</a>
<a name="ln149">        DependencyProperty.Register(&quot;SeparatorVisibility&quot;, typeof(Visibility), typeof(DataGridHeaderBorder), new FrameworkPropertyMetadata(Visibility.Visible));</a>
<a name="ln150"> </a>
<a name="ln151">    #endregion</a>
<a name="ln152"> </a>
<a name="ln153">    #region Layout</a>
<a name="ln154"> </a>
<a name="ln155">    /// &lt;summary&gt;</a>
<a name="ln156">    /// Calculates the desired size of the element given the constraint.</a>
<a name="ln157">    /// &lt;/summary&gt;</a>
<a name="ln158">    protected override Size MeasureOverride(Size constraint)</a>
<a name="ln159">    {</a>
<a name="ln160">        if (UsingBorderImplementation)</a>
<a name="ln161">        {</a>
<a name="ln162">            // Revert to the Border implementation</a>
<a name="ln163">            return base.MeasureOverride(constraint);</a>
<a name="ln164">        }</a>
<a name="ln165"> </a>
<a name="ln166">        var child = Child;</a>
<a name="ln167">        if (child == null) return new Size();</a>
<a name="ln168"> </a>
<a name="ln169">        // Use the public Padding property if it's set</a>
<a name="ln170">        var padding = Padding;</a>
<a name="ln171">        if (padding.Equals(new Thickness()))</a>
<a name="ln172">            padding = DefaultPadding;</a>
<a name="ln173"> </a>
<a name="ln174">        var childWidth = constraint.Width;</a>
<a name="ln175">        var childHeight = constraint.Height;</a>
<a name="ln176"> </a>
<a name="ln177">        // If there is an actual constraint, then reserve space for the chrome</a>
<a name="ln178">        if (!double.IsInfinity(childWidth))</a>
<a name="ln179">        {</a>
<a name="ln180">            childWidth = Math.Max(0.0, childWidth - padding.Left - padding.Right);</a>
<a name="ln181">        }</a>
<a name="ln182"> </a>
<a name="ln183">        if (!double.IsInfinity(childHeight))</a>
<a name="ln184">        {</a>
<a name="ln185">            childHeight = Math.Max(0.0, childHeight - padding.Top - padding.Bottom);</a>
<a name="ln186">        }</a>
<a name="ln187"> </a>
<a name="ln188">        child.Measure(new Size(childWidth, childHeight));</a>
<a name="ln189">        var desiredSize = child.DesiredSize;</a>
<a name="ln190"> </a>
<a name="ln191">        // Add on the reserved space for the chrome</a>
<a name="ln192">        return new Size(desiredSize.Width + padding.Left + padding.Right, desiredSize.Height + padding.Top + padding.Bottom);</a>
<a name="ln193">    }</a>
<a name="ln194"> </a>
<a name="ln195">    /// &lt;summary&gt;</a>
<a name="ln196">    ///     Positions children and returns the final size of the element.</a>
<a name="ln197">    /// &lt;/summary&gt;</a>
<a name="ln198">    protected override Size ArrangeOverride(Size arrangeSize)</a>
<a name="ln199">    {</a>
<a name="ln200">        if (UsingBorderImplementation)</a>
<a name="ln201">        {</a>
<a name="ln202">            // Revert to the Border implementation</a>
<a name="ln203">            return base.ArrangeOverride(arrangeSize);</a>
<a name="ln204">        }</a>
<a name="ln205"> </a>
<a name="ln206">        var child = Child;</a>
<a name="ln207">        if (child != null)</a>
<a name="ln208">        {</a>
<a name="ln209">            // Use the public Padding property if it's set</a>
<a name="ln210">            var padding = Padding;</a>
<a name="ln211">            if (padding.Equals(new Thickness()))</a>
<a name="ln212">            {</a>
<a name="ln213">                padding = DefaultPadding;</a>
<a name="ln214">            }</a>
<a name="ln215"> </a>
<a name="ln216">            // Reserve space for the chrome</a>
<a name="ln217">            var childWidth = Math.Max(0.0, arrangeSize.Width - padding.Left - padding.Right);</a>
<a name="ln218">            var childHeight = Math.Max(0.0, arrangeSize.Height - padding.Top - padding.Bottom);</a>
<a name="ln219"> </a>
<a name="ln220">            child.Arrange(new Rect(padding.Left, padding.Top, childWidth, childHeight));</a>
<a name="ln221">        }</a>
<a name="ln222"> </a>
<a name="ln223">        return arrangeSize;</a>
<a name="ln224">    }</a>
<a name="ln225"> </a>
<a name="ln226">    #endregion</a>
<a name="ln227"> </a>
<a name="ln228">    #region Rendering</a>
<a name="ln229"> </a>
<a name="ln230">    /// &lt;summary&gt;</a>
<a name="ln231">    ///     Returns a default padding for the various themes for use</a>
<a name="ln232">    ///     by measure and arrange.</a>
<a name="ln233">    /// &lt;/summary&gt;</a>
<a name="ln234">    private Thickness DefaultPadding</a>
<a name="ln235">    {</a>
<a name="ln236">        get</a>
<a name="ln237">        {</a>
<a name="ln238">            var padding = new Thickness(3.0); // The default padding</a>
<a name="ln239">            var themePadding = ThemeDefaultPadding;</a>
<a name="ln240">            if (themePadding == null)</a>
<a name="ln241">            {</a>
<a name="ln242">                if (Orientation == Orientation.Vertical)</a>
<a name="ln243">                {</a>
<a name="ln244">                    // Reserve space to the right for the arrow</a>
<a name="ln245">                    padding.Right = 15.0;</a>
<a name="ln246">                }</a>
<a name="ln247">            }</a>
<a name="ln248">            else</a>
<a name="ln249">            {</a>
<a name="ln250">                padding = (Thickness)themePadding;</a>
<a name="ln251">            }</a>
<a name="ln252"> </a>
<a name="ln253">            // When pressed, offset the child</a>
<a name="ln254">            if (IsPressed &amp;&amp; IsClickable)</a>
<a name="ln255">            {</a>
<a name="ln256">                padding.Left += 1.0;</a>
<a name="ln257">                padding.Top += 1.0;</a>
<a name="ln258">                padding.Right -= 1.0;</a>
<a name="ln259">                padding.Bottom -= 1.0;</a>
<a name="ln260">            }</a>
<a name="ln261"> </a>
<a name="ln262">            return padding;</a>
<a name="ln263">        }</a>
<a name="ln264">    }</a>
<a name="ln265"> </a>
<a name="ln266">    /// &lt;summary&gt;</a>
<a name="ln267">    ///     Called when this element should re-render.</a>
<a name="ln268">    /// &lt;/summary&gt;</a>
<a name="ln269">    protected override void OnRender(DrawingContext dc)</a>
<a name="ln270">    {</a>
<a name="ln271">        if (UsingBorderImplementation)</a>
<a name="ln272">        {</a>
<a name="ln273">            // Revert to the Border implementation</a>
<a name="ln274">            base.OnRender(dc);</a>
<a name="ln275">        }</a>
<a name="ln276">        else</a>
<a name="ln277">        {</a>
<a name="ln278">            RenderTheme(dc);</a>
<a name="ln279">        }</a>
<a name="ln280">    }</a>
<a name="ln281"> </a>
<a name="ln282">    private static double Max0(double d)</a>
<a name="ln283">    {</a>
<a name="ln284">        return Math.Max(0.0, d);</a>
<a name="ln285">    }</a>
<a name="ln286"> </a>
<a name="ln287">    #endregion</a>
<a name="ln288"> </a>
<a name="ln289">    #region Freezable Cache</a>
<a name="ln290"> </a>
<a name="ln291">    /// &lt;summary&gt;</a>
<a name="ln292">    /// Creates a cache of frozen Freezable resources for use across all instances of the border.</a>
<a name="ln293">    /// &lt;/summary&gt;</a>
<a name="ln294">    private static void EnsureCache(int size)</a>
<a name="ln295">    {</a>
<a name="ln296">        // Quick check to avoid locking</a>
<a name="ln297">        if (_freezableCache == null)</a>
<a name="ln298">        {</a>
<a name="ln299">            lock (_cacheAccess)</a>
<a name="ln300">            {</a>
<a name="ln301">                // Re-check in case another thread created the cache</a>
<a name="ln302">                if (_freezableCache == null)</a>
<a name="ln303">                {</a>
<a name="ln304">                    _freezableCache = new List&lt;Freezable&gt;(size);</a>
<a name="ln305">                    for (var i = 0; i &lt; size; i++)</a>
<a name="ln306">                    {</a>
<a name="ln307">                        _freezableCache.Add(null);</a>
<a name="ln308">                    }</a>
<a name="ln309">                }</a>
<a name="ln310">            }</a>
<a name="ln311">        }</a>
<a name="ln312"> </a>
<a name="ln313">        Debug.Assert(_freezableCache.Count == size, &quot;The cache size does not match the requested amount.&quot;);</a>
<a name="ln314">    }</a>
<a name="ln315"> </a>
<a name="ln316">    /// &lt;summary&gt;</a>
<a name="ln317">    /// Releases all resources in the cache.</a>
<a name="ln318">    /// &lt;/summary&gt;</a>
<a name="ln319">    private static void ReleaseCache()</a>
<a name="ln320">    {</a>
<a name="ln321">        // Avoid locking if necessary</a>
<a name="ln322">        if (_freezableCache != null)</a>
<a name="ln323">        {</a>
<a name="ln324">            lock (_cacheAccess)</a>
<a name="ln325">            {</a>
<a name="ln326">                // No need to re-check if non-null since it's OK to set it to null multiple times</a>
<a name="ln327">                _freezableCache = null;</a>
<a name="ln328">            }</a>
<a name="ln329">        }</a>
<a name="ln330">    }</a>
<a name="ln331"> </a>
<a name="ln332">    /// &lt;summary&gt;</a>
<a name="ln333">    /// Retrieves a cached resource.</a>
<a name="ln334">    /// &lt;/summary&gt;</a>
<a name="ln335">    private static Freezable GetCachedFreezable(int index)</a>
<a name="ln336">    {</a>
<a name="ln337">        lock (_cacheAccess)</a>
<a name="ln338">        {</a>
<a name="ln339">            var freezable = _freezableCache[index];</a>
<a name="ln340">            Debug.Assert((freezable == null) || freezable.IsFrozen, &quot;Cached Freezables should have been frozen.&quot;);</a>
<a name="ln341">            return freezable;</a>
<a name="ln342">        }</a>
<a name="ln343">    }</a>
<a name="ln344"> </a>
<a name="ln345">    /// &lt;summary&gt;</a>
<a name="ln346">    /// Caches a resources.</a>
<a name="ln347">    /// &lt;/summary&gt;</a>
<a name="ln348">    private static void CacheFreezable(Freezable freezable, int index)</a>
<a name="ln349">    {</a>
<a name="ln350">        Debug.Assert(freezable.IsFrozen, &quot;Cached Freezables should be frozen.&quot;);</a>
<a name="ln351"> </a>
<a name="ln352">        lock (_cacheAccess)</a>
<a name="ln353">        {</a>
<a name="ln354">            if (_freezableCache[index] != null)</a>
<a name="ln355">            {</a>
<a name="ln356">                _freezableCache[index] = freezable;</a>
<a name="ln357">            }</a>
<a name="ln358">        }</a>
<a name="ln359">    }</a>
<a name="ln360"> </a>
<a name="ln361">    private static List&lt;Freezable&gt; _freezableCache;</a>
<a name="ln362">    private static readonly object _cacheAccess = new object();</a>
<a name="ln363"> </a>
<a name="ln364">    #endregion</a>
<a name="ln365"> </a>
<a name="ln366">    #region Theme Rendering</a>
<a name="ln367"> </a>
<a name="ln368">    private Thickness? ThemeDefaultPadding</a>
<a name="ln369">    {</a>
<a name="ln370">        get</a>
<a name="ln371">        {</a>
<a name="ln372">            if (Orientation == Orientation.Vertical)</a>
<a name="ln373">            {</a>
<a name="ln374">                return new Thickness(5.0, 4.0, 5.0, 4.0);</a>
<a name="ln375">            }</a>
<a name="ln376">            return null;</a>
<a name="ln377">        }</a>
<a name="ln378">    }</a>
<a name="ln379"> </a>
<a name="ln380">    private void RenderTheme(DrawingContext dc)</a>
<a name="ln381">    {</a>
<a name="ln382">        var size = RenderSize;</a>
<a name="ln383">        var horizontal = Orientation == Orientation.Horizontal;</a>
<a name="ln384">        var isClickable = IsClickable &amp;&amp; IsEnabled;</a>
<a name="ln385">        var isHovered = isClickable &amp;&amp; IsHovered;</a>
<a name="ln386">        var isPressed = isClickable &amp;&amp; IsPressed;</a>
<a name="ln387">        var sortDirection = SortDirection;</a>
<a name="ln388">        var isSorted = sortDirection != null;</a>
<a name="ln389">        var isSelected = IsSelected;</a>
<a name="ln390">        var hasBevel = (!isHovered &amp;&amp; !isPressed &amp;&amp; !isSorted &amp;&amp; !isSelected);</a>
<a name="ln391"> </a>
<a name="ln392">        EnsureCache((int)AeroFreezables.NumFreezables);</a>
<a name="ln393"> </a>
<a name="ln394">        if (horizontal)</a>
<a name="ln395">        {</a>
<a name="ln396">            // When horizontal, rotate the rendering by -90 degrees</a>
<a name="ln397">            var m1 = new Matrix();</a>
<a name="ln398">            m1.RotateAt(-90.0, 0.0, 0.0);</a>
<a name="ln399">            var m2 = new Matrix();</a>
<a name="ln400">            m2.Translate(0.0, size.Height);</a>
<a name="ln401"> </a>
<a name="ln402">            var horizontalRotate = new MatrixTransform(m1 * m2);</a>
<a name="ln403">            horizontalRotate.Freeze();</a>
<a name="ln404">            dc.PushTransform(horizontalRotate);</a>
<a name="ln405"> </a>
<a name="ln406">            var temp = size.Width;</a>
<a name="ln407">            size.Width = size.Height;</a>
<a name="ln408">            size.Height = temp;</a>
<a name="ln409">        }</a>
<a name="ln410"> </a>
<a name="ln411">        if (hasBevel)</a>
<a name="ln412">        {</a>
<a name="ln413">            // This is a highlight that can be drawn by just filling the background with the color.</a>
<a name="ln414">            // It will be seen through the gab between the border and the background.</a>
<a name="ln415">            var bevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.NormalBevel);</a>
<a name="ln416">            if (bevel == null)</a>
<a name="ln417">            {</a>
<a name="ln418">                bevel = new LinearGradientBrush();</a>
<a name="ln419">                bevel.StartPoint = new Point();</a>
<a name="ln420">                bevel.EndPoint = new Point(0.0, 1.0);</a>
<a name="ln421">                bevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xFF, 0xFF, 0xFF), 0.0));</a>
<a name="ln422">                bevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xFF, 0xFF, 0xFF), 0.4));</a>
<a name="ln423">                bevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xFC, 0xFC, 0xFD), 0.4));</a>
<a name="ln424">                bevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xFB, 0xFC, 0xFC), 1.0));</a>
<a name="ln425">                bevel.Freeze();</a>
<a name="ln426"> </a>
<a name="ln427">                CacheFreezable(bevel, (int)AeroFreezables.NormalBevel);</a>
<a name="ln428">            }</a>
<a name="ln429"> </a>
<a name="ln430">            dc.DrawRectangle(bevel, null, new Rect(0.0, 0.0, size.Width, size.Height));</a>
<a name="ln431">        }</a>
<a name="ln432"> </a>
<a name="ln433">        // Fill the background</a>
<a name="ln434">        var backgroundType = AeroFreezables.NormalBackground;</a>
<a name="ln435">        if (isPressed)</a>
<a name="ln436">        {</a>
<a name="ln437">            backgroundType = AeroFreezables.PressedBackground;</a>
<a name="ln438">        }</a>
<a name="ln439">        else if (isHovered)</a>
<a name="ln440">        {</a>
<a name="ln441">            backgroundType = AeroFreezables.HoveredBackground;</a>
<a name="ln442">        }</a>
<a name="ln443">        else if (isSorted || isSelected)</a>
<a name="ln444">        {</a>
<a name="ln445">            backgroundType = AeroFreezables.SortedBackground;</a>
<a name="ln446">        }</a>
<a name="ln447"> </a>
<a name="ln448">        var background = (LinearGradientBrush)GetCachedFreezable((int)backgroundType);</a>
<a name="ln449">        if (background == null)</a>
<a name="ln450">        {</a>
<a name="ln451">            background = new LinearGradientBrush();</a>
<a name="ln452">            background.StartPoint = new Point();</a>
<a name="ln453">            background.EndPoint = new Point(0.0, 1.0);</a>
<a name="ln454"> </a>
<a name="ln455">            switch (backgroundType)</a>
<a name="ln456">            {</a>
<a name="ln457">                case AeroFreezables.NormalBackground:</a>
<a name="ln458">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xFF, 0xFF, 0xFF), 0.0));</a>
<a name="ln459">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xFF, 0xFF, 0xFF), 0.4));</a>
<a name="ln460">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xF7, 0xF8, 0xFA), 0.4));</a>
<a name="ln461">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xF1, 0xF2, 0xF4), 1.0));</a>
<a name="ln462">                    break;</a>
<a name="ln463"> </a>
<a name="ln464">                case AeroFreezables.PressedBackground:</a>
<a name="ln465">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xBC, 0xE4, 0xF9), 0.0));</a>
<a name="ln466">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xBC, 0xE4, 0xF9), 0.4));</a>
<a name="ln467">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x8D, 0xD6, 0xF7), 0.4));</a>
<a name="ln468">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x8A, 0xD1, 0xF5), 1.0));</a>
<a name="ln469">                    break;</a>
<a name="ln470"> </a>
<a name="ln471">                case AeroFreezables.HoveredBackground:</a>
<a name="ln472">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xE3, 0xF7, 0xFF), 0.0));</a>
<a name="ln473">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xE3, 0xF7, 0xFF), 0.4));</a>
<a name="ln474">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xBD, 0xED, 0xFF), 0.4));</a>
<a name="ln475">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xB7, 0xE7, 0xFB), 1.0));</a>
<a name="ln476">                    break;</a>
<a name="ln477"> </a>
<a name="ln478">                case AeroFreezables.SortedBackground:</a>
<a name="ln479">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xF2, 0xF9, 0xFC), 0.0));</a>
<a name="ln480">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xF2, 0xF9, 0xFC), 0.4));</a>
<a name="ln481">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xE1, 0xF1, 0xF9), 0.4));</a>
<a name="ln482">                    background.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xD8, 0xEC, 0xF6), 1.0));</a>
<a name="ln483">                    break;</a>
<a name="ln484">            }</a>
<a name="ln485"> </a>
<a name="ln486">            background.Freeze();</a>
<a name="ln487"> </a>
<a name="ln488">            CacheFreezable(background, (int)backgroundType);</a>
<a name="ln489">        }</a>
<a name="ln490"> </a>
<a name="ln491">        dc.DrawRectangle(background, null, new Rect(0.0, 0.0, size.Width, size.Height));</a>
<a name="ln492"> </a>
<a name="ln493">        if (size.Width &gt;= 2.0)</a>
<a name="ln494">        {</a>
<a name="ln495">            // Draw the borders on the sides</a>
<a name="ln496">            var sideType = AeroFreezables.NormalSides;</a>
<a name="ln497">            if (isPressed)</a>
<a name="ln498">            {</a>
<a name="ln499">                sideType = AeroFreezables.PressedSides;</a>
<a name="ln500">            }</a>
<a name="ln501">            else if (isHovered)</a>
<a name="ln502">            {</a>
<a name="ln503">                sideType = AeroFreezables.HoveredSides;</a>
<a name="ln504">            }</a>
<a name="ln505">            else if (isSorted || isSelected)</a>
<a name="ln506">            {</a>
<a name="ln507">                sideType = AeroFreezables.SortedSides;</a>
<a name="ln508">            }</a>
<a name="ln509"> </a>
<a name="ln510">            if (SeparatorVisibility == Visibility.Visible)</a>
<a name="ln511">            {</a>
<a name="ln512">                Brush sideBrush;</a>
<a name="ln513">                if (SeparatorBrush != null)</a>
<a name="ln514">                {</a>
<a name="ln515">                    sideBrush = SeparatorBrush;</a>
<a name="ln516">                }</a>
<a name="ln517">                else</a>
<a name="ln518">                {</a>
<a name="ln519">                    sideBrush = (Brush)GetCachedFreezable((int)sideType);</a>
<a name="ln520">                    if (sideBrush == null)</a>
<a name="ln521">                    {</a>
<a name="ln522">                        LinearGradientBrush lgBrush = null;</a>
<a name="ln523">                        if (sideType != AeroFreezables.SortedSides)</a>
<a name="ln524">                        {</a>
<a name="ln525">                            lgBrush = new LinearGradientBrush();</a>
<a name="ln526">                            lgBrush.StartPoint = new Point();</a>
<a name="ln527">                            lgBrush.EndPoint = new Point(0.0, 1.0);</a>
<a name="ln528">                            sideBrush = lgBrush;</a>
<a name="ln529">                        }</a>
<a name="ln530"> </a>
<a name="ln531">                        switch (sideType)</a>
<a name="ln532">                        {</a>
<a name="ln533">                            case AeroFreezables.NormalSides:</a>
<a name="ln534">                                lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xF2, 0xF2, 0xF2), 0.0));</a>
<a name="ln535">                                lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xEF, 0xEF, 0xEF), 0.4));</a>
<a name="ln536">                                lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xE7, 0xE8, 0xEA), 0.4));</a>
<a name="ln537">                                lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xDE, 0xDF, 0xE1), 1.0));</a>
<a name="ln538">                                break;</a>
<a name="ln539"> </a>
<a name="ln540">                            case AeroFreezables.PressedSides:</a>
<a name="ln541">                                lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x7A, 0x9E, 0xB1), 0.0));</a>
<a name="ln542">                                lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x7A, 0x9E, 0xB1), 0.4));</a>
<a name="ln543">                                lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x50, 0x91, 0xAF), 0.4));</a>
<a name="ln544">                                lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x4D, 0x8D, 0xAD), 1.0));</a>
<a name="ln545">                                break;</a>
<a name="ln546"> </a>
<a name="ln547">                            case AeroFreezables.HoveredSides:</a>
<a name="ln548">                                lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x88, 0xCB, 0xEB), 0.0));</a>
<a name="ln549">                                lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x88, 0xCB, 0xEB), 0.4));</a>
<a name="ln550">                                lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x69, 0xBB, 0xE3), 0.4));</a>
<a name="ln551">                                lgBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x69, 0xBB, 0xE3), 1.0));</a>
<a name="ln552">                                break;</a>
<a name="ln553"> </a>
<a name="ln554">                            case AeroFreezables.SortedSides:</a>
<a name="ln555">                                sideBrush = new SolidColorBrush(Color.FromArgb(0xFF, 0x96, 0xD9, 0xF9));</a>
<a name="ln556">                                break;</a>
<a name="ln557">                        }</a>
<a name="ln558"> </a>
<a name="ln559">                        sideBrush.Freeze();</a>
<a name="ln560"> </a>
<a name="ln561">                        CacheFreezable(sideBrush, (int)sideType);</a>
<a name="ln562">                    }</a>
<a name="ln563">                }</a>
<a name="ln564"> </a>
<a name="ln565">                dc.DrawRectangle(sideBrush, null, new Rect(0.0, 0.0, 1.0, Max0(size.Height - 0.95)));</a>
<a name="ln566">                dc.DrawRectangle(sideBrush, null, new Rect(size.Width - 1.0, 0.0, 1.0, Max0(size.Height - 0.95)));</a>
<a name="ln567">            }</a>
<a name="ln568">        }</a>
<a name="ln569"> </a>
<a name="ln570">        if (isPressed &amp;&amp; (size.Width &gt;= 4.0) &amp;&amp; (size.Height &gt;= 4.0))</a>
<a name="ln571">        {</a>
<a name="ln572">            // When pressed, there are added borders on the left and top</a>
<a name="ln573">            var topBrush = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedTop);</a>
<a name="ln574">            if (topBrush == null)</a>
<a name="ln575">            {</a>
<a name="ln576">                topBrush = new LinearGradientBrush();</a>
<a name="ln577">                topBrush.StartPoint = new Point();</a>
<a name="ln578">                topBrush.EndPoint = new Point(0.0, 1.0);</a>
<a name="ln579">                topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x86, 0xA3, 0xB2), 0.0));</a>
<a name="ln580">                topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x86, 0xA3, 0xB2), 0.1));</a>
<a name="ln581">                topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xAA, 0xCE, 0xE1), 0.9));</a>
<a name="ln582">                topBrush.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xAA, 0xCE, 0xE1), 1.0));</a>
<a name="ln583">                topBrush.Freeze();</a>
<a name="ln584"> </a>
<a name="ln585">                CacheFreezable(topBrush, (int)AeroFreezables.PressedTop);</a>
<a name="ln586">            }</a>
<a name="ln587"> </a>
<a name="ln588">            dc.DrawRectangle(topBrush, null, new Rect(0.0, 0.0, size.Width, 2.0));</a>
<a name="ln589"> </a>
<a name="ln590">            var pressedBevel = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.PressedBevel);</a>
<a name="ln591">            if (pressedBevel == null)</a>
<a name="ln592">            {</a>
<a name="ln593">                pressedBevel = new LinearGradientBrush();</a>
<a name="ln594">                pressedBevel.StartPoint = new Point();</a>
<a name="ln595">                pressedBevel.EndPoint = new Point(0.0, 1.0);</a>
<a name="ln596">                pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xA2, 0xCB, 0xE0), 0.0));</a>
<a name="ln597">                pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xA2, 0xCB, 0xE0), 0.4));</a>
<a name="ln598">                pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x72, 0xBC, 0xDF), 0.4));</a>
<a name="ln599">                pressedBevel.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x6E, 0xB8, 0xDC), 1.0));</a>
<a name="ln600">                pressedBevel.Freeze();</a>
<a name="ln601"> </a>
<a name="ln602">                CacheFreezable(pressedBevel, (int)AeroFreezables.PressedBevel);</a>
<a name="ln603">            }</a>
<a name="ln604"> </a>
<a name="ln605">            dc.DrawRectangle(pressedBevel, null, new Rect(1.0, 0.0, 1.0, size.Height - 0.95));</a>
<a name="ln606">            dc.DrawRectangle(pressedBevel, null, new Rect(size.Width - 2.0, 0.0, 1.0, size.Height - 0.95));</a>
<a name="ln607">        }</a>
<a name="ln608"> </a>
<a name="ln609">        if (size.Height &gt;= 2.0)</a>
<a name="ln610">        {</a>
<a name="ln611">            // Draw the bottom border</a>
<a name="ln612">            var bottomType = AeroFreezables.NormalBottom;</a>
<a name="ln613">            if (isPressed)</a>
<a name="ln614">            {</a>
<a name="ln615">                bottomType = AeroFreezables.PressedOrHoveredBottom;</a>
<a name="ln616">            }</a>
<a name="ln617">            else if (isHovered)</a>
<a name="ln618">            {</a>
<a name="ln619">                bottomType = AeroFreezables.PressedOrHoveredBottom;</a>
<a name="ln620">            }</a>
<a name="ln621">            else if (isSorted || isSelected)</a>
<a name="ln622">            {</a>
<a name="ln623">                bottomType = AeroFreezables.SortedBottom;</a>
<a name="ln624">            }</a>
<a name="ln625"> </a>
<a name="ln626">            var bottomBrush = (SolidColorBrush)GetCachedFreezable((int)bottomType);</a>
<a name="ln627">            if (bottomBrush == null)</a>
<a name="ln628">            {</a>
<a name="ln629">                switch (bottomType)</a>
<a name="ln630">                {</a>
<a name="ln631">                    case AeroFreezables.NormalBottom:</a>
<a name="ln632">                        bottomBrush = new SolidColorBrush(Color.FromArgb(0xFF, 0xD5, 0xD5, 0xD5));</a>
<a name="ln633">                        break;</a>
<a name="ln634"> </a>
<a name="ln635">                    case AeroFreezables.PressedOrHoveredBottom:</a>
<a name="ln636">                        bottomBrush = new SolidColorBrush(Color.FromArgb(0xFF, 0x93, 0xC9, 0xE3));</a>
<a name="ln637">                        break;</a>
<a name="ln638"> </a>
<a name="ln639">                    case AeroFreezables.SortedBottom:</a>
<a name="ln640">                        bottomBrush = new SolidColorBrush(Color.FromArgb(0xFF, 0x96, 0xD9, 0xF9));</a>
<a name="ln641">                        break;</a>
<a name="ln642">                }</a>
<a name="ln643"> </a>
<a name="ln644">                bottomBrush.Freeze();</a>
<a name="ln645"> </a>
<a name="ln646">                CacheFreezable(bottomBrush, (int)bottomType);</a>
<a name="ln647">            }</a>
<a name="ln648"> </a>
<a name="ln649">            dc.DrawRectangle(bottomBrush, null, new Rect(0.0, size.Height - 1.0, size.Width, 1.0));</a>
<a name="ln650">        }</a>
<a name="ln651"> </a>
<a name="ln652">        if (isSorted &amp;&amp; (size.Width &gt; 14.0) &amp;&amp; (size.Height &gt; 10.0))</a>
<a name="ln653">        {</a>
<a name="ln654">            // Draw the sort arrow</a>
<a name="ln655">            var positionTransform = new TranslateTransform((size.Width - 8.0) * 0.5, 1.0);</a>
<a name="ln656">            positionTransform.Freeze();</a>
<a name="ln657">            dc.PushTransform(positionTransform);</a>
<a name="ln658"> </a>
<a name="ln659">            var ascending = (sortDirection == ListSortDirection.Ascending);</a>
<a name="ln660">            var arrowGeometry = (PathGeometry)GetCachedFreezable(ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);</a>
<a name="ln661">            if (arrowGeometry == null)</a>
<a name="ln662">            {</a>
<a name="ln663">                arrowGeometry = new PathGeometry();</a>
<a name="ln664">                var arrowFigure = new PathFigure();</a>
<a name="ln665"> </a>
<a name="ln666">                if (ascending)</a>
<a name="ln667">                {</a>
<a name="ln668">                    arrowFigure.StartPoint = new Point(0.0, 4.0);</a>
<a name="ln669"> </a>
<a name="ln670">                    var line = new LineSegment(new Point(4.0, 0.0), false);</a>
<a name="ln671">                    line.Freeze();</a>
<a name="ln672">                    arrowFigure.Segments.Add(line);</a>
<a name="ln673"> </a>
<a name="ln674">                    line = new LineSegment(new Point(8.0, 4.0), false);</a>
<a name="ln675">                    line.Freeze();</a>
<a name="ln676">                    arrowFigure.Segments.Add(line);</a>
<a name="ln677">                }</a>
<a name="ln678">                else</a>
<a name="ln679">                {</a>
<a name="ln680">                    arrowFigure.StartPoint = new Point(0.0, 0.0);</a>
<a name="ln681"> </a>
<a name="ln682">                    var line = new LineSegment(new Point(8.0, 0.0), false);</a>
<a name="ln683">                    line.Freeze();</a>
<a name="ln684">                    arrowFigure.Segments.Add(line);</a>
<a name="ln685"> </a>
<a name="ln686">                    line = new LineSegment(new Point(4.0, 4.0), false);</a>
<a name="ln687">                    line.Freeze();</a>
<a name="ln688">                    arrowFigure.Segments.Add(line);</a>
<a name="ln689">                }</a>
<a name="ln690"> </a>
<a name="ln691">                arrowFigure.IsClosed = true;</a>
<a name="ln692">                arrowFigure.Freeze();</a>
<a name="ln693"> </a>
<a name="ln694">                arrowGeometry.Figures.Add(arrowFigure);</a>
<a name="ln695">                arrowGeometry.Freeze();</a>
<a name="ln696"> </a>
<a name="ln697">                CacheFreezable(arrowGeometry, ascending ? (int)AeroFreezables.ArrowUpGeometry : (int)AeroFreezables.ArrowDownGeometry);</a>
<a name="ln698">            }</a>
<a name="ln699"> </a>
<a name="ln700">            // Draw two arrows, one inset in the other. This is to achieve a double gradient over both the border and the fill.</a>
<a name="ln701">            var arrowBorder = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowBorder);</a>
<a name="ln702">            if (arrowBorder == null)</a>
<a name="ln703">            {</a>
<a name="ln704">                arrowBorder = new LinearGradientBrush();</a>
<a name="ln705">                arrowBorder.StartPoint = new Point();</a>
<a name="ln706">                arrowBorder.EndPoint = new Point(1.0, 1.0);</a>
<a name="ln707">                arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x3C, 0x5E, 0x72), 0.0));</a>
<a name="ln708">                arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x3C, 0x5E, 0x72), 0.1));</a>
<a name="ln709">                arrowBorder.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xC3, 0xE4, 0xF5), 1.0));</a>
<a name="ln710">                arrowBorder.Freeze();</a>
<a name="ln711">                CacheFreezable(arrowBorder, (int)AeroFreezables.ArrowBorder);</a>
<a name="ln712">            }</a>
<a name="ln713"> </a>
<a name="ln714">            dc.DrawGeometry(arrowBorder, null, arrowGeometry);</a>
<a name="ln715"> </a>
<a name="ln716">            var arrowFill = (LinearGradientBrush)GetCachedFreezable((int)AeroFreezables.ArrowFill);</a>
<a name="ln717">            if (arrowFill == null)</a>
<a name="ln718">            {</a>
<a name="ln719">                arrowFill = new LinearGradientBrush();</a>
<a name="ln720">                arrowFill.StartPoint = new Point();</a>
<a name="ln721">                arrowFill.EndPoint = new Point(1.0, 1.0);</a>
<a name="ln722">                arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x61, 0x96, 0xB6), 0.0));</a>
<a name="ln723">                arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0x61, 0x96, 0xB6), 0.1));</a>
<a name="ln724">                arrowFill.GradientStops.Add(new GradientStop(Color.FromArgb(0xFF, 0xCA, 0xE6, 0xF5), 1.0));</a>
<a name="ln725">                arrowFill.Freeze();</a>
<a name="ln726">                CacheFreezable(arrowFill, (int)AeroFreezables.ArrowFill);</a>
<a name="ln727">            }</a>
<a name="ln728"> </a>
<a name="ln729">            // Inset the fill arrow inside the border arrow</a>
<a name="ln730">            var arrowScale = (ScaleTransform)GetCachedFreezable((int)AeroFreezables.ArrowFillScale);</a>
<a name="ln731">            if (arrowScale == null)</a>
<a name="ln732">            {</a>
<a name="ln733">                arrowScale = new ScaleTransform(0.75, 0.75, 3.5, 4.0);</a>
<a name="ln734">                arrowScale.Freeze();</a>
<a name="ln735">                CacheFreezable(arrowScale, (int)AeroFreezables.ArrowFillScale);</a>
<a name="ln736">            }</a>
<a name="ln737"> </a>
<a name="ln738">            dc.PushTransform(arrowScale);</a>
<a name="ln739"> </a>
<a name="ln740">            dc.DrawGeometry(arrowFill, null, arrowGeometry);</a>
<a name="ln741"> </a>
<a name="ln742">            dc.Pop(); // Scale Transform</a>
<a name="ln743">            dc.Pop(); // Position Transform</a>
<a name="ln744">        }</a>
<a name="ln745"> </a>
<a name="ln746">        if (horizontal)</a>
<a name="ln747">        {</a>
<a name="ln748">            dc.Pop(); // Horizontal Rotate</a>
<a name="ln749">        }</a>
<a name="ln750">    }</a>
<a name="ln751"> </a>
<a name="ln752">    private enum AeroFreezables : int</a>
<a name="ln753">    {</a>
<a name="ln754">        NormalBevel,</a>
<a name="ln755">        NormalBackground,</a>
<a name="ln756">        PressedBackground,</a>
<a name="ln757">        HoveredBackground,</a>
<a name="ln758">        SortedBackground,</a>
<a name="ln759">        PressedTop,</a>
<a name="ln760">        NormalSides,</a>
<a name="ln761">        PressedSides,</a>
<a name="ln762">        HoveredSides,</a>
<a name="ln763">        SortedSides,</a>
<a name="ln764">        PressedBevel,</a>
<a name="ln765">        NormalBottom,</a>
<a name="ln766">        PressedOrHoveredBottom,</a>
<a name="ln767">        SortedBottom,</a>
<a name="ln768">        ArrowBorder,</a>
<a name="ln769">        ArrowFill,</a>
<a name="ln770">        ArrowFillScale,</a>
<a name="ln771">        ArrowUpGeometry,</a>
<a name="ln772">        ArrowDownGeometry,</a>
<a name="ln773">        NumFreezables</a>
<a name="ln774">    }</a>
<a name="ln775"> </a>
<a name="ln776">    #endregion</a>
<a name="ln777">}</a>
</code></pre>
<div class="balloon" rel="302"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3054/" target="_blank">V3054</a> Potentially unsafe double-checked locking. Use volatile variable(s) or synchronization primitives to avoid this.</p></div>
<div class="balloon" rel="534"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3080/" target="_blank">V3080</a> Possible null dereference. Consider inspecting 'lgBrush'.</p></div>
<div class="balloon" rel="302"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v5604/" target="_blank">V5604</a> Potentially unsafe double-checked locking. Use volatile variable(s) or synchronization primitives to avoid this.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>