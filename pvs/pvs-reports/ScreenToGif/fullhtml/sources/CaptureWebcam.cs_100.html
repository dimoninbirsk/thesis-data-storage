<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>CaptureWebcam.cs</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cs">
<a name="ln1">#region License</a>
<a name="ln2"> </a>
<a name="ln3">// ------------------------------------------------------------------</a>
<a name="ln4">// Adapted work from DirectX.Capture</a>
<a name="ln5">// https://www.codeproject.com/articles/3566/directx-capture-class-library</a>
<a name="ln6">// http://creativecommons.org/licenses/publicdomain/</a>
<a name="ln7">// -----------------------------------------------------------------</a>
<a name="ln8"> </a>
<a name="ln9">#endregion</a>
<a name="ln10"> </a>
<a name="ln11">using System;</a>
<a name="ln12">using System.Drawing;</a>
<a name="ln13">using System.Runtime.InteropServices;</a>
<a name="ln14">using System.Windows;</a>
<a name="ln15">using System.Windows.Controls;</a>
<a name="ln16">using System.Windows.Interop;</a>
<a name="ln17">using ScreenToGif.Webcam.DirectShow;</a>
<a name="ln18"> </a>
<a name="ln19">namespace ScreenToGif.Webcam.DirectX;</a>
<a name="ln20"> </a>
<a name="ln21">/// &lt;summary&gt;</a>
<a name="ln22">/// Gets the video output of a webcam or other video device.</a>
<a name="ln23">/// &lt;/summary&gt;</a>
<a name="ln24">public class CaptureWebcam : EditStreaming.ISampleGrabberCB, IDisposable</a>
<a name="ln25">{</a>
<a name="ln26">    #region Properties</a>
<a name="ln27"> </a>
<a name="ln28">    /// &lt;summary&gt;</a>
<a name="ln29">    ///  The video capture device filter. Read-only. To use a different</a>
<a name="ln30">    ///  device, dispose of the current Capture instance and create a new</a>
<a name="ln31">    ///  instance with the desired device.</a>
<a name="ln32">    /// &lt;/summary&gt;</a>
<a name="ln33">    public Filter VideoDevice { get; private set; }</a>
<a name="ln34"> </a>
<a name="ln35">    /// &lt;summary&gt;</a>
<a name="ln36">    ///  The control that will host the preview window.</a>
<a name="ln37">    /// &lt;/summary&gt;</a>
<a name="ln38">    public ContentControl PreviewWindow { get; set; }</a>
<a name="ln39"> </a>
<a name="ln40">    /// &lt;summary&gt;</a>
<a name="ln41">    /// The Height of the video feed.</a>
<a name="ln42">    /// &lt;/summary&gt;</a>
<a name="ln43">    public int Height</a>
<a name="ln44">    {</a>
<a name="ln45">        get</a>
<a name="ln46">        {</a>
<a name="ln47">            if (_videoInfoHeader != null)</a>
<a name="ln48">                return _videoInfoHeader.BmiHeader.Height;</a>
<a name="ln49"> </a>
<a name="ln50">            return -1;</a>
<a name="ln51">        }</a>
<a name="ln52">    }</a>
<a name="ln53"> </a>
<a name="ln54">    /// &lt;summary&gt;</a>
<a name="ln55">    /// The Width of the video feed.</a>
<a name="ln56">    /// &lt;/summary&gt;</a>
<a name="ln57">    public int Width</a>
<a name="ln58">    {</a>
<a name="ln59">        get</a>
<a name="ln60">        {</a>
<a name="ln61">            if (_videoInfoHeader != null)</a>
<a name="ln62">                return _videoInfoHeader.BmiHeader.Width;</a>
<a name="ln63"> </a>
<a name="ln64">            return -1;</a>
<a name="ln65">        }</a>
<a name="ln66">    }</a>
<a name="ln67"> </a>
<a name="ln68">    /// &lt;summary&gt;</a>
<a name="ln69">    /// The Scale of the video feed.</a>
<a name="ln70">    /// &lt;/summary&gt;</a>
<a name="ln71">    public double Scale { get; set; }</a>
<a name="ln72"> </a>
<a name="ln73">    #endregion</a>
<a name="ln74"> </a>
<a name="ln75">    #region Enum</a>
<a name="ln76"> </a>
<a name="ln77">    /// &lt;summary&gt;</a>
<a name="ln78">    /// Possible states of the internal filter graph.</a>
<a name="ln79">    /// &lt;/summary&gt;</a>
<a name="ln80">    protected enum GraphState</a>
<a name="ln81">    {</a>
<a name="ln82">        /// &lt;summary&gt;</a>
<a name="ln83">        /// No filter graph at all.</a>
<a name="ln84">        /// &lt;/summary&gt;</a>
<a name="ln85">        Null,</a>
<a name="ln86">        /// &lt;summary&gt;</a>
<a name="ln87">        /// Filter graph created with device filters added.</a>
<a name="ln88">        /// &lt;/summary&gt;</a>
<a name="ln89">        Created,</a>
<a name="ln90"> </a>
<a name="ln91">        /// &lt;summary&gt;</a>
<a name="ln92">        /// Filter complete built, ready to run (possibly previewing).</a>
<a name="ln93">        /// &lt;/summary&gt;</a>
<a name="ln94">        Rendered,</a>
<a name="ln95"> </a>
<a name="ln96">        /// &lt;summary&gt;</a>
<a name="ln97">        /// Recording is live.</a>
<a name="ln98">        /// &lt;/summary&gt;</a>
<a name="ln99">        Live</a>
<a name="ln100">    }</a>
<a name="ln101"> </a>
<a name="ln102">    #endregion</a>
<a name="ln103"> </a>
<a name="ln104">    #region Variables</a>
<a name="ln105"> </a>
<a name="ln106">    /// &lt;summary&gt;</a>
<a name="ln107">    /// When graphState==Rendered, have we rendered the preview stream?</a>
<a name="ln108">    /// &lt;/summary&gt;</a>
<a name="ln109">    protected bool IsPreviewRendered = false;</a>
<a name="ln110"> </a>
<a name="ln111">    /// &lt;summary&gt;</a>
<a name="ln112">    /// Do we need the preview stream rendered (VideoDevice and PreviewWindow != null)</a>
<a name="ln113">    /// &lt;/summary&gt;</a>
<a name="ln114">    protected bool WantPreviewRendered = false;</a>
<a name="ln115"> </a>
<a name="ln116">    ///// &lt;summary&gt;</a>
<a name="ln117">    ///// List of physical video sources</a>
<a name="ln118">    ///// &lt;/summary&gt;</a>
<a name="ln119">    //protected SourceCollection videoSources = null;</a>
<a name="ln120"> </a>
<a name="ln121">    /// &lt;summary&gt;</a>
<a name="ln122">    /// State of the internal filter graph.</a>
<a name="ln123">    /// &lt;/summary&gt;</a>
<a name="ln124">    protected GraphState ActualGraphState = GraphState.Null;</a>
<a name="ln125"> </a>
<a name="ln126">    /// &lt;summary&gt;</a>
<a name="ln127">    /// DShow Filter: Graph builder.</a>
<a name="ln128">    /// &lt;/summary&gt;</a>
<a name="ln129">    protected ExtendStreaming.IGraphBuilder GraphBuilder;</a>
<a name="ln130"> </a>
<a name="ln131">    /// &lt;summary&gt;</a>
<a name="ln132">    /// DShow Filter: building graphs for capturing video.</a>
<a name="ln133">    /// &lt;/summary&gt;</a>
<a name="ln134">    protected ExtendStreaming.ICaptureGraphBuilder2 CaptureGraphBuilder = null;</a>
<a name="ln135"> </a>
<a name="ln136">    /// &lt;summary&gt;</a>
<a name="ln137">    /// DShow Filter: selected video device.</a>
<a name="ln138">    /// &lt;/summary&gt;</a>
<a name="ln139">    protected CoreStreaming.IBaseFilter VideoDeviceFilter = null;</a>
<a name="ln140"> </a>
<a name="ln141">    /// &lt;summary&gt;</a>
<a name="ln142">    /// DShow Filter: configure frame rate, size.</a>
<a name="ln143">    /// &lt;/summary&gt;</a>
<a name="ln144">    protected ExtendStreaming.IAMStreamConfig VideoStreamConfig = null;</a>
<a name="ln145"> </a>
<a name="ln146">    /// &lt;summary&gt;</a>
<a name="ln147">    /// DShow Filter: Start/Stop the filter graph -&gt; copy of graphBuilder.</a>
<a name="ln148">    /// &lt;/summary&gt;</a>
<a name="ln149">    protected ControlStreaming.IMediaControl MediaControl;</a>
<a name="ln150"> </a>
<a name="ln151">    /// &lt;summary&gt;</a>
<a name="ln152">    /// DShow Filter: Control preview window -&gt; copy of graphBuilder.</a>
<a name="ln153">    /// &lt;/summary&gt;</a>
<a name="ln154">    protected ControlStreaming.IVideoWindow VideoWindow;</a>
<a name="ln155"> </a>
<a name="ln156">    /// &lt;summary&gt;</a>
<a name="ln157">    /// DShow Filter: selected video compressor.</a>
<a name="ln158">    /// &lt;/summary&gt;</a>
<a name="ln159">    protected CoreStreaming.IBaseFilter VideoCompressorFilter = null;</a>
<a name="ln160"> </a>
<a name="ln161">    /// &lt;summary&gt;</a>
<a name="ln162">    /// Property Backer: Video compression filter.</a>
<a name="ln163">    /// &lt;/summary&gt;</a>
<a name="ln164">    protected Filter VideoCompressor = null;</a>
<a name="ln165"> </a>
<a name="ln166">    /// &lt;summary&gt;</a>
<a name="ln167">    /// Grabber filter interface.</a>
<a name="ln168">    /// &lt;/summary&gt;</a>
<a name="ln169">    private CoreStreaming.IBaseFilter _baseGrabFlt;</a>
<a name="ln170"> </a>
<a name="ln171">    private byte[] _savedArray;</a>
<a name="ln172"> </a>
<a name="ln173">    protected EditStreaming.ISampleGrabber SampGrabber = null;</a>
<a name="ln174">    private EditStreaming.VideoInfoHeader _videoInfoHeader;</a>
<a name="ln175"> </a>
<a name="ln176">    #endregion</a>
<a name="ln177"> </a>
<a name="ln178">    /// &lt;summary&gt;</a>
<a name="ln179">    /// Default constructor of the Capture class.</a>
<a name="ln180">    /// &lt;/summary&gt;</a>
<a name="ln181">    /// &lt;param name=&quot;videoDevice&quot;&gt;The video device to be the source.&lt;/param&gt;</a>
<a name="ln182">    /// &lt;exception cref=&quot;ArgumentException&quot;&gt;If no video device is provided.&lt;/exception&gt;</a>
<a name="ln183">    public CaptureWebcam(Filter videoDevice)</a>
<a name="ln184">    {</a>
<a name="ln185">        VideoDevice = videoDevice ?? throw new ArgumentException(&quot;The videoDevice parameter must be set to a valid Filter.\n&quot;);</a>
<a name="ln186"> </a>
<a name="ln187">        CreateGraph();</a>
<a name="ln188">    }</a>
<a name="ln189"> </a>
<a name="ln190">    #region Public Methods</a>
<a name="ln191"> </a>
<a name="ln192">    /// &lt;summary&gt;</a>
<a name="ln193">    /// Starts the video preview from the video source.</a>
<a name="ln194">    /// &lt;/summary&gt;</a>
<a name="ln195">    public void StartPreview()</a>
<a name="ln196">    {</a>
<a name="ln197">        DerenderGraph();</a>
<a name="ln198"> </a>
<a name="ln199">        WantPreviewRendered = (PreviewWindow != null) &amp;&amp; (VideoDevice != null);</a>
<a name="ln200"> </a>
<a name="ln201">        RenderGraph();</a>
<a name="ln202">        StartPreviewIfNeeded();</a>
<a name="ln203">    }</a>
<a name="ln204"> </a>
<a name="ln205">    /// &lt;summary&gt;</a>
<a name="ln206">    /// Stops the video previewing.</a>
<a name="ln207">    /// &lt;/summary&gt;</a>
<a name="ln208">    public void StopPreview()</a>
<a name="ln209">    {</a>
<a name="ln210">        DerenderGraph();</a>
<a name="ln211"> </a>
<a name="ln212">        WantPreviewRendered = false;</a>
<a name="ln213"> </a>
<a name="ln214">        RenderGraph();</a>
<a name="ln215">        StartPreviewIfNeeded();</a>
<a name="ln216">    }</a>
<a name="ln217"> </a>
<a name="ln218">    /// &lt;summary&gt;</a>
<a name="ln219">    /// Closes and cleans the video previewing.</a>
<a name="ln220">    /// &lt;/summary&gt;</a>
<a name="ln221">    public void Dispose()</a>
<a name="ln222">    {</a>
<a name="ln223">        WantPreviewRendered = false;</a>
<a name="ln224"> </a>
<a name="ln225">        try { DestroyGraph(); }</a>
<a name="ln226">        catch { }</a>
<a name="ln227">    }</a>
<a name="ln228"> </a>
<a name="ln229">    #endregion</a>
<a name="ln230"> </a>
<a name="ln231">    #region Protected Methods</a>
<a name="ln232"> </a>
<a name="ln233">    /// &lt;summary&gt;</a>
<a name="ln234">    ///  Create a new filter graph and add filters (devices, compressors, misc),</a>
<a name="ln235">    ///  but leave the filters unconnected. Call RenderGraph()</a>
<a name="ln236">    ///  to connect the filters.</a>
<a name="ln237">    /// &lt;/summary&gt;</a>
<a name="ln238">    protected void CreateGraph()</a>
<a name="ln239">    {</a>
<a name="ln240">        //Skip if already created</a>
<a name="ln241">        if ((int)ActualGraphState &lt; (int)GraphState.Created)</a>
<a name="ln242">        {</a>
<a name="ln243">            //Make a new filter graph.</a>
<a name="ln244">            GraphBuilder = (ExtendStreaming.IGraphBuilder)Activator.CreateInstance(Type.GetTypeFromCLSID(Uuid.Clsid.FilterGraph, true));</a>
<a name="ln245"> </a>
<a name="ln246">            //Get the Capture Graph Builder.</a>
<a name="ln247">            var clsid = Uuid.Clsid.CaptureGraphBuilder2;</a>
<a name="ln248">            var riid = typeof(ExtendStreaming.ICaptureGraphBuilder2).GUID;</a>
<a name="ln249">            CaptureGraphBuilder = (ExtendStreaming.ICaptureGraphBuilder2)Activator.CreateInstance(Type.GetTypeFromCLSID(clsid, true));</a>
<a name="ln250"> </a>
<a name="ln251">            //Link the CaptureGraphBuilder to the filter graph</a>
<a name="ln252">            var hr = CaptureGraphBuilder.SetFiltergraph(GraphBuilder);</a>
<a name="ln253"> </a>
<a name="ln254">            if (hr &lt; 0)</a>
<a name="ln255">                Marshal.ThrowExceptionForHR(hr);</a>
<a name="ln256"> </a>
<a name="ln257">            var comType = Type.GetTypeFromCLSID(Uuid.Clsid.SampleGrabber);</a>
<a name="ln258"> </a>
<a name="ln259">            if (comType == null)</a>
<a name="ln260">                throw new Exception(&quot;DirectShow SampleGrabber not installed/registered!&quot;);</a>
<a name="ln261"> </a>
<a name="ln262">            var comObj = Activator.CreateInstance(comType);</a>
<a name="ln263">            SampGrabber = (EditStreaming.ISampleGrabber)comObj; comObj = null;</a>
<a name="ln264"> </a>
<a name="ln265">            _baseGrabFlt = (CoreStreaming.IBaseFilter) SampGrabber;</a>
<a name="ln266"> </a>
<a name="ln267">            var media = new CoreStreaming.AmMediaType();</a>
<a name="ln268"> </a>
<a name="ln269">            //Get the video device and add it to the filter graph</a>
<a name="ln270">            if (VideoDevice != null)</a>
<a name="ln271">            {</a>
<a name="ln272">                VideoDeviceFilter = (CoreStreaming.IBaseFilter)Marshal.BindToMoniker(VideoDevice.MonikerString);</a>
<a name="ln273"> </a>
<a name="ln274">                hr = GraphBuilder.AddFilter(VideoDeviceFilter, &quot;Video Capture Device&quot;);</a>
<a name="ln275"> </a>
<a name="ln276">                if (hr &lt; 0)</a>
<a name="ln277">                    Marshal.ThrowExceptionForHR(hr);</a>
<a name="ln278"> </a>
<a name="ln279">                media.majorType = Uuid.MediaType.Video;</a>
<a name="ln280">                media.subType = Uuid.MediaSubType.RGB32;//RGB24;</a>
<a name="ln281">                media.formatType = Uuid.FormatType.VideoInfo;</a>
<a name="ln282">                media.temporalCompression = true; //New</a>
<a name="ln283"> </a>
<a name="ln284">                hr = SampGrabber.SetMediaType(media);</a>
<a name="ln285"> </a>
<a name="ln286">                if (hr &lt; 0)</a>
<a name="ln287">                    Marshal.ThrowExceptionForHR(hr);</a>
<a name="ln288"> </a>
<a name="ln289">                hr = GraphBuilder.AddFilter(_baseGrabFlt, &quot;Grabber&quot;);</a>
<a name="ln290"> </a>
<a name="ln291">                if (hr &lt; 0)</a>
<a name="ln292">                    Marshal.ThrowExceptionForHR(hr);</a>
<a name="ln293">            }</a>
<a name="ln294"> </a>
<a name="ln295">            // Retrieve the stream control interface for the video device</a>
<a name="ln296">            // FindInterface will also add any required filters</a>
<a name="ln297">            // (WDM devices in particular may need additional</a>
<a name="ln298">            // upstream filters to function).</a>
<a name="ln299"> </a>
<a name="ln300">            // Try looking for an interleaved media type</a>
<a name="ln301">            object o;</a>
<a name="ln302">            var cat = Uuid.PinCategory.Capture;</a>
<a name="ln303">            var med = Uuid.MediaType.Interleaved;</a>
<a name="ln304">            var iid = typeof(ExtendStreaming.IAMStreamConfig).GUID;</a>
<a name="ln305">            hr = CaptureGraphBuilder.FindInterface(cat, med, VideoDeviceFilter, iid, out o);</a>
<a name="ln306"> </a>
<a name="ln307">            if (hr != 0)</a>
<a name="ln308">            {</a>
<a name="ln309">                // If not found, try looking for a video media type</a>
<a name="ln310">                med = Uuid.MediaType.Video;</a>
<a name="ln311">                hr = CaptureGraphBuilder.FindInterface(cat, med, VideoDeviceFilter, iid, out o);</a>
<a name="ln312"> </a>
<a name="ln313">                if (hr != 0)</a>
<a name="ln314">                    o = null;</a>
<a name="ln315">            }</a>
<a name="ln316"> </a>
<a name="ln317">            VideoStreamConfig = o as ExtendStreaming.IAMStreamConfig;</a>
<a name="ln318"> </a>
<a name="ln319">            // Retrieve the media control interface (for starting/stopping graph)</a>
<a name="ln320">            MediaControl = (ControlStreaming.IMediaControl)GraphBuilder;</a>
<a name="ln321"> </a>
<a name="ln322">            // Reload any video crossbars</a>
<a name="ln323">            //if (videoSources != null) videoSources.Dispose(); videoSources = null;</a>
<a name="ln324"> </a>
<a name="ln325">            _videoInfoHeader = (EditStreaming.VideoInfoHeader)Marshal.PtrToStructure(media.formatPtr, typeof(EditStreaming.VideoInfoHeader));</a>
<a name="ln326">            Marshal.FreeCoTaskMem(media.formatPtr); media.formatPtr = IntPtr.Zero;</a>
<a name="ln327"> </a>
<a name="ln328">            hr = SampGrabber.SetBufferSamples(false);</a>
<a name="ln329">            if (hr == 0)</a>
<a name="ln330">                hr = SampGrabber.SetOneShot(false);</a>
<a name="ln331">            if (hr == 0)</a>
<a name="ln332">                hr = SampGrabber.SetCallback(null, 0);</a>
<a name="ln333">            if (hr &lt; 0)</a>
<a name="ln334">                Marshal.ThrowExceptionForHR(hr);</a>
<a name="ln335">        }</a>
<a name="ln336"> </a>
<a name="ln337">        //Update the state now that we are done.</a>
<a name="ln338">        ActualGraphState = GraphState.Created;</a>
<a name="ln339">    }</a>
<a name="ln340"> </a>
<a name="ln341">    /// &lt;summary&gt;</a>
<a name="ln342">    ///  Disconnect and remove all filters except the device</a>
<a name="ln343">    ///  and compressor filters. This is the opposite of</a>
<a name="ln344">    ///  renderGraph(). Some properties such as FrameRate</a>
<a name="ln345">    ///  can only be set when the device output pins are not</a>
<a name="ln346">    ///  connected.</a>
<a name="ln347">    /// &lt;/summary&gt;</a>
<a name="ln348">    protected void DerenderGraph()</a>
<a name="ln349">    {</a>
<a name="ln350">        // Stop the graph if it is running (ignore errors)</a>
<a name="ln351">        MediaControl?.Stop();</a>
<a name="ln352"> </a>
<a name="ln353">        // Free the preview window (ignore errors)</a>
<a name="ln354">        if (VideoWindow != null)</a>
<a name="ln355">        {</a>
<a name="ln356">            VideoWindow.put_Visible(CoreStreaming.DsHlp.OAFALSE);</a>
<a name="ln357">            VideoWindow.put_Owner(IntPtr.Zero);</a>
<a name="ln358">            VideoWindow = null;</a>
<a name="ln359">        }</a>
<a name="ln360"> </a>
<a name="ln361">        // Remove the Resize event handler</a>
<a name="ln362">        if (PreviewWindow != null)</a>
<a name="ln363">            PreviewWindow.SizeChanged -= OnPreviewWindowResize;</a>
<a name="ln364"> </a>
<a name="ln365">        if ((int)ActualGraphState &gt;= (int)GraphState.Rendered)</a>
<a name="ln366">        {</a>
<a name="ln367">            // Update the state</a>
<a name="ln368">            ActualGraphState = GraphState.Created;</a>
<a name="ln369">            IsPreviewRendered = false;</a>
<a name="ln370"> </a>
<a name="ln371">            // Disconnect all filters downstream of the video and audio devices. If we have a compressor</a>
<a name="ln372">            // then disconnect it, but don't remove it</a>
<a name="ln373">            if (VideoDeviceFilter != null)</a>
<a name="ln374">                RemoveDownstream(VideoDeviceFilter, VideoCompressor == null);</a>
<a name="ln375">        }</a>
<a name="ln376">    }</a>
<a name="ln377"> </a>
<a name="ln378">    /// &lt;summary&gt;</a>
<a name="ln379">    ///  Removes all filters downstream from a filter from the graph.</a>
<a name="ln380">    ///  This is called only by DerenderGraph() to remove everything</a>
<a name="ln381">    ///  from the graph except the devices and compressors. The parameter</a>
<a name="ln382">    ///  &quot;removeFirstFilter&quot; is used to keep a compressor (that should</a>
<a name="ln383">    ///  be immediately downstream of the device) if one is begin used.</a>
<a name="ln384">    /// &lt;/summary&gt;</a>
<a name="ln385">    protected void RemoveDownstream(CoreStreaming.IBaseFilter filter, bool removeFirstFilter)</a>
<a name="ln386">    {</a>
<a name="ln387">        // Get a pin enumerator off the filter</a>
<a name="ln388">        var hr = filter.EnumPins(out var pinEnum);</a>
<a name="ln389"> </a>
<a name="ln390">        if (pinEnum == null)</a>
<a name="ln391">            return;</a>
<a name="ln392"> </a>
<a name="ln393">        pinEnum.Reset();</a>
<a name="ln394"> </a>
<a name="ln395">        if (hr != 0)</a>
<a name="ln396">            return;</a>
<a name="ln397"> </a>
<a name="ln398">        //Loop through each pin.</a>
<a name="ln399">        var pins = new CoreStreaming.IPin[1];</a>
<a name="ln400"> </a>
<a name="ln401">        do</a>
<a name="ln402">        {</a>
<a name="ln403">            // Get the next pin</a>
<a name="ln404">            hr = pinEnum.Next(1, pins, out _);</a>
<a name="ln405"> </a>
<a name="ln406">            if (hr != 0 || pins[0] == null)</a>
<a name="ln407">                continue;</a>
<a name="ln408"> </a>
<a name="ln409">            //Get the pin it is connected to</a>
<a name="ln410">            pins[0].ConnectedTo(out var pinTo);</a>
<a name="ln411"> </a>
<a name="ln412">            if (pinTo != null)</a>
<a name="ln413">            {</a>
<a name="ln414">                // Is this an input pin?</a>
<a name="ln415">                hr = pinTo.QueryPinInfo(out var info);</a>
<a name="ln416"> </a>
<a name="ln417">                if (hr == 0 &amp;&amp; (info.dir == CoreStreaming.PinDirection.Input))</a>
<a name="ln418">                {</a>
<a name="ln419">                    // Recurse down this branch</a>
<a name="ln420">                    RemoveDownstream(info.filter, true);</a>
<a name="ln421"> </a>
<a name="ln422">                    // Disconnect</a>
<a name="ln423">                    GraphBuilder.Disconnect(pinTo);</a>
<a name="ln424">                    GraphBuilder.Disconnect(pins[0]);</a>
<a name="ln425"> </a>
<a name="ln426">                    // Remove this filter</a>
<a name="ln427">                    // but don't remove the video or audio compressors</a>
<a name="ln428">                    if (info.filter != VideoCompressorFilter)</a>
<a name="ln429">                        GraphBuilder.RemoveFilter(info.filter);</a>
<a name="ln430">                }</a>
<a name="ln431"> </a>
<a name="ln432">                Marshal.ReleaseComObject(info.filter);</a>
<a name="ln433">                Marshal.ReleaseComObject(pinTo);</a>
<a name="ln434">            }</a>
<a name="ln435"> </a>
<a name="ln436">            Marshal.ReleaseComObject(pins[0]);</a>
<a name="ln437">        } while (hr == 0);</a>
<a name="ln438"> </a>
<a name="ln439">        Marshal.ReleaseComObject(pinEnum);</a>
<a name="ln440">    }</a>
<a name="ln441"> </a>
<a name="ln442">    /// &lt;summary&gt;</a>
<a name="ln443">    ///  Connects the filters of a previously created graph</a>
<a name="ln444">    ///  (created by CreateGraph()). Once rendered the graph</a>
<a name="ln445">    ///  is ready to be used. This method may also destroy</a>
<a name="ln446">    ///  streams if we have streams we no longer want.</a>
<a name="ln447">    /// &lt;/summary&gt;</a>
<a name="ln448">    protected void RenderGraph()</a>
<a name="ln449">    {</a>
<a name="ln450">        var didSomething = false;</a>
<a name="ln451"> </a>
<a name="ln452">        // Stop the graph</a>
<a name="ln453">        MediaControl?.Stop();</a>
<a name="ln454"> </a>
<a name="ln455">        // Create the graph if needed (group should already be created)</a>
<a name="ln456">        CreateGraph();</a>
<a name="ln457"> </a>
<a name="ln458">        // Derender the graph if we have a capture or preview stream</a>
<a name="ln459">        // that we no longer want. We can't derender the capture and</a>
<a name="ln460">        // preview streams separately.</a>
<a name="ln461">        // Notice the second case will leave a capture stream intact</a>
<a name="ln462">        // even if we no longer want it. This allows the user that is</a>
<a name="ln463">        // not using the preview to Stop() and Start() without</a>
<a name="ln464">        // rerendering the graph.</a>
<a name="ln465">        if (!WantPreviewRendered &amp;&amp; IsPreviewRendered)</a>
<a name="ln466">            DerenderGraph();</a>
<a name="ln467"> </a>
<a name="ln468">        // Render preview stream (only if necessary)</a>
<a name="ln469">        if (WantPreviewRendered &amp;&amp; !IsPreviewRendered)</a>
<a name="ln470">        {</a>
<a name="ln471">            //Render preview (video -&gt; renderer)</a>
<a name="ln472">            var cat = Uuid.PinCategory.Preview;</a>
<a name="ln473">            var med = Uuid.MediaType.Video;</a>
<a name="ln474"> </a>
<a name="ln475">            var hr = CaptureGraphBuilder.RenderStream(cat, med, VideoDeviceFilter, _baseGrabFlt, null);</a>
<a name="ln476"> </a>
<a name="ln477">            if (hr &lt; 0)</a>
<a name="ln478">                Marshal.ThrowExceptionForHR(hr);</a>
<a name="ln479"> </a>
<a name="ln480">            //Get the IVideoWindow interface</a>
<a name="ln481">            VideoWindow = (ControlStreaming.IVideoWindow) GraphBuilder;</a>
<a name="ln482"> </a>
<a name="ln483">            // Set the video window to be a child of the main window</a>
<a name="ln484">            var source = PresentationSource.FromVisual(PreviewWindow) as HwndSource;</a>
<a name="ln485">            hr = VideoWindow.put_Owner(source.Handle);</a>
<a name="ln486"> </a>
<a name="ln487">            if (hr &lt; 0)</a>
<a name="ln488">                Marshal.ThrowExceptionForHR(hr);</a>
<a name="ln489"> </a>
<a name="ln490">            //Set video window style</a>
<a name="ln491">            hr = VideoWindow.put_WindowStyle(ControlStreaming.WindowStyle.Child | ControlStreaming.WindowStyle.ClipChildren | ControlStreaming.WindowStyle.ClipSiblings);</a>
<a name="ln492"> </a>
<a name="ln493">            if (hr &lt; 0)</a>
<a name="ln494">                Marshal.ThrowExceptionForHR(hr);</a>
<a name="ln495"> </a>
<a name="ln496">            //Position video window in client rect of owner window</a>
<a name="ln497">            PreviewWindow.SizeChanged += OnPreviewWindowResize;</a>
<a name="ln498">            OnPreviewWindowResize(this, null);</a>
<a name="ln499"> </a>
<a name="ln500">            //Make the video window visible, now that it is properly positioned.</a>
<a name="ln501">            hr = VideoWindow.put_Visible(ControlStreaming.OABool.True);</a>
<a name="ln502"> </a>
<a name="ln503">            if (hr &lt; 0)</a>
<a name="ln504">                Marshal.ThrowExceptionForHR(hr);</a>
<a name="ln505"> </a>
<a name="ln506">            IsPreviewRendered = true;</a>
<a name="ln507">            didSomething = true;</a>
<a name="ln508"> </a>
<a name="ln509">            var media = new CoreStreaming.AmMediaType();</a>
<a name="ln510">            hr = SampGrabber.GetConnectedMediaType(media);</a>
<a name="ln511"> </a>
<a name="ln512">            if (hr &lt; 0)</a>
<a name="ln513">                Marshal.ThrowExceptionForHR(hr);</a>
<a name="ln514"> </a>
<a name="ln515">            if (media.formatType != Uuid.FormatType.VideoInfo || media.formatPtr == IntPtr.Zero)</a>
<a name="ln516">                throw new NotSupportedException(&quot;Unknown Grabber Media Format&quot;);</a>
<a name="ln517"> </a>
<a name="ln518">            _videoInfoHeader = (EditStreaming.VideoInfoHeader)Marshal.PtrToStructure(media.formatPtr, typeof(EditStreaming.VideoInfoHeader));</a>
<a name="ln519"> </a>
<a name="ln520">            Marshal.FreeCoTaskMem(media.formatPtr);</a>
<a name="ln521">            media.formatPtr = IntPtr.Zero;</a>
<a name="ln522">        }</a>
<a name="ln523"> </a>
<a name="ln524">        if (didSomething)</a>
<a name="ln525">            ActualGraphState = GraphState.Rendered;</a>
<a name="ln526">    }</a>
<a name="ln527"> </a>
<a name="ln528">    /// &lt;summary&gt;</a>
<a name="ln529">    ///  Setup and start the preview window if the user has</a>
<a name="ln530">    ///  requested it (by setting PreviewWindow).</a>
<a name="ln531">    /// &lt;/summary&gt;</a>
<a name="ln532">    protected void StartPreviewIfNeeded()</a>
<a name="ln533">    {</a>
<a name="ln534">        // Render preview</a>
<a name="ln535">        if (WantPreviewRendered &amp;&amp; IsPreviewRendered)</a>
<a name="ln536">        {</a>
<a name="ln537">            // Run the graph (ignore errors)</a>
<a name="ln538">            // We can run the entire graph because the capture</a>
<a name="ln539">            // stream should not be rendered (and that is enforced</a>
<a name="ln540">            // in the if statement above)</a>
<a name="ln541">            MediaControl.Run();</a>
<a name="ln542">        }</a>
<a name="ln543">    }</a>
<a name="ln544"> </a>
<a name="ln545">    /// &lt;summary&gt; Resize the preview when the PreviewWindow is resized &lt;/summary&gt;</a>
<a name="ln546">    protected void OnPreviewWindowResize(object sender, EventArgs e)</a>
<a name="ln547">    {</a>
<a name="ln548">        // Position video window in client rect of owner window.</a>
<a name="ln549">        VideoWindow?.SetWindowPosition(0, 0,</a>
<a name="ln550">            (int)(PreviewWindow.ActualWidth * Scale),</a>
<a name="ln551">            (int)(PreviewWindow.ActualHeight * Scale)); //-70</a>
<a name="ln552">    }</a>
<a name="ln553"> </a>
<a name="ln554">    /// &lt;summary&gt;</a>
<a name="ln555">    ///  Completely tear down a filter graph and</a>
<a name="ln556">    ///  release all associated resources.</a>
<a name="ln557">    /// &lt;/summary&gt;</a>
<a name="ln558">    protected void DestroyGraph()</a>
<a name="ln559">    {</a>
<a name="ln560">        // Derender the graph</a>
<a name="ln561">        // This will stop the graph and release preview window.</a>
<a name="ln562">        // It also destroys half of the graph which is unnecessary but harmless here (ignore errors).</a>
<a name="ln563">        try { DerenderGraph(); }</a>
<a name="ln564">        catch { }</a>
<a name="ln565"> </a>
<a name="ln566">        // Update the state after derender because it</a>
<a name="ln567">        // depends on correct status. But we also want to</a>
<a name="ln568">        // update the state as early as possible in case of error.</a>
<a name="ln569">        ActualGraphState = GraphState.Null;</a>
<a name="ln570">        IsPreviewRendered = false;</a>
<a name="ln571"> </a>
<a name="ln572">        // Remove filters from the graph</a>
<a name="ln573">        // This should be unnecessary but the Nvidia WDM video driver cannot be used by this application</a>
<a name="ln574">        // again unless we remove it. Ideally, we should simply enumerate all the filters in the graph and remove them (ignore errors).</a>
<a name="ln575">        if (GraphBuilder != null)</a>
<a name="ln576">        {</a>
<a name="ln577">            if (VideoCompressorFilter != null)</a>
<a name="ln578">                GraphBuilder.RemoveFilter(VideoCompressorFilter);</a>
<a name="ln579">            if (VideoDeviceFilter != null)</a>
<a name="ln580">                GraphBuilder.RemoveFilter(VideoDeviceFilter);</a>
<a name="ln581"> </a>
<a name="ln582">            // Cleanup</a>
<a name="ln583">            Marshal.ReleaseComObject(GraphBuilder); GraphBuilder = null;</a>
<a name="ln584">        }</a>
<a name="ln585"> </a>
<a name="ln586">        if (CaptureGraphBuilder != null)</a>
<a name="ln587">            Marshal.ReleaseComObject(CaptureGraphBuilder); CaptureGraphBuilder = null;</a>
<a name="ln588">        if (VideoDeviceFilter != null)</a>
<a name="ln589">            Marshal.ReleaseComObject(VideoDeviceFilter); VideoDeviceFilter = null;</a>
<a name="ln590">        if (VideoCompressorFilter != null)</a>
<a name="ln591">            Marshal.ReleaseComObject(VideoCompressorFilter); VideoCompressorFilter = null;</a>
<a name="ln592"> </a>
<a name="ln593">        // These are copies of graphBuilder</a>
<a name="ln594">        MediaControl = null;</a>
<a name="ln595">        VideoWindow = null;</a>
<a name="ln596"> </a>
<a name="ln597">        // For unmanaged objects we haven't released explicitly</a>
<a name="ln598">        GC.Collect();</a>
<a name="ln599">    }</a>
<a name="ln600"> </a>
<a name="ln601">    #endregion</a>
<a name="ln602"> </a>
<a name="ln603">    #region SampleGrabber</a>
<a name="ln604"> </a>
<a name="ln605">    /// &lt;summary&gt;</a>
<a name="ln606">    /// Capture frame event delegate.</a>
<a name="ln607">    /// &lt;/summary&gt;</a>
<a name="ln608">    /// &lt;param name=&quot;bitmap&quot;&gt;Returns a Bitmap image from the webcam.&lt;/param&gt;</a>
<a name="ln609">    public delegate void CaptureFrame(Bitmap bitmap);</a>
<a name="ln610"> </a>
<a name="ln611">    /// &lt;summary&gt;</a>
<a name="ln612">    /// Capture frame event.</a>
<a name="ln613">    /// &lt;/summary&gt;</a>
<a name="ln614">    public event CaptureFrame CaptureFrameEvent;</a>
<a name="ln615"> </a>
<a name="ln616">    public int SampleCB(double sampleTime, CoreStreaming.IMediaSample pSample)</a>
<a name="ln617">    {</a>
<a name="ln618">        return 0;</a>
<a name="ln619">    }</a>
<a name="ln620"> </a>
<a name="ln621">    public int BufferCB(double sampleTime, IntPtr pBuffer, int bufferLen)</a>
<a name="ln622">    {</a>
<a name="ln623">        if (CaptureFrameEvent == null)</a>
<a name="ln624">            return 1;</a>
<a name="ln625"> </a>
<a name="ln626">        var width = _videoInfoHeader.BmiHeader.Width;</a>
<a name="ln627">        var height = _videoInfoHeader.BmiHeader.Height;</a>
<a name="ln628"> </a>
<a name="ln629">        var stride = width * 3;</a>
<a name="ln630"> </a>
<a name="ln631">        Marshal.Copy(pBuffer, _savedArray, 0, bufferLen);</a>
<a name="ln632"> </a>
<a name="ln633">        var handle = GCHandle.Alloc(_savedArray, GCHandleType.Pinned);</a>
<a name="ln634">        var scan0 = (int)handle.AddrOfPinnedObject();</a>
<a name="ln635">        //scan0 += (height - 1) * stride;</a>
<a name="ln636">        scan0 += height * stride;</a>
<a name="ln637"> </a>
<a name="ln638">        var b = new Bitmap(width, height, -stride, System.Drawing.Imaging.PixelFormat.Format24bppRgb, (IntPtr)scan0);</a>
<a name="ln639">        handle.Free();</a>
<a name="ln640"> </a>
<a name="ln641">        CaptureFrameEvent?.Invoke(b);</a>
<a name="ln642"> </a>
<a name="ln643">        return 0;</a>
<a name="ln644">    }</a>
<a name="ln645"> </a>
<a name="ln646">    /// &lt;summary&gt;</a>
<a name="ln647">    /// Prepares the capture of frames.</a>
<a name="ln648">    /// &lt;/summary&gt;</a>
<a name="ln649">    public void PrepareCapture()</a>
<a name="ln650">    {</a>
<a name="ln651">        var size = _videoInfoHeader.BmiHeader.ImageSize;</a>
<a name="ln652"> </a>
<a name="ln653">        if (_savedArray == null)</a>
<a name="ln654">        {</a>
<a name="ln655">            if (size &lt; 1000 || size &gt; 16000000)</a>
<a name="ln656">                return;</a>
<a name="ln657"> </a>
<a name="ln658">            _savedArray = new byte[size + 64000];</a>
<a name="ln659">        }</a>
<a name="ln660"> </a>
<a name="ln661">        SampGrabber.SetBufferSamples(false);</a>
<a name="ln662">    }</a>
<a name="ln663"> </a>
<a name="ln664">    /// &lt;summary&gt;</a>
<a name="ln665">    /// Gets the current frame from the buffer.</a>
<a name="ln666">    /// &lt;/summary&gt;</a>
<a name="ln667">    /// &lt;returns&gt;The Bitmap of the frame.&lt;/returns&gt;</a>
<a name="ln668">    public Bitmap GetFrame()</a>
<a name="ln669">    {</a>
<a name="ln670">        //TODO: Verify any possible leaks.</a>
<a name="ln671"> </a>
<a name="ln672">        //Asks for the buffer size.</a>
<a name="ln673">        var bufferSize = 0;</a>
<a name="ln674">        SampGrabber.GetCurrentBuffer(ref bufferSize, IntPtr.Zero);</a>
<a name="ln675"> </a>
<a name="ln676">        //Allocs the byte array.</a>
<a name="ln677">        var handleObj = GCHandle.Alloc(_savedArray, GCHandleType.Pinned);</a>
<a name="ln678"> </a>
<a name="ln679">        //Gets the address of the pinned object.</a>
<a name="ln680">        var address = handleObj.AddrOfPinnedObject();</a>
<a name="ln681"> </a>
<a name="ln682">        //Puts the buffer inside the byte array.</a>
<a name="ln683">        SampGrabber.GetCurrentBuffer(ref bufferSize, address);</a>
<a name="ln684"> </a>
<a name="ln685">        //Image size.</a>
<a name="ln686">        var width = _videoInfoHeader.BmiHeader.Width;</a>
<a name="ln687">        var height = _videoInfoHeader.BmiHeader.Height;</a>
<a name="ln688"> </a>
<a name="ln689">        var stride = width * 3;</a>
<a name="ln690">        //address += (height - 1) * stride;</a>
<a name="ln691">        address += height * stride;</a>
<a name="ln692"> </a>
<a name="ln693">        var bitmap = new Bitmap(width, height, -stride, System.Drawing.Imaging.PixelFormat.Format24bppRgb, address);</a>
<a name="ln694">        handleObj.Free();</a>
<a name="ln695"> </a>
<a name="ln696">        return bitmap;</a>
<a name="ln697">    }</a>
<a name="ln698"> </a>
<a name="ln699">    #endregion</a>
<a name="ln700">}</a>
</code></pre>
<div class="balloon" rel="587"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3043/" target="_blank">V3043</a> The code's operational logic does not correspond with its formatting. The statement is indented to the right, but it is always executed. It is possible that curly brackets are missing.</p></div>
<div class="balloon" rel="589"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3043/" target="_blank">V3043</a> The code's operational logic does not correspond with its formatting. The statement is indented to the right, but it is always executed. It is possible that curly brackets are missing.</p></div>
<div class="balloon" rel="591"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3043/" target="_blank">V3043</a> The code's operational logic does not correspond with its formatting. The statement is indented to the right, but it is always executed. It is possible that curly brackets are missing.</p></div>
<div class="balloon" rel="485"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3149/" target="_blank">V3149</a> Dereferencing the result of 'as' operator can lead to NullReferenceException. Consider inspecting 'source'.</p></div>
<div class="balloon" rel="385"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3203/" target="_blank">V3203</a> Method parameter is not used: removeFirstFilter.</p></div>
<div class="balloon" rel="226"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v5606/" target="_blank">V5606</a> An empty exception handler. Silent suppression of exceptions may hide the presence of bugs or vulnerabilities.</p></div>
<div class="balloon" rel="564"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v5606/" target="_blank">V5606</a> An empty exception handler. Silent suppression of exceptions may hide the presence of bugs or vulnerabilities.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>