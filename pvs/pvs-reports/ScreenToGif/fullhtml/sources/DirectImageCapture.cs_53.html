<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>DirectImageCapture.cs</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cs">
<a name="ln1">using System;</a>
<a name="ln2">using System.Drawing.Imaging;</a>
<a name="ln3">using System.Linq;</a>
<a name="ln4">using System.Runtime.InteropServices;</a>
<a name="ln5">using System.Threading.Tasks;</a>
<a name="ln6">using System.Windows;</a>
<a name="ln7">using ScreenToGif.Domain.Enums.Native;</a>
<a name="ln8">using ScreenToGif.Domain.Exceptions;</a>
<a name="ln9">using ScreenToGif.Model;</a>
<a name="ln10">using ScreenToGif.Native.External;</a>
<a name="ln11">using ScreenToGif.Native.Structs;</a>
<a name="ln12">using ScreenToGif.Util;</a>
<a name="ln13">using SharpDX;</a>
<a name="ln14">using SharpDX.Direct3D;</a>
<a name="ln15">using SharpDX.Direct3D11;</a>
<a name="ln16">using SharpDX.DXGI;</a>
<a name="ln17">using SharpDX.Mathematics.Interop;</a>
<a name="ln18">using Device = SharpDX.Direct3D11.Device;</a>
<a name="ln19">using MapFlags = SharpDX.Direct3D11.MapFlags;</a>
<a name="ln20"> </a>
<a name="ln21">namespace ScreenToGif.Capture;</a>
<a name="ln22"> </a>
<a name="ln23">/// &lt;summary&gt;</a>
<a name="ln24">/// Frame capture using the DesktopDuplication API.</a>
<a name="ln25">/// Adapted from:</a>
<a name="ln26">/// https://github.com/ajorkowski/VirtualSpace</a>
<a name="ln27">/// https://github.com/Microsoft/Windows-classic-samples/blob/master/Samples/DXGIDesktopDuplication</a>
<a name="ln28">///</a>
<a name="ln29">/// How to debug:</a>
<a name="ln30">/// https://walbourn.github.io/dxgi-debug-device/</a>
<a name="ln31">/// https://walbourn.github.io/direct3d-sdk-debug-layer-tricks/</a>
<a name="ln32">/// https://devblogs.microsoft.com/cppblog/visual-studio-2015-and-graphics-tools-for-windows-10/</a>
<a name="ln33">/// &lt;/summary&gt;</a>
<a name="ln34">internal class DirectImageCapture : BaseCapture</a>
<a name="ln35">{</a>
<a name="ln36">    #region Variables</a>
<a name="ln37"> </a>
<a name="ln38">    /// &lt;summary&gt;</a>
<a name="ln39">    /// The current device being duplicated.</a>
<a name="ln40">    /// &lt;/summary&gt;</a>
<a name="ln41">    protected internal Device Device;</a>
<a name="ln42"> </a>
<a name="ln43">    /// &lt;summary&gt;</a>
<a name="ln44">    /// The desktop duplication interface.</a>
<a name="ln45">    /// &lt;/summary&gt;</a>
<a name="ln46">    protected internal OutputDuplication DuplicatedOutput;</a>
<a name="ln47"> </a>
<a name="ln48">    /// &lt;summary&gt;</a>
<a name="ln49">    /// The rotation of the screen.</a>
<a name="ln50">    /// &lt;/summary&gt;</a>
<a name="ln51">    protected internal DisplayModeRotation DisplayRotation;</a>
<a name="ln52"> </a>
<a name="ln53">    /// &lt;summary&gt;</a>
<a name="ln54">    /// The texture used to copy the pixel data from the desktop to the destination image.</a>
<a name="ln55">    /// &lt;/summary&gt;</a>
<a name="ln56">    protected internal Texture2D StagingTexture;</a>
<a name="ln57"> </a>
<a name="ln58">    /// &lt;summary&gt;</a>
<a name="ln59">    /// The texture used exclusively to be a backing texture when capturing the cursor shape.</a>
<a name="ln60">    /// This texture will always hold only the desktop texture, without the cursor.</a>
<a name="ln61">    /// &lt;/summary&gt;</a>
<a name="ln62">    protected internal Texture2D BackingTexture;</a>
<a name="ln63"> </a>
<a name="ln64">    /// &lt;summary&gt;</a>
<a name="ln65">    /// The texture used exclusively to be a backing texture when capturing screens which are rotated.</a>
<a name="ln66">    /// &lt;/summary&gt;</a>
<a name="ln67">    protected internal Texture2D TransformTexture;</a>
<a name="ln68"> </a>
<a name="ln69">    /// &lt;summary&gt;</a>
<a name="ln70">    /// Texture used to merge the cursor with the background image (desktop).</a>
<a name="ln71">    /// &lt;/summary&gt;</a>
<a name="ln72">    protected internal Texture2D CursorStagingTexture;</a>
<a name="ln73"> </a>
<a name="ln74">    /// &lt;summary&gt;</a>
<a name="ln75">    /// The buffer that holds all pixel data of the cursor.</a>
<a name="ln76">    /// &lt;/summary&gt;</a>
<a name="ln77">    protected internal byte[] CursorShapeBuffer;</a>
<a name="ln78"> </a>
<a name="ln79">    /// &lt;summary&gt;</a>
<a name="ln80">    /// The details of the cursor.</a>
<a name="ln81">    /// &lt;/summary&gt;</a>
<a name="ln82">    protected internal OutputDuplicatePointerShapeInformation CursorShapeInfo;</a>
<a name="ln83"> </a>
<a name="ln84">    /// &lt;summary&gt;</a>
<a name="ln85">    /// The previous position of the mouse cursor.</a>
<a name="ln86">    /// &lt;/summary&gt;</a>
<a name="ln87">    protected internal OutputDuplicatePointerPosition PreviousPosition;</a>
<a name="ln88"> </a>
<a name="ln89">    /// &lt;summary&gt;</a>
<a name="ln90">    /// The latest time in which a frame or metadata was captured.</a>
<a name="ln91">    /// &lt;/summary&gt;</a>
<a name="ln92">    protected internal long LastProcessTime = 0;</a>
<a name="ln93"> </a>
<a name="ln94">    protected internal int OffsetLeft { get; set; }</a>
<a name="ln95">    protected internal int OffsetTop { get; set; }</a>
<a name="ln96">    protected internal int TrueLeft =&gt; Left + OffsetLeft;</a>
<a name="ln97">    protected internal int TrueRight =&gt; Left + OffsetLeft + Width;</a>
<a name="ln98">    protected internal int TrueTop =&gt; Top + OffsetTop;</a>
<a name="ln99">    protected internal int TrueBottom =&gt; Top + OffsetTop + Height;</a>
<a name="ln100"> </a>
<a name="ln101">    /// &lt;summary&gt;</a>
<a name="ln102">    /// Flag that holds the information whether the previous capture had a major crash.</a>
<a name="ln103">    /// &lt;/summary&gt;</a>
<a name="ln104">    protected internal bool MajorCrashHappened = false;</a>
<a name="ln105"> </a>
<a name="ln106">    #endregion</a>
<a name="ln107"> </a>
<a name="ln108">    public override void Start(int delay, int left, int top, int width, int height, double dpi, ProjectInfo project)</a>
<a name="ln109">    {</a>
<a name="ln110">        base.Start(delay, left, top, width, height, dpi, project);</a>
<a name="ln111"> </a>
<a name="ln112">        //Only set as Started after actually finishing starting.</a>
<a name="ln113">        WasStarted = false;</a>
<a name="ln114"> </a>
<a name="ln115">        Initialize();</a>
<a name="ln116"> </a>
<a name="ln117">        WasStarted = true;</a>
<a name="ln118">    }</a>
<a name="ln119"> </a>
<a name="ln120">    public override void ResetConfiguration()</a>
<a name="ln121">    {</a>
<a name="ln122">        DisposeInternal();</a>
<a name="ln123">        Initialize();</a>
<a name="ln124">    }</a>
<a name="ln125"> </a>
<a name="ln126">    internal void Initialize()</a>
<a name="ln127">    {</a>
<a name="ln128">        MajorCrashHappened = false;</a>
<a name="ln129"> </a>
<a name="ln130">#if DEBUG</a>
<a name="ln131">        Device = new Device(DriverType.Hardware, DeviceCreationFlags.Debug);</a>
<a name="ln132"> </a>
<a name="ln133">        var debug = SharpDX.DXGI.InfoQueue.TryCreate();</a>
<a name="ln134">        debug?.SetBreakOnSeverity(DebugId.All, InformationQueueMessageSeverity.Corruption, true);</a>
<a name="ln135">        debug?.SetBreakOnSeverity(DebugId.All, InformationQueueMessageSeverity.Error, true);</a>
<a name="ln136">        debug?.SetBreakOnSeverity(DebugId.All, InformationQueueMessageSeverity.Warning, true);</a>
<a name="ln137"> </a>
<a name="ln138">        var debug2 = DXGIDebug.TryCreate();</a>
<a name="ln139">        debug2?.ReportLiveObjects(DebugId.Dx, DebugRloFlags.Summary | DebugRloFlags.Detail);</a>
<a name="ln140"> </a>
<a name="ln141">#else</a>
<a name="ln142">            Device = new Device(DriverType.Hardware, DeviceCreationFlags.VideoSupport);</a>
<a name="ln143">#endif</a>
<a name="ln144"> </a>
<a name="ln145">        using (var multiThread = Device.QueryInterface&lt;Multithread&gt;())</a>
<a name="ln146">            multiThread.SetMultithreadProtected(true);</a>
<a name="ln147"> </a>
<a name="ln148">        //Texture used to copy contents from the GPU to be accessible by the CPU.</a>
<a name="ln149">        StagingTexture = new Texture2D(Device, new Texture2DDescription</a>
<a name="ln150">        {</a>
<a name="ln151">            ArraySize = 1,</a>
<a name="ln152">            BindFlags = BindFlags.None,</a>
<a name="ln153">            CpuAccessFlags = CpuAccessFlags.Read,</a>
<a name="ln154">            Format = Format.B8G8R8A8_UNorm,</a>
<a name="ln155">            Width = Width,</a>
<a name="ln156">            Height = Height,</a>
<a name="ln157">            OptionFlags = ResourceOptionFlags.None,</a>
<a name="ln158">            MipLevels = 1,</a>
<a name="ln159">            SampleDescription = new SampleDescription(1, 0),</a>
<a name="ln160">            Usage = ResourceUsage.Staging</a>
<a name="ln161">        });</a>
<a name="ln162"> </a>
<a name="ln163">        //Texture that is used to receive the pixel data from the GPU.</a>
<a name="ln164">        BackingTexture = new Texture2D(Device, new Texture2DDescription</a>
<a name="ln165">        {</a>
<a name="ln166">            ArraySize = 1,</a>
<a name="ln167">            BindFlags = BindFlags.RenderTarget | BindFlags.ShaderResource,</a>
<a name="ln168">            CpuAccessFlags = CpuAccessFlags.None,</a>
<a name="ln169">            Format = Format.B8G8R8A8_UNorm,</a>
<a name="ln170">            Width = Width,</a>
<a name="ln171">            Height = Height,</a>
<a name="ln172">            OptionFlags = ResourceOptionFlags.None,</a>
<a name="ln173">            MipLevels = 1,</a>
<a name="ln174">            SampleDescription = new SampleDescription(1, 0),</a>
<a name="ln175">            Usage = ResourceUsage.Default</a>
<a name="ln176">        });</a>
<a name="ln177"> </a>
<a name="ln178">        using (var factory = new Factory1())</a>
<a name="ln179">        {</a>
<a name="ln180">            //Get the Output1 based on the current capture region position.</a>
<a name="ln181">            using (var output1 = GetOutput(factory))</a>
<a name="ln182">            {</a>
<a name="ln183">                try</a>
<a name="ln184">                {</a>
<a name="ln185">                    //Make sure to run with the integrated graphics adapter if using a Microsoft hybrid system. https://stackoverflow.com/a/54196789/1735672</a>
<a name="ln186">                    DuplicatedOutput = output1.DuplicateOutput(Device);</a>
<a name="ln187">                }</a>
<a name="ln188">                catch (SharpDXException e) when (e.Descriptor == SharpDX.DXGI.ResultCode.NotCurrentlyAvailable)</a>
<a name="ln189">                {</a>
<a name="ln190">                    throw new Exception(&quot;Too many applications using the Desktop Duplication API. Please close one of the applications and try again.&quot;, e);</a>
<a name="ln191">                }</a>
<a name="ln192">                catch (SharpDXException e) when (e.Descriptor == SharpDX.DXGI.ResultCode.Unsupported)</a>
<a name="ln193">                {</a>
<a name="ln194">                    throw new GraphicsConfigurationException(&quot;The Desktop Duplication API is not supported on this computer.&quot;, e);</a>
<a name="ln195">                }</a>
<a name="ln196">                catch (SharpDXException e) when (e.Descriptor == SharpDX.DXGI.ResultCode.InvalidCall)</a>
<a name="ln197">                {</a>
<a name="ln198">                    throw new GraphicsConfigurationException(&quot;The Desktop Duplication API is not supported on this screen.&quot;, e);</a>
<a name="ln199">                }</a>
<a name="ln200">                catch (SharpDXException e) when (e.Descriptor.NativeApiCode == &quot;E_INVALIDARG&quot;)</a>
<a name="ln201">                {</a>
<a name="ln202">                    throw new GraphicsConfigurationException(&quot;Looks like that the Desktop Duplication API is not supported on this screen.&quot;, e);</a>
<a name="ln203">                }</a>
<a name="ln204">            }</a>
<a name="ln205">        }</a>
<a name="ln206">    }</a>
<a name="ln207"> </a>
<a name="ln208">    /// &lt;summary&gt;</a>
<a name="ln209">    /// Get the correct Output1 based on region to be captured.</a>
<a name="ln210">    /// &lt;/summary&gt;</a>
<a name="ln211">    private Output1 GetOutput(Factory1 factory)</a>
<a name="ln212">    {</a>
<a name="ln213">        try</a>
<a name="ln214">        {</a>
<a name="ln215">            //Gets the output with the bigger area being intersected.</a>
<a name="ln216">            var output = factory.Adapters1.SelectMany(s =&gt; s.Outputs).FirstOrDefault(f =&gt; f.Description.DeviceName == DeviceName) ??</a>
<a name="ln217">                         factory.Adapters1.SelectMany(s =&gt; s.Outputs).OrderByDescending(f =&gt;</a>
<a name="ln218">                         {</a>
<a name="ln219">                             var x = Math.Max(Left, f.Description.DesktopBounds.Left);</a>
<a name="ln220">                             var num1 = Math.Min(Left + Width, f.Description.DesktopBounds.Right);</a>
<a name="ln221">                             var y = Math.Max(Top, f.Description.DesktopBounds.Top);</a>
<a name="ln222">                             var num2 = Math.Min(Top + Height, f.Description.DesktopBounds.Bottom);</a>
<a name="ln223"> </a>
<a name="ln224">                             if (num1 &gt;= x &amp;&amp; num2 &gt;= y)</a>
<a name="ln225">                                 return num1 - x + num2 - y;</a>
<a name="ln226"> </a>
<a name="ln227">                             return 0;</a>
<a name="ln228">                         }).FirstOrDefault();</a>
<a name="ln229"> </a>
<a name="ln230">            if (output == null)</a>
<a name="ln231">                throw new Exception($&quot;Could not find a proper output device for the area of L: {Left}, T: {Top}, Width: {Width}, Height: {Height}.&quot;);</a>
<a name="ln232"> </a>
<a name="ln233">            //Position adjustments, so the correct region is captured.</a>
<a name="ln234">            OffsetLeft = output.Description.DesktopBounds.Left;</a>
<a name="ln235">            OffsetTop = output.Description.DesktopBounds.Top;</a>
<a name="ln236">            DisplayRotation = output.Description.Rotation;</a>
<a name="ln237"> </a>
<a name="ln238">            if (DisplayRotation != DisplayModeRotation.Identity)</a>
<a name="ln239">            {</a>
<a name="ln240">                //Texture that is used to receive the pixel data from the GPU.</a>
<a name="ln241">                TransformTexture = new Texture2D(Device, new Texture2DDescription</a>
<a name="ln242">                {</a>
<a name="ln243">                    ArraySize = 1,</a>
<a name="ln244">                    BindFlags = BindFlags.RenderTarget | BindFlags.ShaderResource,</a>
<a name="ln245">                    CpuAccessFlags = CpuAccessFlags.None,</a>
<a name="ln246">                    Format = Format.B8G8R8A8_UNorm,</a>
<a name="ln247">                    Width = Height,</a>
<a name="ln248">                    Height = Width,</a>
<a name="ln249">                    OptionFlags = ResourceOptionFlags.None,</a>
<a name="ln250">                    MipLevels = 1,</a>
<a name="ln251">                    SampleDescription = new SampleDescription(1, 0),</a>
<a name="ln252">                    Usage = ResourceUsage.Default</a>
<a name="ln253">                });</a>
<a name="ln254">            }</a>
<a name="ln255"> </a>
<a name="ln256">            //Create textures in here, after detecting the orientation?</a>
<a name="ln257"> </a>
<a name="ln258">            return output.QueryInterface&lt;Output1&gt;();</a>
<a name="ln259">        }</a>
<a name="ln260">        catch (SharpDXException ex)</a>
<a name="ln261">        {</a>
<a name="ln262">            throw new Exception(&quot;Could not find the specified output device.&quot;, ex);</a>
<a name="ln263">        }</a>
<a name="ln264">    }</a>
<a name="ln265"> </a>
<a name="ln266"> </a>
<a name="ln267">    public override int Capture(FrameInfo frame)</a>
<a name="ln268">    {</a>
<a name="ln269">        var res = new Result(-1);</a>
<a name="ln270"> </a>
<a name="ln271">        try</a>
<a name="ln272">        {</a>
<a name="ln273">            //Try to get the duplicated output frame within given time.</a>
<a name="ln274">            res = DuplicatedOutput.TryAcquireNextFrame(0, out var info, out var resource);</a>
<a name="ln275"> </a>
<a name="ln276">            if (FrameCount == 0 &amp;&amp; (res.Failure || resource == null))</a>
<a name="ln277">            {</a>
<a name="ln278">                //Somehow, it was not possible to retrieve the resource, frame or metadata.</a>
<a name="ln279">                resource?.Dispose();</a>
<a name="ln280">                return FrameCount;</a>
<a name="ln281">            }</a>
<a name="ln282"> </a>
<a name="ln283">            #region Process changes</a>
<a name="ln284"> </a>
<a name="ln285">            //Something on screen was moved or changed.</a>
<a name="ln286">            if (info.TotalMetadataBufferSize &gt; 0)</a>
<a name="ln287">            {</a>
<a name="ln288">                //Copy resource into memory that can be accessed by the CPU.</a>
<a name="ln289">                using (var screenTexture = resource.QueryInterface&lt;Texture2D&gt;())</a>
<a name="ln290">                {</a>
<a name="ln291">                    #region Moved rectangles</a>
<a name="ln292"> </a>
<a name="ln293">                    var movedRectangles = new OutputDuplicateMoveRectangle[info.TotalMetadataBufferSize];</a>
<a name="ln294">                    DuplicatedOutput.GetFrameMoveRects(movedRectangles.Length, movedRectangles, out var movedRegionsLength);</a>
<a name="ln295"> </a>
<a name="ln296">                    for (var movedIndex = 0; movedIndex &lt; movedRegionsLength / Marshal.SizeOf(typeof(OutputDuplicateMoveRectangle)); movedIndex++)</a>
<a name="ln297">                    {</a>
<a name="ln298">                        //Crop the destination rectangle to the screen area rectangle.</a>
<a name="ln299">                        var left = Math.Max(movedRectangles[movedIndex].DestinationRect.Left, Left - OffsetLeft);</a>
<a name="ln300">                        var right = Math.Min(movedRectangles[movedIndex].DestinationRect.Right, Left + Width - OffsetLeft);</a>
<a name="ln301">                        var top = Math.Max(movedRectangles[movedIndex].DestinationRect.Top, Top - OffsetTop);</a>
<a name="ln302">                        var bottom = Math.Min(movedRectangles[movedIndex].DestinationRect.Bottom, Top + Height - OffsetTop);</a>
<a name="ln303"> </a>
<a name="ln304">                        //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln305">                        if (right &gt; left &amp;&amp; bottom &gt; top)</a>
<a name="ln306">                        {</a>
<a name="ln307">                            //Limit the source rectangle to the available size within the destination rectangle.</a>
<a name="ln308">                            var sourceWidth = movedRectangles[movedIndex].SourcePoint.X + (right - left);</a>
<a name="ln309">                            var sourceHeight = movedRectangles[movedIndex].SourcePoint.Y + (bottom - top);</a>
<a name="ln310"> </a>
<a name="ln311">                            Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0,</a>
<a name="ln312">                                new ResourceRegion(movedRectangles[movedIndex].SourcePoint.X, movedRectangles[movedIndex].SourcePoint.Y, 0, sourceWidth, sourceHeight, 1),</a>
<a name="ln313">                                StagingTexture, 0, left - (Left - OffsetLeft), top - (Top - OffsetTop));</a>
<a name="ln314">                        }</a>
<a name="ln315">                    }</a>
<a name="ln316"> </a>
<a name="ln317">                    #endregion</a>
<a name="ln318"> </a>
<a name="ln319">                    #region Dirty rectangles</a>
<a name="ln320"> </a>
<a name="ln321">                    var dirtyRectangles = new RawRectangle[info.TotalMetadataBufferSize];</a>
<a name="ln322">                    DuplicatedOutput.GetFrameDirtyRects(dirtyRectangles.Length, dirtyRectangles, out var dirtyRegionsLength);</a>
<a name="ln323"> </a>
<a name="ln324">                    for (var dirtyIndex = 0; dirtyIndex &lt; dirtyRegionsLength / Marshal.SizeOf(typeof(RawRectangle)); dirtyIndex++)</a>
<a name="ln325">                    {</a>
<a name="ln326">                        //Crop screen positions and size to frame sizes.</a>
<a name="ln327">                        var left = Math.Max(dirtyRectangles[dirtyIndex].Left, Left - OffsetLeft);</a>
<a name="ln328">                        var right = Math.Min(dirtyRectangles[dirtyIndex].Right, Left + Width - OffsetLeft);</a>
<a name="ln329">                        var top = Math.Max(dirtyRectangles[dirtyIndex].Top, Top - OffsetTop);</a>
<a name="ln330">                        var bottom = Math.Min(dirtyRectangles[dirtyIndex].Bottom, Top + Height - OffsetTop);</a>
<a name="ln331"> </a>
<a name="ln332">                        //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln333">                        if (right &gt; left &amp;&amp; bottom &gt; top)</a>
<a name="ln334">                            Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0, new ResourceRegion(left, top, 0, right, bottom, 1), StagingTexture, 0, left - (Left - OffsetLeft), top - (Top - OffsetTop));</a>
<a name="ln335">                    }</a>
<a name="ln336"> </a>
<a name="ln337">                    #endregion</a>
<a name="ln338">                }</a>
<a name="ln339">            }</a>
<a name="ln340"> </a>
<a name="ln341">            #endregion</a>
<a name="ln342"> </a>
<a name="ln343">            #region Gets the image data</a>
<a name="ln344"> </a>
<a name="ln345">            //Gets the staging texture as a stream.</a>
<a name="ln346">            var data = Device.ImmediateContext.MapSubresource(StagingTexture, 0, MapMode.Read, MapFlags.None);</a>
<a name="ln347"> </a>
<a name="ln348">            if (data.IsEmpty)</a>
<a name="ln349">            {</a>
<a name="ln350">                Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln351">                resource?.Dispose();</a>
<a name="ln352">                return FrameCount;</a>
<a name="ln353">            }</a>
<a name="ln354"> </a>
<a name="ln355">            var bitmap = new System.Drawing.Bitmap(Width, Height, PixelFormat.Format32bppArgb);</a>
<a name="ln356">            var boundsRect = new System.Drawing.Rectangle(0, 0, Width, Height);</a>
<a name="ln357"> </a>
<a name="ln358">            //Copy pixels from screen capture Texture to the GDI bitmap.</a>
<a name="ln359">            var mapDest = bitmap.LockBits(boundsRect, ImageLockMode.WriteOnly, bitmap.PixelFormat);</a>
<a name="ln360">            var sourcePtr = data.DataPointer;</a>
<a name="ln361">            var destPtr = mapDest.Scan0;</a>
<a name="ln362"> </a>
<a name="ln363">            for (var y = 0; y &lt; Height; y++)</a>
<a name="ln364">            {</a>
<a name="ln365">                //Copy a single line.</a>
<a name="ln366">                Utilities.CopyMemory(destPtr, sourcePtr, Width * 4);</a>
<a name="ln367"> </a>
<a name="ln368">                //Advance pointers.</a>
<a name="ln369">                sourcePtr = IntPtr.Add(sourcePtr, data.RowPitch);</a>
<a name="ln370">                destPtr = IntPtr.Add(destPtr, mapDest.Stride);</a>
<a name="ln371">            }</a>
<a name="ln372"> </a>
<a name="ln373">            //Release source and dest locks.</a>
<a name="ln374">            bitmap.UnlockBits(mapDest);</a>
<a name="ln375"> </a>
<a name="ln376">            //Set frame details.</a>
<a name="ln377">            FrameCount++;</a>
<a name="ln378">            frame.Path = $&quot;{Project.FullPath}{FrameCount}.png&quot;;</a>
<a name="ln379">            frame.Delay = FrameRate.GetMilliseconds();</a>
<a name="ln380">            frame.Image = bitmap;</a>
<a name="ln381"> </a>
<a name="ln382">            if (IsAcceptingFrames)</a>
<a name="ln383">                BlockingCollection.Add(frame);</a>
<a name="ln384"> </a>
<a name="ln385">            #endregion</a>
<a name="ln386"> </a>
<a name="ln387">            Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln388"> </a>
<a name="ln389">            resource?.Dispose();</a>
<a name="ln390">            return FrameCount;</a>
<a name="ln391">        }</a>
<a name="ln392">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.WaitTimeout.Result.Code)</a>
<a name="ln393">        {</a>
<a name="ln394">            return FrameCount;</a>
<a name="ln395">        }</a>
<a name="ln396">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceRemoved.Result.Code || se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceReset.Result.Code)</a>
<a name="ln397">        {</a>
<a name="ln398">            //When the device gets lost or reset, the resources should be instantiated again.</a>
<a name="ln399">            DisposeInternal();</a>
<a name="ln400">            Initialize();</a>
<a name="ln401"> </a>
<a name="ln402">            return FrameCount;</a>
<a name="ln403">        }</a>
<a name="ln404">        catch (Exception ex)</a>
<a name="ln405">        {</a>
<a name="ln406">            LogWriter.Log(ex, &quot;It was not possible to finish capturing the frame with DirectX.&quot;);</a>
<a name="ln407"> </a>
<a name="ln408">            MajorCrashHappened = true;</a>
<a name="ln409"> </a>
<a name="ln410">            if (IsAcceptingFrames)</a>
<a name="ln411">                Application.Current.Dispatcher.Invoke(() =&gt; OnError.Invoke(ex));</a>
<a name="ln412"> </a>
<a name="ln413">            return FrameCount;</a>
<a name="ln414">        }</a>
<a name="ln415">        finally</a>
<a name="ln416">        {</a>
<a name="ln417">            try</a>
<a name="ln418">            {</a>
<a name="ln419">                //Only release the frame if there was a success in capturing it.</a>
<a name="ln420">                if (res.Success)</a>
<a name="ln421">                    DuplicatedOutput.ReleaseFrame();</a>
<a name="ln422">            }</a>
<a name="ln423">            catch (Exception e)</a>
<a name="ln424">            {</a>
<a name="ln425">                LogWriter.Log(e, &quot;It was not possible to release the frame.&quot;);</a>
<a name="ln426">            }</a>
<a name="ln427">        }</a>
<a name="ln428">    }</a>
<a name="ln429"> </a>
<a name="ln430">    public override async Task&lt;int&gt; CaptureAsync(FrameInfo frame)</a>
<a name="ln431">    {</a>
<a name="ln432">        return await Task.Factory.StartNew(() =&gt; Capture(frame));</a>
<a name="ln433">    }</a>
<a name="ln434"> </a>
<a name="ln435">    public override int CaptureWithCursor(FrameInfo frame)</a>
<a name="ln436">    {</a>
<a name="ln437">        var res = new Result(-1);</a>
<a name="ln438"> </a>
<a name="ln439">        try</a>
<a name="ln440">        {</a>
<a name="ln441">            //Try to get the duplicated output frame within given time.</a>
<a name="ln442">            res = DuplicatedOutput.TryAcquireNextFrame(0, out var info, out var resource);</a>
<a name="ln443"> </a>
<a name="ln444">            //Checks how to proceed with the capture. It could have failed, or the screen, cursor or both could have been captured.</a>
<a name="ln445">            if (FrameCount == 0 &amp;&amp; info.LastMouseUpdateTime == 0 &amp;&amp; (res.Failure || resource == null))</a>
<a name="ln446">            {</a>
<a name="ln447">                //Somehow, it was not possible to retrieve the resource, frame or metadata.</a>
<a name="ln448">                resource?.Dispose();</a>
<a name="ln449">                return FrameCount;</a>
<a name="ln450">            }</a>
<a name="ln451">            else if (FrameCount == 0 &amp;&amp; info.TotalMetadataBufferSize == 0 &amp;&amp; info.LastMouseUpdateTime &gt; 0)</a>
<a name="ln452">            {</a>
<a name="ln453">                //Sometimes, the first frame has cursor info, but no screen changes.</a>
<a name="ln454">                GetCursor(null, info, frame);</a>
<a name="ln455">                resource?.Dispose();</a>
<a name="ln456">                return FrameCount;</a>
<a name="ln457">            }</a>
<a name="ln458"> </a>
<a name="ln459">            #region Process changes</a>
<a name="ln460"> </a>
<a name="ln461">            //Something on screen was moved or changed.</a>
<a name="ln462">            if (info.TotalMetadataBufferSize &gt; 0)</a>
<a name="ln463">            {</a>
<a name="ln464">                //Copies the screen data into memory that can be accessed by the CPU.</a>
<a name="ln465">                using (var screenTexture = resource.QueryInterface&lt;Texture2D&gt;())</a>
<a name="ln466">                {</a>
<a name="ln467">                    #region Moved rectangles</a>
<a name="ln468"> </a>
<a name="ln469">                    var movedRectangles = new OutputDuplicateMoveRectangle[info.TotalMetadataBufferSize];</a>
<a name="ln470">                    DuplicatedOutput.GetFrameMoveRects(movedRectangles.Length, movedRectangles, out var movedRegionsLength);</a>
<a name="ln471"> </a>
<a name="ln472">                    for (var movedIndex = 0; movedIndex &lt; movedRegionsLength / Marshal.SizeOf(typeof(OutputDuplicateMoveRectangle)); movedIndex++)</a>
<a name="ln473">                    {</a>
<a name="ln474">                        //Crop the destination rectangle to the screen area rectangle.</a>
<a name="ln475">                        var left = Math.Max(movedRectangles[movedIndex].DestinationRect.Left, Left - OffsetLeft);</a>
<a name="ln476">                        var right = Math.Min(movedRectangles[movedIndex].DestinationRect.Right, Left + Width - OffsetLeft);</a>
<a name="ln477">                        var top = Math.Max(movedRectangles[movedIndex].DestinationRect.Top, Top - OffsetTop);</a>
<a name="ln478">                        var bottom = Math.Min(movedRectangles[movedIndex].DestinationRect.Bottom, Top + Height - OffsetTop);</a>
<a name="ln479"> </a>
<a name="ln480">                        //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln481">                        if (right &gt; left &amp;&amp; bottom &gt; top)</a>
<a name="ln482">                        {</a>
<a name="ln483">                            //Limit the source rectangle to the available size within the destination rectangle.</a>
<a name="ln484">                            var sourceWidth = movedRectangles[movedIndex].SourcePoint.X + (right - left);</a>
<a name="ln485">                            var sourceHeight = movedRectangles[movedIndex].SourcePoint.Y + (bottom - top);</a>
<a name="ln486"> </a>
<a name="ln487">                            Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0,</a>
<a name="ln488">                                new ResourceRegion(movedRectangles[movedIndex].SourcePoint.X, movedRectangles[movedIndex].SourcePoint.Y, 0, sourceWidth, sourceHeight, 1),</a>
<a name="ln489">                                BackingTexture, 0, left - (Left - OffsetLeft), top - (Top - OffsetTop));</a>
<a name="ln490">                        }</a>
<a name="ln491">                    }</a>
<a name="ln492"> </a>
<a name="ln493">                    #endregion</a>
<a name="ln494"> </a>
<a name="ln495">                    #region Dirty rectangles</a>
<a name="ln496"> </a>
<a name="ln497">                    var dirtyRectangles = new RawRectangle[info.TotalMetadataBufferSize];</a>
<a name="ln498">                    DuplicatedOutput.GetFrameDirtyRects(dirtyRectangles.Length, dirtyRectangles, out var dirtyRegionsLength);</a>
<a name="ln499"> </a>
<a name="ln500">                    for (var dirtyIndex = 0; dirtyIndex &lt; dirtyRegionsLength / Marshal.SizeOf(typeof(RawRectangle)); dirtyIndex++)</a>
<a name="ln501">                    {</a>
<a name="ln502">                        //Crop screen positions and size to frame sizes.</a>
<a name="ln503">                        var left = Math.Max(dirtyRectangles[dirtyIndex].Left, Left - OffsetLeft);</a>
<a name="ln504">                        var right = Math.Min(dirtyRectangles[dirtyIndex].Right, Left + Width - OffsetLeft);</a>
<a name="ln505">                        var top = Math.Max(dirtyRectangles[dirtyIndex].Top, Top - OffsetTop);</a>
<a name="ln506">                        var bottom = Math.Min(dirtyRectangles[dirtyIndex].Bottom, Top + Height - OffsetTop);</a>
<a name="ln507"> </a>
<a name="ln508">                        //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln509">                        if (right &gt; left &amp;&amp; bottom &gt; top)</a>
<a name="ln510">                            Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0, new ResourceRegion(left, top, 0, right, bottom, 1), BackingTexture, 0, left - (Left - OffsetLeft), top - (Top - OffsetTop));</a>
<a name="ln511">                    }</a>
<a name="ln512"> </a>
<a name="ln513">                    #endregion</a>
<a name="ln514">                }</a>
<a name="ln515">            }</a>
<a name="ln516"> </a>
<a name="ln517">            if (info.TotalMetadataBufferSize &gt; 0 || info.LastMouseUpdateTime &gt; 0)</a>
<a name="ln518">            {</a>
<a name="ln519">                //Copy the captured desktop texture into a staging texture, in order to show the mouse cursor and not make the captured texture dirty with it.</a>
<a name="ln520">                Device.ImmediateContext.CopyResource(BackingTexture, StagingTexture);</a>
<a name="ln521"> </a>
<a name="ln522">                //Gets the cursor image and merges with the staging texture.</a>
<a name="ln523">                GetCursor(StagingTexture, info, frame);</a>
<a name="ln524">            }</a>
<a name="ln525"> </a>
<a name="ln526">            //Saves the most recent capture time.</a>
<a name="ln527">            LastProcessTime = Math.Max(info.LastPresentTime, info.LastMouseUpdateTime);</a>
<a name="ln528"> </a>
<a name="ln529">            #endregion</a>
<a name="ln530"> </a>
<a name="ln531">            #region Gets the image data</a>
<a name="ln532"> </a>
<a name="ln533">            //Get the desktop capture texture.</a>
<a name="ln534">            var data = Device.ImmediateContext.MapSubresource(StagingTexture, 0, MapMode.Read, MapFlags.None);</a>
<a name="ln535"> </a>
<a name="ln536">            if (data.IsEmpty)</a>
<a name="ln537">            {</a>
<a name="ln538">                Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln539">                resource?.Dispose();</a>
<a name="ln540">                return FrameCount;</a>
<a name="ln541">            }</a>
<a name="ln542"> </a>
<a name="ln543">            var bitmap = new System.Drawing.Bitmap(Width, Height, PixelFormat.Format32bppArgb);</a>
<a name="ln544">            var boundsRect = new System.Drawing.Rectangle(0, 0, Width, Height);</a>
<a name="ln545"> </a>
<a name="ln546">            //Copy pixels from screen capture Texture to the GDI bitmap.</a>
<a name="ln547">            var mapDest = bitmap.LockBits(boundsRect, ImageLockMode.WriteOnly, bitmap.PixelFormat);</a>
<a name="ln548">            var sourcePtr = data.DataPointer;</a>
<a name="ln549">            var destPtr = mapDest.Scan0;</a>
<a name="ln550"> </a>
<a name="ln551">            for (var y = 0; y &lt; Height; y++)</a>
<a name="ln552">            {</a>
<a name="ln553">                //Copy a single line.</a>
<a name="ln554">                Utilities.CopyMemory(destPtr, sourcePtr, Width * 4);</a>
<a name="ln555"> </a>
<a name="ln556">                //Advance pointers.</a>
<a name="ln557">                sourcePtr = IntPtr.Add(sourcePtr, data.RowPitch);</a>
<a name="ln558">                destPtr = IntPtr.Add(destPtr, mapDest.Stride);</a>
<a name="ln559">            }</a>
<a name="ln560"> </a>
<a name="ln561">            //Releases the source and dest locks.</a>
<a name="ln562">            bitmap.UnlockBits(mapDest);</a>
<a name="ln563"> </a>
<a name="ln564">            //Set frame details.</a>
<a name="ln565">            FrameCount++;</a>
<a name="ln566">            frame.Path = $&quot;{Project.FullPath}{FrameCount}.png&quot;;</a>
<a name="ln567">            frame.Delay = FrameRate.GetMilliseconds();</a>
<a name="ln568">            frame.Image = bitmap;</a>
<a name="ln569"> </a>
<a name="ln570">            if (IsAcceptingFrames)</a>
<a name="ln571">                BlockingCollection.Add(frame);</a>
<a name="ln572"> </a>
<a name="ln573">            #endregion</a>
<a name="ln574"> </a>
<a name="ln575">            Device.ImmediateContext?.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln576"> </a>
<a name="ln577">            resource?.Dispose();</a>
<a name="ln578">            return FrameCount;</a>
<a name="ln579">        }</a>
<a name="ln580">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.WaitTimeout.Result.Code)</a>
<a name="ln581">        {</a>
<a name="ln582">            return FrameCount;</a>
<a name="ln583">        }</a>
<a name="ln584">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceRemoved.Result.Code || se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceReset.Result.Code)</a>
<a name="ln585">        {</a>
<a name="ln586">            //When the device gets lost or reset, the resources should be instantiated again.</a>
<a name="ln587">            DisposeInternal();</a>
<a name="ln588">            Initialize();</a>
<a name="ln589"> </a>
<a name="ln590">            return FrameCount;</a>
<a name="ln591">        }</a>
<a name="ln592">        catch (Exception ex)</a>
<a name="ln593">        {</a>
<a name="ln594">            LogWriter.Log(ex, &quot;It was not possible to finish capturing the frame with DirectX.&quot;);</a>
<a name="ln595"> </a>
<a name="ln596">            MajorCrashHappened = true;</a>
<a name="ln597"> </a>
<a name="ln598">            if (IsAcceptingFrames)</a>
<a name="ln599">                Application.Current.Dispatcher.Invoke(() =&gt; OnError.Invoke(ex));</a>
<a name="ln600"> </a>
<a name="ln601">            return FrameCount;</a>
<a name="ln602">        }</a>
<a name="ln603">        finally</a>
<a name="ln604">        {</a>
<a name="ln605">            try</a>
<a name="ln606">            {</a>
<a name="ln607">                //Only release the frame if there was a success in capturing it.</a>
<a name="ln608">                if (res.Success)</a>
<a name="ln609">                    DuplicatedOutput.ReleaseFrame();</a>
<a name="ln610">            }</a>
<a name="ln611">            catch (Exception e)</a>
<a name="ln612">            {</a>
<a name="ln613">                LogWriter.Log(e, &quot;It was not possible to release the frame.&quot;);</a>
<a name="ln614">            }</a>
<a name="ln615">        }</a>
<a name="ln616">    }</a>
<a name="ln617"> </a>
<a name="ln618">    public override async Task&lt;int&gt; CaptureWithCursorAsync(FrameInfo frame)</a>
<a name="ln619">    {</a>
<a name="ln620">        return await Task.Factory.StartNew(() =&gt; CaptureWithCursor(frame));</a>
<a name="ln621">    }</a>
<a name="ln622"> </a>
<a name="ln623">    public override int ManualCapture(FrameInfo frame, bool showCursor = false)</a>
<a name="ln624">    {</a>
<a name="ln625">        var res = new Result(-1);</a>
<a name="ln626"> </a>
<a name="ln627">        try</a>
<a name="ln628">        {</a>
<a name="ln629">            //Try to get the duplicated output frame within given time.</a>
<a name="ln630">            res = DuplicatedOutput.TryAcquireNextFrame(1000, out var info, out var resource);</a>
<a name="ln631"> </a>
<a name="ln632">            //Checks how to proceed with the capture. It could have failed, or the screen, cursor or both could have been captured.</a>
<a name="ln633">            if (res.Failure || resource == null || (!showCursor &amp;&amp; info.AccumulatedFrames == 0) || (showCursor &amp;&amp; info.AccumulatedFrames == 0 &amp;&amp; info.LastMouseUpdateTime &lt;= LastProcessTime))</a>
<a name="ln634">            {</a>
<a name="ln635">                //Somehow, it was not possible to retrieve the resource, frame or metadata.</a>
<a name="ln636">                //frame.WasDropped = true;</a>
<a name="ln637">                //BlockingCollection.Add(frame);</a>
<a name="ln638"> </a>
<a name="ln639">                resource?.Dispose();</a>
<a name="ln640">                return FrameCount;</a>
<a name="ln641">            }</a>
<a name="ln642">            else if (showCursor &amp;&amp; info.AccumulatedFrames == 0 &amp;&amp; info.LastMouseUpdateTime &gt; LastProcessTime)</a>
<a name="ln643">            {</a>
<a name="ln644">                //Gets the cursor shape if the screen hasn't changed in between, so the cursor will be available for the next frame.</a>
<a name="ln645">                GetCursor(null, info, frame);</a>
<a name="ln646"> </a>
<a name="ln647">                resource.Dispose();</a>
<a name="ln648">                return FrameCount;</a>
<a name="ln649">            }</a>
<a name="ln650"> </a>
<a name="ln651">            //Saves the most recent capture time.</a>
<a name="ln652">            LastProcessTime = Math.Max(info.LastPresentTime, info.LastMouseUpdateTime);</a>
<a name="ln653"> </a>
<a name="ln654">            //Copy resource into memory that can be accessed by the CPU.</a>
<a name="ln655">            using (var screenTexture = resource.QueryInterface&lt;Texture2D&gt;())</a>
<a name="ln656">            {</a>
<a name="ln657">                if (showCursor)</a>
<a name="ln658">                {</a>
<a name="ln659">                    //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln660">                    Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0, new ResourceRegion(TrueLeft, TrueTop, 0, TrueRight, TrueBottom, 1), BackingTexture, 0);</a>
<a name="ln661"> </a>
<a name="ln662">                    //Copy the captured desktop texture into a staging texture, in order to show the mouse cursor and not make the captured texture dirty with it.</a>
<a name="ln663">                    Device.ImmediateContext.CopyResource(BackingTexture, StagingTexture);</a>
<a name="ln664"> </a>
<a name="ln665">                    //Gets the cursor image and merges with the staging texture.</a>
<a name="ln666">                    GetCursor(StagingTexture, info, frame);</a>
<a name="ln667">                }</a>
<a name="ln668">                else</a>
<a name="ln669">                {</a>
<a name="ln670">                    //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln671">                    Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0, new ResourceRegion(TrueLeft, TrueTop, 0, TrueRight, TrueBottom, 1), StagingTexture, 0);</a>
<a name="ln672">                }</a>
<a name="ln673">            }</a>
<a name="ln674"> </a>
<a name="ln675">            //Get the desktop capture texture.</a>
<a name="ln676">            var data = Device.ImmediateContext.MapSubresource(StagingTexture, 0, MapMode.Read, MapFlags.None);</a>
<a name="ln677"> </a>
<a name="ln678">            if (data.IsEmpty)</a>
<a name="ln679">            {</a>
<a name="ln680">                //frame.WasDropped = true;</a>
<a name="ln681">                //BlockingCollection.Add(frame);</a>
<a name="ln682"> </a>
<a name="ln683">                Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln684">                resource.Dispose();</a>
<a name="ln685">                return FrameCount;</a>
<a name="ln686">            }</a>
<a name="ln687"> </a>
<a name="ln688">            #region Get image data</a>
<a name="ln689"> </a>
<a name="ln690">            var bitmap = new System.Drawing.Bitmap(Width, Height, PixelFormat.Format32bppArgb);</a>
<a name="ln691">            var boundsRect = new System.Drawing.Rectangle(0, 0, Width, Height);</a>
<a name="ln692"> </a>
<a name="ln693">            //Copy pixels from screen capture Texture to the GDI bitmap.</a>
<a name="ln694">            var mapDest = bitmap.LockBits(boundsRect, ImageLockMode.WriteOnly, bitmap.PixelFormat);</a>
<a name="ln695">            var sourcePtr = data.DataPointer;</a>
<a name="ln696">            var destPtr = mapDest.Scan0;</a>
<a name="ln697"> </a>
<a name="ln698">            for (var y = 0; y &lt; Height; y++)</a>
<a name="ln699">            {</a>
<a name="ln700">                //Copy a single line.</a>
<a name="ln701">                Utilities.CopyMemory(destPtr, sourcePtr, Width * 4);</a>
<a name="ln702"> </a>
<a name="ln703">                //Advance pointers.</a>
<a name="ln704">                sourcePtr = IntPtr.Add(sourcePtr, data.RowPitch);</a>
<a name="ln705">                destPtr = IntPtr.Add(destPtr, mapDest.Stride);</a>
<a name="ln706">            }</a>
<a name="ln707"> </a>
<a name="ln708">            //Release source and dest locks.</a>
<a name="ln709">            bitmap.UnlockBits(mapDest);</a>
<a name="ln710"> </a>
<a name="ln711">            //Set frame details.</a>
<a name="ln712">            FrameCount++;</a>
<a name="ln713">            frame.Path = $&quot;{Project.FullPath}{FrameCount}.png&quot;;</a>
<a name="ln714">            frame.Delay = FrameRate.GetMilliseconds();</a>
<a name="ln715">            frame.Image = bitmap;</a>
<a name="ln716">            BlockingCollection.Add(frame);</a>
<a name="ln717"> </a>
<a name="ln718">            #endregion</a>
<a name="ln719"> </a>
<a name="ln720">            Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln721"> </a>
<a name="ln722">            resource.Dispose();</a>
<a name="ln723">            return FrameCount;</a>
<a name="ln724">        }</a>
<a name="ln725">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.WaitTimeout.Result.Code)</a>
<a name="ln726">        {</a>
<a name="ln727">            return FrameCount;</a>
<a name="ln728">        }</a>
<a name="ln729">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceRemoved.Result.Code || se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceReset.Result.Code)</a>
<a name="ln730">        {</a>
<a name="ln731">            //When the device gets lost or reset, the resources should be instantiated again.</a>
<a name="ln732">            DisposeInternal();</a>
<a name="ln733">            Initialize();</a>
<a name="ln734"> </a>
<a name="ln735">            return FrameCount;</a>
<a name="ln736">        }</a>
<a name="ln737">        catch (Exception ex)</a>
<a name="ln738">        {</a>
<a name="ln739">            LogWriter.Log(ex, &quot;It was not possible to finish capturing the frame with DirectX.&quot;);</a>
<a name="ln740"> </a>
<a name="ln741">            MajorCrashHappened = true;</a>
<a name="ln742">            OnError.Invoke(ex);</a>
<a name="ln743">            return FrameCount;</a>
<a name="ln744">        }</a>
<a name="ln745">        finally</a>
<a name="ln746">        {</a>
<a name="ln747">            try</a>
<a name="ln748">            {</a>
<a name="ln749">                //Only release the frame if there was a success in capturing it.</a>
<a name="ln750">                if (res.Success)</a>
<a name="ln751">                    DuplicatedOutput.ReleaseFrame();</a>
<a name="ln752">            }</a>
<a name="ln753">            catch (Exception e)</a>
<a name="ln754">            {</a>
<a name="ln755">                LogWriter.Log(e, &quot;It was not possible to release the frame.&quot;);</a>
<a name="ln756">            }</a>
<a name="ln757">        }</a>
<a name="ln758">    }</a>
<a name="ln759"> </a>
<a name="ln760">    public override async Task&lt;int&gt; ManualCaptureAsync(FrameInfo frame, bool showCursor = false)</a>
<a name="ln761">    {</a>
<a name="ln762">        return await Task.Factory.StartNew(() =&gt; ManualCapture(frame, showCursor));</a>
<a name="ln763">    }</a>
<a name="ln764"> </a>
<a name="ln765"> </a>
<a name="ln766">    protected internal bool GetCursor(Texture2D screenTexture, OutputDuplicateFrameInformation info, FrameInfo frame)</a>
<a name="ln767">    {</a>
<a name="ln768">        //Prepare buffer array to hold the cursor shape.</a>
<a name="ln769">        if (CursorShapeBuffer == null || info.PointerShapeBufferSize &gt; CursorShapeBuffer.Length)</a>
<a name="ln770">            CursorShapeBuffer = new byte[info.PointerShapeBufferSize];</a>
<a name="ln771"> </a>
<a name="ln772">        //If there's a cursor shape available to be captured.</a>
<a name="ln773">        if (info.PointerShapeBufferSize &gt; 0)</a>
<a name="ln774">        {</a>
<a name="ln775">            //Pin the buffer in order to pass the address as parameter later.</a>
<a name="ln776">            var pinnedBuffer = GCHandle.Alloc(CursorShapeBuffer, GCHandleType.Pinned);</a>
<a name="ln777">            var cursorBufferAddress = pinnedBuffer.AddrOfPinnedObject();</a>
<a name="ln778"> </a>
<a name="ln779">            //Load the cursor shape into the buffer.</a>
<a name="ln780">            DuplicatedOutput.GetFramePointerShape(info.PointerShapeBufferSize, cursorBufferAddress, out _, out CursorShapeInfo);</a>
<a name="ln781"> </a>
<a name="ln782">            //If the cursor is monochrome, it will return the cursor shape twice, one is the mask.</a>
<a name="ln783">            if (CursorShapeInfo.Type == 1)</a>
<a name="ln784">                CursorShapeInfo.Height /= 2;</a>
<a name="ln785"> </a>
<a name="ln786">            //The buffer must be unpinned, to free resources.</a>
<a name="ln787">            pinnedBuffer.Free();</a>
<a name="ln788">        }</a>
<a name="ln789"> </a>
<a name="ln790">        //Store the current cursor position, if it was moved.</a>
<a name="ln791">        if (info.LastMouseUpdateTime != 0)</a>
<a name="ln792">            PreviousPosition = info.PointerPosition;</a>
<a name="ln793"> </a>
<a name="ln794">        //TODO: In a future version, don't merge the cursor image in here, let the editor do that.</a>
<a name="ln795">        //Saves the position of the cursor, so the editor can add the mouse events overlay later.</a>
<a name="ln796">        frame.CursorX = PreviousPosition.Position.X - (Left - OffsetLeft);</a>
<a name="ln797">        frame.CursorY = PreviousPosition.Position.Y - (Top - OffsetTop);</a>
<a name="ln798"> </a>
<a name="ln799">        //If the method is supposed to simply the get the cursor shape no shape was loaded before, there's nothing else to do.</a>
<a name="ln800">        //if (CursorShapeBuffer?.Length == 0 || (info.LastPresentTime == 0 &amp;&amp; info.LastMouseUpdateTime == 0) || !info.PointerPosition.Visible)</a>
<a name="ln801">        if (screenTexture == null || CursorShapeBuffer?.Length == 0)// || !info.PointerPosition.Visible)</a>
<a name="ln802">        {</a>
<a name="ln803">            //FallbackCursorCapture(frame);</a>
<a name="ln804"> </a>
<a name="ln805">            //if (CursorShapeBuffer != null)</a>
<a name="ln806">            return false;</a>
<a name="ln807">        }</a>
<a name="ln808"> </a>
<a name="ln809">        //Don't let it bleed beyond the top-left corner, calculate the dimensions of the portion of the cursor that will appear.</a>
<a name="ln810">        var leftCut = frame.CursorX;</a>
<a name="ln811">        var topCut = frame.CursorY;</a>
<a name="ln812">        var rightCut = screenTexture.Description.Width - (frame.CursorX + CursorShapeInfo.Width);</a>
<a name="ln813">        var bottomCut = screenTexture.Description.Height - (frame.CursorY + CursorShapeInfo.Height);</a>
<a name="ln814"> </a>
<a name="ln815">        //Adjust to the hotspot offset, so it's possible to add the highlight correctly later.</a>
<a name="ln816">        frame.CursorX += CursorShapeInfo.HotSpot.X;</a>
<a name="ln817">        frame.CursorY += CursorShapeInfo.HotSpot.Y;</a>
<a name="ln818"> </a>
<a name="ln819">        //Don't try merging the textures if the cursor is out of bounds.</a>
<a name="ln820">        if (leftCut + CursorShapeInfo.Width &lt; 1 || topCut + CursorShapeInfo.Height &lt; 1 || rightCut + CursorShapeInfo.Width &lt; 1 || bottomCut + CursorShapeInfo.Height &lt; 1)</a>
<a name="ln821">            return false;</a>
<a name="ln822"> </a>
<a name="ln823">        var cursorLeft = Math.Max(leftCut, 0);</a>
<a name="ln824">        var cursorTop = Math.Max(topCut, 0);</a>
<a name="ln825">        var cursorWidth = leftCut &lt; 0 ? CursorShapeInfo.Width + leftCut : rightCut &lt; 0 ? CursorShapeInfo.Width + rightCut : CursorShapeInfo.Width;</a>
<a name="ln826">        var cursorHeight = topCut &lt; 0 ? CursorShapeInfo.Height + topCut : bottomCut &lt; 0 ? CursorShapeInfo.Height + bottomCut : CursorShapeInfo.Height;</a>
<a name="ln827"> </a>
<a name="ln828">        //The staging texture must be able to hold all pixels.</a>
<a name="ln829">        if (CursorStagingTexture == null || CursorStagingTexture.Description.Width != cursorWidth || CursorStagingTexture.Description.Height != cursorHeight)</a>
<a name="ln830">        {</a>
<a name="ln831">            //In order to change the size of the texture, I need to instantiate it again with the new size.</a>
<a name="ln832">            CursorStagingTexture?.Dispose();</a>
<a name="ln833">            CursorStagingTexture = new Texture2D(Device, new Texture2DDescription</a>
<a name="ln834">            {</a>
<a name="ln835">                ArraySize = 1,</a>
<a name="ln836">                BindFlags = BindFlags.None,</a>
<a name="ln837">                CpuAccessFlags = CpuAccessFlags.Write,</a>
<a name="ln838">                Height = cursorHeight,</a>
<a name="ln839">                Format = Format.B8G8R8A8_UNorm,</a>
<a name="ln840">                Width = cursorWidth,</a>
<a name="ln841">                MipLevels = 1,</a>
<a name="ln842">                OptionFlags = ResourceOptionFlags.None,</a>
<a name="ln843">                SampleDescription = new SampleDescription(1, 0),</a>
<a name="ln844">                Usage = ResourceUsage.Staging</a>
<a name="ln845">            });</a>
<a name="ln846">        }</a>
<a name="ln847"> </a>
<a name="ln848">        //The region where the cursor is located is copied to the staging texture to act as the background when dealing with masks and transparency.</a>
<a name="ln849">        //The cutout must be the exact region needed and it can't overflow. It's not allowed to try to cut outside of the screenTexture region.</a>
<a name="ln850">        var region = new ResourceRegion</a>
<a name="ln851">        {</a>
<a name="ln852">            Left = cursorLeft,</a>
<a name="ln853">            Top = cursorTop,</a>
<a name="ln854">            Front = 0,</a>
<a name="ln855">            Right = cursorLeft + cursorWidth,</a>
<a name="ln856">            Bottom = cursorTop + cursorHeight,</a>
<a name="ln857">            Back = 1</a>
<a name="ln858">        };</a>
<a name="ln859"> </a>
<a name="ln860">        //Copy from the screen the region in which the cursor is located.</a>
<a name="ln861">        Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0, region, CursorStagingTexture, 0);</a>
<a name="ln862"> </a>
<a name="ln863">        //Get cursor details and draw it to the staging texture.</a>
<a name="ln864">        DrawCursorShape(CursorStagingTexture, CursorShapeInfo, CursorShapeBuffer, leftCut &lt; 0 ? leftCut * -1 : 0, topCut &lt; 0 ? topCut * -1 : 0, cursorWidth, cursorHeight);</a>
<a name="ln865"> </a>
<a name="ln866">        //Copy back the cursor texture to the screen texture.</a>
<a name="ln867">        Device.ImmediateContext.CopySubresourceRegion(CursorStagingTexture, 0, null, screenTexture, 0, cursorLeft, cursorTop);</a>
<a name="ln868"> </a>
<a name="ln869">        return true;</a>
<a name="ln870">    }</a>
<a name="ln871"> </a>
<a name="ln872">    private void DrawCursorShape(Texture2D texture, OutputDuplicatePointerShapeInformation info, byte[] buffer, int leftCut, int topCut, int cursorWidth, int cursorHeight)</a>
<a name="ln873">    {</a>
<a name="ln874">        using (var surface = texture.QueryInterface&lt;Surface&gt;())</a>
<a name="ln875">        {</a>
<a name="ln876">            //Maps the surface, indicating that the CPU needs access to the data.</a>
<a name="ln877">            var rect = surface.Map(SharpDX.DXGI.MapFlags.Write);</a>
<a name="ln878"> </a>
<a name="ln879">            //Cursors can be divided into 3 types:</a>
<a name="ln880">            switch (info.Type)</a>
<a name="ln881">            {</a>
<a name="ln882">                //Masked monochrome, a cursor which reacts with the background.</a>
<a name="ln883">                case (int)OutputDuplicatePointerShapeType.Monochrome:</a>
<a name="ln884">                    DrawMonochromeCursor(leftCut, topCut, cursorWidth, cursorHeight, rect, info.Pitch, buffer, info.Height);</a>
<a name="ln885">                    break;</a>
<a name="ln886"> </a>
<a name="ln887">                //Color, a colored cursor which supports transparency.</a>
<a name="ln888">                case (int)OutputDuplicatePointerShapeType.Color:</a>
<a name="ln889">                    DrawColorCursor(leftCut, topCut, cursorWidth, cursorHeight, rect, info.Pitch, buffer);</a>
<a name="ln890">                    break;</a>
<a name="ln891"> </a>
<a name="ln892">                //Masked color, a mix of both previous types.</a>
<a name="ln893">                case (int)OutputDuplicatePointerShapeType.MaskedColor:</a>
<a name="ln894">                    DrawMaskedColorCursor(leftCut, topCut, cursorWidth, cursorHeight, rect, info.Pitch, buffer);</a>
<a name="ln895">                    break;</a>
<a name="ln896">            }</a>
<a name="ln897"> </a>
<a name="ln898">            surface.Unmap();</a>
<a name="ln899">        }</a>
<a name="ln900">    }</a>
<a name="ln901"> </a>
<a name="ln902">    private void DrawMonochromeCursor(int offsetX, int offsetY, int width, int height, DataRectangle rect, int pitch, byte[] buffer, int actualHeight)</a>
<a name="ln903">    {</a>
<a name="ln904">        for (var row = offsetY; row &lt; height; row++)</a>
<a name="ln905">        {</a>
<a name="ln906">            //128 in binary.</a>
<a name="ln907">            byte mask = 0x80;</a>
<a name="ln908"> </a>
<a name="ln909">            //Simulate the offset, adjusting the mask.</a>
<a name="ln910">            for (var off = 0; off &lt; offsetX; off++)</a>
<a name="ln911">            {</a>
<a name="ln912">                if (mask == 0x01)</a>
<a name="ln913">                    mask = 0x80;</a>
<a name="ln914">                else</a>
<a name="ln915">                    mask = (byte)(mask &gt;&gt; 1);</a>
<a name="ln916">            }</a>
<a name="ln917"> </a>
<a name="ln918">            for (var col = offsetX; col &lt; width; col++)</a>
<a name="ln919">            {</a>
<a name="ln920">                var pos = (row - offsetY) * rect.Pitch + (col - offsetX) * 4;</a>
<a name="ln921">                var and = (buffer[row * pitch + col / 8] &amp; mask) == mask; //Mask is take from the first half of the cursor image.</a>
<a name="ln922">                var xor = (buffer[row * pitch + col / 8 + actualHeight * pitch] &amp; mask) == mask; //Mask is taken from the second half of the cursor image, hence the &quot;+ height * pitch&quot;.</a>
<a name="ln923"> </a>
<a name="ln924">                //Reads current pixel and applies AND and XOR. (AND/XOR ? White : Black)</a>
<a name="ln925">                Marshal.WriteByte(rect.DataPointer, pos, (byte)((Marshal.ReadByte(rect.DataPointer, pos) &amp; (and ? 255 : 0)) ^ (xor ? 255 : 0)));</a>
<a name="ln926">                Marshal.WriteByte(rect.DataPointer, pos + 1, (byte)((Marshal.ReadByte(rect.DataPointer, pos + 1) &amp; (and ? 255 : 0)) ^ (xor ? 255 : 0)));</a>
<a name="ln927">                Marshal.WriteByte(rect.DataPointer, pos + 2, (byte)((Marshal.ReadByte(rect.DataPointer, pos + 2) &amp; (and ? 255 : 0)) ^ (xor ? 255 : 0)));</a>
<a name="ln928">                Marshal.WriteByte(rect.DataPointer, pos + 3, (byte)((Marshal.ReadByte(rect.DataPointer, pos + 3) &amp; 255) ^ 0));</a>
<a name="ln929"> </a>
<a name="ln930">                //Shifts the mask around until it reaches 1, then resets it back to 128.</a>
<a name="ln931">                if (mask == 0x01)</a>
<a name="ln932">                    mask = 0x80;</a>
<a name="ln933">                else</a>
<a name="ln934">                    mask = (byte)(mask &gt;&gt; 1);</a>
<a name="ln935">            }</a>
<a name="ln936">        }</a>
<a name="ln937">    }</a>
<a name="ln938"> </a>
<a name="ln939">    private void DrawColorCursor(int offsetX, int offsetY, int width, int height, DataRectangle rect, int pitch, byte[] buffer)</a>
<a name="ln940">    {</a>
<a name="ln941">        for (var row = offsetY; row &lt; height; row++)</a>
<a name="ln942">        {</a>
<a name="ln943">            for (var col = offsetX; col &lt; width; col++)</a>
<a name="ln944">            {</a>
<a name="ln945">                var surfaceIndex = (row - offsetY) * rect.Pitch + (col - offsetX) * 4;</a>
<a name="ln946">                var bufferIndex = row * pitch + col * 4;</a>
<a name="ln947">                var alpha = buffer[bufferIndex + 3] + 1;</a>
<a name="ln948"> </a>
<a name="ln949">                if (alpha == 1)</a>
<a name="ln950">                    continue;</a>
<a name="ln951"> </a>
<a name="ln952">                //Premultiplied alpha values.</a>
<a name="ln953">                var invAlpha = 256 - alpha;</a>
<a name="ln954">                alpha += 1;</a>
<a name="ln955"> </a>
<a name="ln956">                Marshal.WriteByte(rect.DataPointer, surfaceIndex, (byte)((alpha * buffer[bufferIndex] + invAlpha * Marshal.ReadByte(rect.DataPointer, surfaceIndex)) &gt;&gt; 8));</a>
<a name="ln957">                Marshal.WriteByte(rect.DataPointer, surfaceIndex + 1, (byte)((alpha * buffer[bufferIndex + 1] + invAlpha * Marshal.ReadByte(rect.DataPointer, surfaceIndex + 1)) &gt;&gt; 8));</a>
<a name="ln958">                Marshal.WriteByte(rect.DataPointer, surfaceIndex + 2, (byte)((alpha * buffer[bufferIndex + 2] + invAlpha * Marshal.ReadByte(rect.DataPointer, surfaceIndex + 2)) &gt;&gt; 8));</a>
<a name="ln959">            }</a>
<a name="ln960">        }</a>
<a name="ln961">    }</a>
<a name="ln962"> </a>
<a name="ln963">    private void DrawMaskedColorCursor(int offsetX, int offsetY, int width, int height, DataRectangle rect, int pitch, byte[] buffer)</a>
<a name="ln964">    {</a>
<a name="ln965">        //ImageUtil.ImageMethods.SavePixelArrayToFile(buffer, width, height, 4, System.IO.Path.GetFullPath(&quot;.\\MaskedColor.png&quot;));</a>
<a name="ln966"> </a>
<a name="ln967">        for (var row = offsetY; row &lt; height; row++)</a>
<a name="ln968">        {</a>
<a name="ln969">            for (var col = offsetX; col &lt; width; col++)</a>
<a name="ln970">            {</a>
<a name="ln971">                var surfaceIndex = (row - offsetY) * rect.Pitch + (col - offsetX) * 4;</a>
<a name="ln972">                var bufferIndex = row * pitch + col * 4;</a>
<a name="ln973">                var maskFlag = buffer[bufferIndex + 3];</a>
<a name="ln974"> </a>
<a name="ln975">                //Just copies the pixel color.</a>
<a name="ln976">                if (maskFlag == 0)</a>
<a name="ln977">                {</a>
<a name="ln978">                    Marshal.WriteByte(rect.DataPointer, surfaceIndex, buffer[bufferIndex]);</a>
<a name="ln979">                    Marshal.WriteByte(rect.DataPointer, surfaceIndex + 1, buffer[bufferIndex + 1]);</a>
<a name="ln980">                    Marshal.WriteByte(rect.DataPointer, surfaceIndex + 2, buffer[bufferIndex + 2]);</a>
<a name="ln981">                    return;</a>
<a name="ln982">                }</a>
<a name="ln983"> </a>
<a name="ln984">                //Applies the XOR operation with the current color.</a>
<a name="ln985">                Marshal.WriteByte(rect.DataPointer, surfaceIndex, (byte)(buffer[bufferIndex] ^ Marshal.ReadByte(rect.DataPointer, surfaceIndex)));</a>
<a name="ln986">                Marshal.WriteByte(rect.DataPointer, surfaceIndex + 1, (byte)(buffer[bufferIndex + 1] ^ Marshal.ReadByte(rect.DataPointer, surfaceIndex + 1)));</a>
<a name="ln987">                Marshal.WriteByte(rect.DataPointer, surfaceIndex + 2, (byte)(buffer[bufferIndex + 2] ^ Marshal.ReadByte(rect.DataPointer, surfaceIndex + 2)));</a>
<a name="ln988">            }</a>
<a name="ln989">        }</a>
<a name="ln990">    }</a>
<a name="ln991"> </a>
<a name="ln992">    public override void Save(FrameInfo frame)</a>
<a name="ln993">    {</a>
<a name="ln994">        frame.Image?.Save(frame.Path);</a>
<a name="ln995">        frame.Image?.Dispose();</a>
<a name="ln996">        frame.Image = null;</a>
<a name="ln997"> </a>
<a name="ln998">        Project.Frames.Add(frame);</a>
<a name="ln999">    }</a>
<a name="ln1000"> </a>
<a name="ln1001">    public override async Task Stop()</a>
<a name="ln1002">    {</a>
<a name="ln1003">        if (!WasStarted)</a>
<a name="ln1004">            return;</a>
<a name="ln1005"> </a>
<a name="ln1006">        DisposeInternal();</a>
<a name="ln1007"> </a>
<a name="ln1008">        await base.Stop();</a>
<a name="ln1009">    }</a>
<a name="ln1010"> </a>
<a name="ln1011">    internal void DisposeInternal()</a>
<a name="ln1012">    {</a>
<a name="ln1013">        Device.Dispose();</a>
<a name="ln1014"> </a>
<a name="ln1015">        if (MajorCrashHappened)</a>
<a name="ln1016">            return;</a>
<a name="ln1017"> </a>
<a name="ln1018">        BackingTexture.Dispose();</a>
<a name="ln1019">        StagingTexture.Dispose();</a>
<a name="ln1020">        DuplicatedOutput.Dispose();</a>
<a name="ln1021"> </a>
<a name="ln1022">        CursorStagingTexture?.Dispose();</a>
<a name="ln1023">    }</a>
<a name="ln1024"> </a>
<a name="ln1025"> </a>
<a name="ln1026">    [Obsolete]</a>
<a name="ln1027">    private void FallbackCursorCapture(FrameInfo frame)</a>
<a name="ln1028">    {</a>
<a name="ln1029">        //if (_justStarted &amp;&amp; (CursorShapeBuffer?.Length ?? 0) == 0)</a>
<a name="ln1030">        {</a>
<a name="ln1031">            //_justStarted = false;</a>
<a name="ln1032"> </a>
<a name="ln1033">            //https://stackoverflow.com/a/6374151/1735672</a>
<a name="ln1034">            //Bitmap struct, is used to get the cursor shape when SharpDX fails to do so.</a>
<a name="ln1035">            var infoHeader = new BitmapInfoHeader();</a>
<a name="ln1036">            infoHeader.biSize = (uint)Marshal.SizeOf(infoHeader);</a>
<a name="ln1037">            infoHeader.biBitCount = 32;</a>
<a name="ln1038">            infoHeader.biClrUsed = 0;</a>
<a name="ln1039">            infoHeader.biClrImportant = 0;</a>
<a name="ln1040">            infoHeader.biCompression = 0;</a>
<a name="ln1041">            infoHeader.biHeight = -Height; //Negative, so the Y-axis will be positioned correctly.</a>
<a name="ln1042">            infoHeader.biWidth = Width;</a>
<a name="ln1043">            infoHeader.biPlanes = 1;</a>
<a name="ln1044"> </a>
<a name="ln1045">            try</a>
<a name="ln1046">            {</a>
<a name="ln1047">                var cursorInfo = new CursorInfo();</a>
<a name="ln1048">                cursorInfo.cbSize = Marshal.SizeOf(cursorInfo);</a>
<a name="ln1049"> </a>
<a name="ln1050">                if (!User32.GetCursorInfo(out cursorInfo))</a>
<a name="ln1051">                    return;</a>
<a name="ln1052"> </a>
<a name="ln1053">                if (cursorInfo.flags == Native.Constants.CursorShowing)</a>
<a name="ln1054">                {</a>
<a name="ln1055">                    var hicon = User32.CopyIcon(cursorInfo.hCursor);</a>
<a name="ln1056"> </a>
<a name="ln1057">                    if (hicon != IntPtr.Zero)</a>
<a name="ln1058">                    {</a>
<a name="ln1059">                        if (User32.GetIconInfo(hicon, out var iconInfo))</a>
<a name="ln1060">                        {</a>
<a name="ln1061">                            frame.CursorX = cursorInfo.ptScreenPos.X - Left;</a>
<a name="ln1062">                            frame.CursorY = cursorInfo.ptScreenPos.Y - Top;</a>
<a name="ln1063"> </a>
<a name="ln1064">                            var bitmap = new Bitmap();</a>
<a name="ln1065">                            var hndl = GCHandle.Alloc(bitmap, GCHandleType.Pinned);</a>
<a name="ln1066">                            var ptrToBitmap = hndl.AddrOfPinnedObject();</a>
<a name="ln1067">                            Gdi32.GetObject(iconInfo.hbmColor, Marshal.SizeOf&lt;Bitmap&gt;(), ptrToBitmap);</a>
<a name="ln1068">                            bitmap = Marshal.PtrToStructure&lt;Bitmap&gt;(ptrToBitmap);</a>
<a name="ln1069">                            hndl.Free();</a>
<a name="ln1070"> </a>
<a name="ln1071">                            //https://microsoft.public.vc.mfc.narkive.com/H1CZeqUk/how-can-i-get-bitmapinfo-object-from-bitmap-or-hbitmap</a>
<a name="ln1072">                            infoHeader.biHeight = bitmap.bmHeight;</a>
<a name="ln1073">                            infoHeader.biWidth = bitmap.bmWidth;</a>
<a name="ln1074">                            infoHeader.biBitCount = (ushort)bitmap.bmBitsPixel;</a>
<a name="ln1075"> </a>
<a name="ln1076">                            var w = (bitmap.bmWidth * bitmap.bmBitsPixel + 31) / 8;</a>
<a name="ln1077">                            CursorShapeBuffer = new byte[w * bitmap.bmHeight];</a>
<a name="ln1078"> </a>
<a name="ln1079">                            var windowDeviceContext = User32.GetWindowDC(IntPtr.Zero);</a>
<a name="ln1080">                            var compatibleBitmap = Gdi32.CreateCompatibleBitmap(windowDeviceContext, Width, Height);</a>
<a name="ln1081"> </a>
<a name="ln1082">                            Gdi32.GetDIBits(windowDeviceContext, compatibleBitmap, 0, (uint)infoHeader.biHeight, CursorShapeBuffer, ref infoHeader, DibColorModes.RgbColors);</a>
<a name="ln1083"> </a>
<a name="ln1084">                            //CursorShapeInfo = new OutputDuplicatePointerShapeInformation();</a>
<a name="ln1085">                            //CursorShapeInfo.Type = (int)OutputDuplicatePointerShapeType.Color;</a>
<a name="ln1086">                            //CursorShapeInfo.Width = bitmap.bmWidth;</a>
<a name="ln1087">                            //CursorShapeInfo.Height = bitmap.bmHeight;</a>
<a name="ln1088">                            //CursorShapeInfo.Pitch = w;</a>
<a name="ln1089">                            //CursorShapeInfo.HotSpot = new RawPoint(0, 0);</a>
<a name="ln1090"> </a>
<a name="ln1091">                            //if (frame.CursorX &gt; 0 &amp;&amp; frame.CursorY &gt; 0)</a>
<a name="ln1092">                            //    Native.DrawIconEx(_compatibleDeviceContext, frame.CursorX - iconInfo.xHotspot, frame.CursorY - iconInfo.yHotspot, cursorInfo.hCursor, 0, 0, 0, IntPtr.Zero, 0x0003);</a>
<a name="ln1093"> </a>
<a name="ln1094">                            //Native.SelectObject(CompatibleDeviceContext, OldBitmap);</a>
<a name="ln1095">                            //Native.DeleteObject(compatibleBitmap);</a>
<a name="ln1096">                            //Native.DeleteDC(CompatibleDeviceContext);</a>
<a name="ln1097">                            //Native.ReleaseDC(IntPtr.Zero, windowDeviceContext);</a>
<a name="ln1098">                        }</a>
<a name="ln1099"> </a>
<a name="ln1100">                        Gdi32.DeleteObject(iconInfo.hbmColor);</a>
<a name="ln1101">                        Gdi32.DeleteObject(iconInfo.hbmMask);</a>
<a name="ln1102">                    }</a>
<a name="ln1103"> </a>
<a name="ln1104">                    User32.DestroyIcon(hicon);</a>
<a name="ln1105">                }</a>
<a name="ln1106"> </a>
<a name="ln1107">                Gdi32.DeleteObject(cursorInfo.hCursor);</a>
<a name="ln1108">            }</a>
<a name="ln1109">            catch (Exception e)</a>
<a name="ln1110">            {</a>
<a name="ln1111">                LogWriter.Log(e, &quot;Impossible to get the cursor&quot;);</a>
<a name="ln1112">            }</a>
<a name="ln1113">        }</a>
<a name="ln1114">    }</a>
<a name="ln1115">}</a>
</code></pre>
<div class="balloon" rel="538"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3095/" target="_blank">V3095</a> The 'Device.ImmediateContext' object was used before it was verified against null. Check lines: 538, 575.</p></div>
<div class="balloon" rel="34"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3073/" target="_blank">V3073</a> Not all IDisposable members are properly disposed. Call 'Dispose' when disposing 'DirectImageCapture' class. Inspect: TransformTexture.</p></div>
<div class="balloon" rel="289"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3125/" target="_blank">V3125</a> The 'resource' object was used after it was verified against null. Check lines: 289, 279.</p></div>
<div class="balloon" rel="465"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3125/" target="_blank">V3125</a> The 'resource' object was used after it was verified against null. Check lines: 465, 455.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>