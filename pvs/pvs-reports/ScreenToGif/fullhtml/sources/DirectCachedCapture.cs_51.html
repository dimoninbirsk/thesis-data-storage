<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>DirectCachedCapture.cs</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cs">
<a name="ln1">using System;</a>
<a name="ln2">using System.IO;</a>
<a name="ln3">using System.IO.Compression;</a>
<a name="ln4">using System.Runtime.InteropServices;</a>
<a name="ln5">using System.Threading.Tasks;</a>
<a name="ln6">using System.Windows;</a>
<a name="ln7">using ScreenToGif.Model;</a>
<a name="ln8">using ScreenToGif.Util;</a>
<a name="ln9">using ScreenToGif.Util.Settings;</a>
<a name="ln10">using SharpDX;</a>
<a name="ln11">using SharpDX.Direct3D11;</a>
<a name="ln12">using SharpDX.DXGI;</a>
<a name="ln13">using SharpDX.Mathematics.Interop;</a>
<a name="ln14">using MapFlags = SharpDX.Direct3D11.MapFlags;</a>
<a name="ln15"> </a>
<a name="ln16">namespace ScreenToGif.Capture;</a>
<a name="ln17"> </a>
<a name="ln18">/// &lt;summary&gt;</a>
<a name="ln19">/// Frame capture using the DesktopDuplication API and memory cache.</a>
<a name="ln20">/// Adapted from:</a>
<a name="ln21">/// https://github.com/ajorkowski/VirtualSpace</a>
<a name="ln22">/// https://github.com/Microsoft/Windows-classic-samples/blob/master/Samples/DXGIDesktopDuplication</a>
<a name="ln23">///</a>
<a name="ln24">/// How to debug:</a>
<a name="ln25">/// https://walbourn.github.io/dxgi-debug-device/</a>
<a name="ln26">/// https://walbourn.github.io/direct3d-sdk-debug-layer-tricks/</a>
<a name="ln27">/// https://devblogs.microsoft.com/cppblog/visual-studio-2015-and-graphics-tools-for-windows-10/</a>
<a name="ln28">/// &lt;/summary&gt;</a>
<a name="ln29">internal class DirectCachedCapture : DirectImageCapture</a>
<a name="ln30">{</a>
<a name="ln31">    #region Variables</a>
<a name="ln32"> </a>
<a name="ln33">    private FileStream _fileStream;</a>
<a name="ln34">    private BufferedStream _bufferedStream;</a>
<a name="ln35">    private DeflateStream _compressStream;</a>
<a name="ln36"> </a>
<a name="ln37">    #endregion</a>
<a name="ln38"> </a>
<a name="ln39">    public override void Start(int delay, int left, int top, int width, int height, double dpi, ProjectInfo project)</a>
<a name="ln40">    {</a>
<a name="ln41">        base.Start(delay, left, top, width, height, dpi, project);</a>
<a name="ln42"> </a>
<a name="ln43">        _fileStream = new FileStream(project.CachePath, FileMode.Create, FileAccess.Write, FileShare.None);</a>
<a name="ln44">        _bufferedStream = new BufferedStream(_fileStream, UserSettings.All.MemoryCacheSize * 1048576); //Each 1 MB has 1_048_576 bytes.</a>
<a name="ln45">        _compressStream = new DeflateStream(_bufferedStream, UserSettings.All.CaptureCompression, true);</a>
<a name="ln46">    }</a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">    public override int Capture(FrameInfo frame)</a>
<a name="ln50">    {</a>
<a name="ln51">        var res = new Result(-1);</a>
<a name="ln52"> </a>
<a name="ln53">        try</a>
<a name="ln54">        {</a>
<a name="ln55">            //Try to get the duplicated output frame within given time.</a>
<a name="ln56">            res = DuplicatedOutput.TryAcquireNextFrame(0, out var info, out var resource);</a>
<a name="ln57"> </a>
<a name="ln58">            if (FrameCount == 0 &amp;&amp; (res.Failure || resource == null))</a>
<a name="ln59">            {</a>
<a name="ln60">                //Somehow, it was not possible to retrieve the resource, frame or metadata.</a>
<a name="ln61">                resource?.Dispose();</a>
<a name="ln62">                return FrameCount;</a>
<a name="ln63">            }</a>
<a name="ln64"> </a>
<a name="ln65">            #region Process changes</a>
<a name="ln66"> </a>
<a name="ln67">            //Something on screen was moved or changed.</a>
<a name="ln68">            if (info.TotalMetadataBufferSize &gt; 0)</a>
<a name="ln69">            {</a>
<a name="ln70">                //Copy resource into memory that can be accessed by the CPU.</a>
<a name="ln71">                using (var screenTexture = resource.QueryInterface&lt;Texture2D&gt;())</a>
<a name="ln72">                {</a>
<a name="ln73">                    #region Moved rectangles</a>
<a name="ln74"> </a>
<a name="ln75">                    var movedRectangles = new OutputDuplicateMoveRectangle[info.TotalMetadataBufferSize];</a>
<a name="ln76">                    DuplicatedOutput.GetFrameMoveRects(movedRectangles.Length, movedRectangles, out var movedRegionsLength);</a>
<a name="ln77"> </a>
<a name="ln78">                    for (var movedIndex = 0; movedIndex &lt; movedRegionsLength / Marshal.SizeOf(typeof(OutputDuplicateMoveRectangle)); movedIndex++)</a>
<a name="ln79">                    {</a>
<a name="ln80">                        //Crop the destination rectangle to the screen area rectangle.</a>
<a name="ln81">                        var left = Math.Max(movedRectangles[movedIndex].DestinationRect.Left, Left - OffsetLeft);</a>
<a name="ln82">                        var right = Math.Min(movedRectangles[movedIndex].DestinationRect.Right, Left + Width - OffsetLeft);</a>
<a name="ln83">                        var top = Math.Max(movedRectangles[movedIndex].DestinationRect.Top, Top - OffsetTop);</a>
<a name="ln84">                        var bottom = Math.Min(movedRectangles[movedIndex].DestinationRect.Bottom, Top + Height - OffsetTop);</a>
<a name="ln85"> </a>
<a name="ln86">                        //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln87">                        if (right &gt; left &amp;&amp; bottom &gt; top)</a>
<a name="ln88">                        {</a>
<a name="ln89">                            //Limit the source rectangle to the available size within the destination rectangle.</a>
<a name="ln90">                            var sourceWidth = movedRectangles[movedIndex].SourcePoint.X + (right - left);</a>
<a name="ln91">                            var sourceHeight = movedRectangles[movedIndex].SourcePoint.Y + (bottom - top);</a>
<a name="ln92"> </a>
<a name="ln93">                            Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0,</a>
<a name="ln94">                                new ResourceRegion(movedRectangles[movedIndex].SourcePoint.X, movedRectangles[movedIndex].SourcePoint.Y, 0, sourceWidth, sourceHeight, 1),</a>
<a name="ln95">                                StagingTexture, 0, left - (Left - OffsetLeft), top - (Top - OffsetTop));</a>
<a name="ln96">                        }</a>
<a name="ln97">                    }</a>
<a name="ln98"> </a>
<a name="ln99">                    #endregion</a>
<a name="ln100"> </a>
<a name="ln101">                    #region Dirty rectangles</a>
<a name="ln102"> </a>
<a name="ln103">                    var dirtyRectangles = new RawRectangle[info.TotalMetadataBufferSize];</a>
<a name="ln104">                    DuplicatedOutput.GetFrameDirtyRects(dirtyRectangles.Length, dirtyRectangles, out var dirtyRegionsLength);</a>
<a name="ln105"> </a>
<a name="ln106">                    for (var dirtyIndex = 0; dirtyIndex &lt; dirtyRegionsLength / Marshal.SizeOf(typeof(RawRectangle)); dirtyIndex++)</a>
<a name="ln107">                    {</a>
<a name="ln108">                        //Crop screen positions and size to frame sizes.</a>
<a name="ln109">                        var left = Math.Max(dirtyRectangles[dirtyIndex].Left, Left - OffsetLeft);</a>
<a name="ln110">                        var right = Math.Min(dirtyRectangles[dirtyIndex].Right, Left + Width - OffsetLeft);</a>
<a name="ln111">                        var top = Math.Max(dirtyRectangles[dirtyIndex].Top, Top - OffsetTop);</a>
<a name="ln112">                        var bottom = Math.Min(dirtyRectangles[dirtyIndex].Bottom, Top + Height - OffsetTop);</a>
<a name="ln113"> </a>
<a name="ln114">                        //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln115">                        if (right &gt; left &amp;&amp; bottom &gt; top)</a>
<a name="ln116">                            Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0, new ResourceRegion(left, top, 0, right, bottom, 1), StagingTexture, 0, left - (Left - OffsetLeft), top - (Top - OffsetTop));</a>
<a name="ln117">                    }</a>
<a name="ln118"> </a>
<a name="ln119">                    #endregion</a>
<a name="ln120">                }</a>
<a name="ln121">            }</a>
<a name="ln122"> </a>
<a name="ln123">            #endregion</a>
<a name="ln124"> </a>
<a name="ln125">            #region Gets the image data</a>
<a name="ln126"> </a>
<a name="ln127">            //Gets the staging texture as a stream.</a>
<a name="ln128">            var data = Device.ImmediateContext.MapSubresource(StagingTexture, 0, MapMode.Read, MapFlags.None, out var stream);</a>
<a name="ln129"> </a>
<a name="ln130">            if (data.IsEmpty)</a>
<a name="ln131">            {</a>
<a name="ln132">                Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln133">                stream?.Dispose();</a>
<a name="ln134">                resource?.Dispose();</a>
<a name="ln135">                return FrameCount;</a>
<a name="ln136">            }</a>
<a name="ln137"> </a>
<a name="ln138">            //Set frame details.</a>
<a name="ln139">            FrameCount++;</a>
<a name="ln140">            frame.Path = $&quot;{Project.FullPath}{FrameCount}.png&quot;;</a>
<a name="ln141">            frame.Delay = FrameRate.GetMilliseconds();</a>
<a name="ln142">            frame.DataLength = stream.Length;</a>
<a name="ln143">            frame.Data = new byte[stream.Length];</a>
<a name="ln144"> </a>
<a name="ln145">            //BGRA32 is 4 bytes.</a>
<a name="ln146">            for (var height = 0; height &lt; Height; height++)</a>
<a name="ln147">            {</a>
<a name="ln148">                stream.Position = height * data.RowPitch;</a>
<a name="ln149">                Marshal.Copy(new IntPtr(stream.DataPointer.ToInt64() + height * data.RowPitch), frame.Data, height * Width * 4, Width * 4);</a>
<a name="ln150">            }</a>
<a name="ln151"> </a>
<a name="ln152">            if (IsAcceptingFrames)</a>
<a name="ln153">                BlockingCollection.Add(frame);</a>
<a name="ln154"> </a>
<a name="ln155">            #endregion</a>
<a name="ln156"> </a>
<a name="ln157">            Device.ImmediateContext?.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln158"> </a>
<a name="ln159">            resource?.Dispose();</a>
<a name="ln160">            return FrameCount;</a>
<a name="ln161">        }</a>
<a name="ln162">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.WaitTimeout.Result.Code)</a>
<a name="ln163">        {</a>
<a name="ln164">            return FrameCount;</a>
<a name="ln165">        }</a>
<a name="ln166">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceRemoved.Result.Code || se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceReset.Result.Code)</a>
<a name="ln167">        {</a>
<a name="ln168">            //When the device gets lost or reset, the resources should be instantiated again.</a>
<a name="ln169">            DisposeInternal();</a>
<a name="ln170">            Initialize();</a>
<a name="ln171"> </a>
<a name="ln172">            return FrameCount;</a>
<a name="ln173">        }</a>
<a name="ln174">        catch (Exception ex)</a>
<a name="ln175">        {</a>
<a name="ln176">            LogWriter.Log(ex, &quot;It was not possible to finish capturing the frame with DirectX.&quot;);</a>
<a name="ln177"> </a>
<a name="ln178">            MajorCrashHappened = true;</a>
<a name="ln179"> </a>
<a name="ln180">            if (IsAcceptingFrames)</a>
<a name="ln181">                Application.Current.Dispatcher.Invoke(() =&gt; OnError.Invoke(ex));</a>
<a name="ln182"> </a>
<a name="ln183">            return FrameCount;</a>
<a name="ln184">        }</a>
<a name="ln185">        finally</a>
<a name="ln186">        {</a>
<a name="ln187">            try</a>
<a name="ln188">            {</a>
<a name="ln189">                //Only release the frame if there was a success in capturing it.</a>
<a name="ln190">                if (res.Success)</a>
<a name="ln191">                    DuplicatedOutput.ReleaseFrame();</a>
<a name="ln192">            }</a>
<a name="ln193">            catch (Exception e)</a>
<a name="ln194">            {</a>
<a name="ln195">                LogWriter.Log(e, &quot;It was not possible to release the frame.&quot;);</a>
<a name="ln196">            }</a>
<a name="ln197">        }</a>
<a name="ln198">    }</a>
<a name="ln199"> </a>
<a name="ln200">    public override int CaptureWithCursor(FrameInfo frame)</a>
<a name="ln201">    {</a>
<a name="ln202">        var res = new Result(-1);</a>
<a name="ln203"> </a>
<a name="ln204">        try</a>
<a name="ln205">        {</a>
<a name="ln206">            //Try to get the duplicated output frame within given time.</a>
<a name="ln207">            res = DuplicatedOutput.TryAcquireNextFrame(0, out var info, out var resource);</a>
<a name="ln208"> </a>
<a name="ln209">            //Checks how to proceed with the capture. It could have failed, or the screen, cursor or both could have been captured.</a>
<a name="ln210">            if (FrameCount == 0 &amp;&amp; info.LastMouseUpdateTime == 0 &amp;&amp; (res.Failure || resource == null))</a>
<a name="ln211">            {</a>
<a name="ln212">                //Somehow, it was not possible to retrieve the resource, frame or metadata.</a>
<a name="ln213">                resource?.Dispose();</a>
<a name="ln214">                return FrameCount;</a>
<a name="ln215">            }</a>
<a name="ln216">            else if (FrameCount == 0 &amp;&amp; info.TotalMetadataBufferSize == 0 &amp;&amp; info.LastMouseUpdateTime &gt; 0)</a>
<a name="ln217">            {</a>
<a name="ln218">                //Sometimes, the first frame has cursor info, but no screen changes.</a>
<a name="ln219">                GetCursor(null, info, frame);</a>
<a name="ln220">                resource?.Dispose();</a>
<a name="ln221">                return FrameCount;</a>
<a name="ln222">            }</a>
<a name="ln223"> </a>
<a name="ln224">            #region Process changes</a>
<a name="ln225"> </a>
<a name="ln226">            //Something on screen was moved or changed.</a>
<a name="ln227">            if (info.TotalMetadataBufferSize &gt; 0)</a>
<a name="ln228">            {</a>
<a name="ln229">                //Copies the screen data into memory that can be accessed by the CPU.</a>
<a name="ln230">                using (var screenTexture = resource.QueryInterface&lt;Texture2D&gt;())</a>
<a name="ln231">                {</a>
<a name="ln232">                    #region Moved rectangles</a>
<a name="ln233"> </a>
<a name="ln234">                    var movedRectangles = new OutputDuplicateMoveRectangle[info.TotalMetadataBufferSize];</a>
<a name="ln235">                    DuplicatedOutput.GetFrameMoveRects(movedRectangles.Length, movedRectangles, out var movedRegionsLength);</a>
<a name="ln236"> </a>
<a name="ln237">                    for (var movedIndex = 0; movedIndex &lt; movedRegionsLength / Marshal.SizeOf(typeof(OutputDuplicateMoveRectangle)); movedIndex++)</a>
<a name="ln238">                    {</a>
<a name="ln239">                        //Crop the destination rectangle to the screen area rectangle.</a>
<a name="ln240">                        var left = Math.Max(movedRectangles[movedIndex].DestinationRect.Left, Left - OffsetLeft);</a>
<a name="ln241">                        var right = Math.Min(movedRectangles[movedIndex].DestinationRect.Right, Left + Width - OffsetLeft);</a>
<a name="ln242">                        var top = Math.Max(movedRectangles[movedIndex].DestinationRect.Top, Top - OffsetTop);</a>
<a name="ln243">                        var bottom = Math.Min(movedRectangles[movedIndex].DestinationRect.Bottom, Top + Height - OffsetTop);</a>
<a name="ln244"> </a>
<a name="ln245">                        //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln246">                        if (right &gt; left &amp;&amp; bottom &gt; top)</a>
<a name="ln247">                        {</a>
<a name="ln248">                            //Limit the source rectangle to the available size within the destination rectangle.</a>
<a name="ln249">                            var sourceWidth = movedRectangles[movedIndex].SourcePoint.X + (right - left);</a>
<a name="ln250">                            var sourceHeight = movedRectangles[movedIndex].SourcePoint.Y + (bottom - top);</a>
<a name="ln251"> </a>
<a name="ln252">                            Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0,</a>
<a name="ln253">                                new ResourceRegion(movedRectangles[movedIndex].SourcePoint.X, movedRectangles[movedIndex].SourcePoint.Y, 0, sourceWidth, sourceHeight, 1),</a>
<a name="ln254">                                BackingTexture, 0, left - (Left - OffsetLeft), top - (Top - OffsetTop));</a>
<a name="ln255">                        }</a>
<a name="ln256">                    }</a>
<a name="ln257"> </a>
<a name="ln258">                    #endregion</a>
<a name="ln259"> </a>
<a name="ln260">                    #region Dirty rectangles</a>
<a name="ln261"> </a>
<a name="ln262">                    var dirtyRectangles = new RawRectangle[info.TotalMetadataBufferSize];</a>
<a name="ln263">                    DuplicatedOutput.GetFrameDirtyRects(dirtyRectangles.Length, dirtyRectangles, out var dirtyRegionsLength);</a>
<a name="ln264"> </a>
<a name="ln265">                    for (var dirtyIndex = 0; dirtyIndex &lt; dirtyRegionsLength / Marshal.SizeOf(typeof(RawRectangle)); dirtyIndex++)</a>
<a name="ln266">                    {</a>
<a name="ln267">                        //Crop screen positions and size to frame sizes.</a>
<a name="ln268">                        var left = Math.Max(dirtyRectangles[dirtyIndex].Left, Left - OffsetLeft);</a>
<a name="ln269">                        var right = Math.Min(dirtyRectangles[dirtyIndex].Right, Left + Width - OffsetLeft);</a>
<a name="ln270">                        var top = Math.Max(dirtyRectangles[dirtyIndex].Top, Top - OffsetTop);</a>
<a name="ln271">                        var bottom = Math.Min(dirtyRectangles[dirtyIndex].Bottom, Top + Height - OffsetTop);</a>
<a name="ln272"> </a>
<a name="ln273">                        //int left, right, top, bottom;</a>
<a name="ln274">                        //switch (DisplayRotation)</a>
<a name="ln275">                        //{</a>
<a name="ln276">                        //    case DisplayModeRotation.Rotate90:</a>
<a name="ln277">                        //    {</a>
<a name="ln278">                        //        //TODO:</a>
<a name="ln279">                        //        left = Math.Max(dirtyRectangles[dirtyIndex].Left, Left - OffsetLeft);</a>
<a name="ln280">                        //        right = Math.Min(dirtyRectangles[dirtyIndex].Right, Left + Width - OffsetLeft);</a>
<a name="ln281">                        //        top = Math.Max(dirtyRectangles[dirtyIndex].Top, Top - OffsetTop);</a>
<a name="ln282">                        //        bottom = Math.Min(dirtyRectangles[dirtyIndex].Bottom, Top + Height - OffsetTop);</a>
<a name="ln283"> </a>
<a name="ln284">                        //        //left = Math.Min(dirtyRectangles[dirtyIndex].Bottom, Top + Height - OffsetTop);</a>
<a name="ln285">                        //        //right = Math.Max(dirtyRectangles[dirtyIndex].Top, Top - OffsetTop);</a>
<a name="ln286">                        //        //top = Math.Max(dirtyRectangles[dirtyIndex].Left, Left - OffsetLeft);</a>
<a name="ln287">                        //        //bottom = Math.Min(dirtyRectangles[dirtyIndex].Right, Left + Width - OffsetLeft);</a>
<a name="ln288"> </a>
<a name="ln289">                        //        break;</a>
<a name="ln290">                        //    }</a>
<a name="ln291"> </a>
<a name="ln292">                        //    case DisplayModeRotation.Rotate180:</a>
<a name="ln293">                        //    {</a>
<a name="ln294">                        //        //TODO:</a>
<a name="ln295">                        //        left = Math.Max(dirtyRectangles[dirtyIndex].Top + OffsetTop, Top);</a>
<a name="ln296">                        //        right = Math.Min(dirtyRectangles[dirtyIndex].Bottom + OffsetTop, Top + Height);</a>
<a name="ln297">                        //        top = Math.Min(dirtyRectangles[dirtyIndex].Right + OffsetLeft, Left + Width);</a>
<a name="ln298">                        //        bottom = Math.Max(dirtyRectangles[dirtyIndex].Left + OffsetLeft, Left);</a>
<a name="ln299">                        //        break;</a>
<a name="ln300">                        //    }</a>
<a name="ln301"> </a>
<a name="ln302">                        //    default:</a>
<a name="ln303">                        //    {</a>
<a name="ln304">                        //        //In this context, the screen positions are relative to the current screen, not to the whole set of screens (virtual space).</a>
<a name="ln305">                        //        left = Math.Max(dirtyRectangles[dirtyIndex].Left, Left - OffsetLeft);</a>
<a name="ln306">                        //        right = Math.Min(dirtyRectangles[dirtyIndex].Right, Left + Width - OffsetLeft);</a>
<a name="ln307">                        //        top = Math.Max(dirtyRectangles[dirtyIndex].Top, Top - OffsetTop);</a>
<a name="ln308">                        //        bottom = Math.Min(dirtyRectangles[dirtyIndex].Bottom, Top + Height - OffsetTop);</a>
<a name="ln309">                        //        break;</a>
<a name="ln310">                        //    }</a>
<a name="ln311">                        //}</a>
<a name="ln312"> </a>
<a name="ln313">                        //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln314">                        if (right &gt; left &amp;&amp; bottom &gt; top)</a>
<a name="ln315">                            Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0, new ResourceRegion(left, top, 0, right, bottom, 1), BackingTexture, 0, left - (Left - OffsetLeft), top - (Top - OffsetTop));</a>
<a name="ln316">                    }</a>
<a name="ln317"> </a>
<a name="ln318">                    #endregion</a>
<a name="ln319">                }</a>
<a name="ln320">            }</a>
<a name="ln321"> </a>
<a name="ln322">            if (info.TotalMetadataBufferSize &gt; 0 || info.LastMouseUpdateTime &gt; 0)</a>
<a name="ln323">            {</a>
<a name="ln324">                //Copy the captured desktop texture into a staging texture, in order to show the mouse cursor and not make the captured texture dirty with it.</a>
<a name="ln325">                Device.ImmediateContext.CopyResource(BackingTexture, StagingTexture);</a>
<a name="ln326"> </a>
<a name="ln327">                //Gets the cursor image and merges with the staging texture.</a>
<a name="ln328">                GetCursor(StagingTexture, info, frame);</a>
<a name="ln329">            }</a>
<a name="ln330"> </a>
<a name="ln331">            //Saves the most recent capture time.</a>
<a name="ln332">            LastProcessTime = Math.Max(info.LastPresentTime, info.LastMouseUpdateTime);</a>
<a name="ln333"> </a>
<a name="ln334">            #endregion</a>
<a name="ln335"> </a>
<a name="ln336">            #region Gets the image data</a>
<a name="ln337"> </a>
<a name="ln338">            //Gets the staging texture as a stream.</a>
<a name="ln339">            var data = Device.ImmediateContext.MapSubresource(StagingTexture, 0, MapMode.Read, MapFlags.None, out var stream);</a>
<a name="ln340"> </a>
<a name="ln341">            if (data.IsEmpty)</a>
<a name="ln342">            {</a>
<a name="ln343">                Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln344">                stream?.Dispose();</a>
<a name="ln345">                resource?.Dispose();</a>
<a name="ln346">                return FrameCount;</a>
<a name="ln347">            }</a>
<a name="ln348"> </a>
<a name="ln349">            //Sets the frame details.</a>
<a name="ln350">            FrameCount++;</a>
<a name="ln351">            frame.Path = $&quot;{Project.FullPath}{FrameCount}.png&quot;;</a>
<a name="ln352">            frame.Delay = FrameRate.GetMilliseconds();</a>
<a name="ln353">            frame.DataLength = stream.Length;</a>
<a name="ln354">            frame.Data = new byte[stream.Length];</a>
<a name="ln355"> </a>
<a name="ln356">            //BGRA32 is 4 bytes.</a>
<a name="ln357">            for (var height = 0; height &lt; Height; height++)</a>
<a name="ln358">            {</a>
<a name="ln359">                stream.Position = height * data.RowPitch;</a>
<a name="ln360">                Marshal.Copy(new IntPtr(stream.DataPointer.ToInt64() + height * data.RowPitch), frame.Data, height * Width * 4, Width * 4);</a>
<a name="ln361">            }</a>
<a name="ln362"> </a>
<a name="ln363">            if (IsAcceptingFrames)</a>
<a name="ln364">                BlockingCollection.Add(frame);</a>
<a name="ln365"> </a>
<a name="ln366">            #endregion</a>
<a name="ln367"> </a>
<a name="ln368">            Device.ImmediateContext?.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln369">            stream.Dispose();</a>
<a name="ln370">            resource?.Dispose();</a>
<a name="ln371"> </a>
<a name="ln372">            return FrameCount;</a>
<a name="ln373">        }</a>
<a name="ln374">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.WaitTimeout.Result.Code)</a>
<a name="ln375">        {</a>
<a name="ln376">            return FrameCount;</a>
<a name="ln377">        }</a>
<a name="ln378">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceRemoved.Result.Code || se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceReset.Result.Code)</a>
<a name="ln379">        {</a>
<a name="ln380">            //When the device gets lost or reset, the resources should be instantiated again.</a>
<a name="ln381">            DisposeInternal();</a>
<a name="ln382">            Initialize();</a>
<a name="ln383"> </a>
<a name="ln384">            return FrameCount;</a>
<a name="ln385">        }</a>
<a name="ln386">        catch (Exception ex)</a>
<a name="ln387">        {</a>
<a name="ln388">            LogWriter.Log(ex, &quot;It was not possible to finish capturing the frame with DirectX.&quot;);</a>
<a name="ln389"> </a>
<a name="ln390">            MajorCrashHappened = true;</a>
<a name="ln391"> </a>
<a name="ln392">            if (IsAcceptingFrames)</a>
<a name="ln393">                Application.Current.Dispatcher.Invoke(() =&gt; OnError.Invoke(ex));</a>
<a name="ln394"> </a>
<a name="ln395">            return FrameCount;</a>
<a name="ln396">        }</a>
<a name="ln397">        finally</a>
<a name="ln398">        {</a>
<a name="ln399">            try</a>
<a name="ln400">            {</a>
<a name="ln401">                //Only release the frame if there was a success in capturing it.</a>
<a name="ln402">                if (res.Success)</a>
<a name="ln403">                    DuplicatedOutput.ReleaseFrame();</a>
<a name="ln404">            }</a>
<a name="ln405">            catch (Exception e)</a>
<a name="ln406">            {</a>
<a name="ln407">                LogWriter.Log(e, &quot;It was not possible to release the frame.&quot;);</a>
<a name="ln408">            }</a>
<a name="ln409">        }</a>
<a name="ln410">    }</a>
<a name="ln411"> </a>
<a name="ln412">    public override int ManualCapture(FrameInfo frame, bool showCursor = false)</a>
<a name="ln413">    {</a>
<a name="ln414">        var res = new Result(-1);</a>
<a name="ln415"> </a>
<a name="ln416">        try</a>
<a name="ln417">        {</a>
<a name="ln418">            //Try to get the duplicated output frame within given time.</a>
<a name="ln419">            res = DuplicatedOutput.TryAcquireNextFrame(1000, out var info, out var resource);</a>
<a name="ln420"> </a>
<a name="ln421">            //Checks how to proceed with the capture. It could have failed, or the screen, cursor or both could have been captured.</a>
<a name="ln422">            if (res.Failure || resource == null || (!showCursor &amp;&amp; info.AccumulatedFrames == 0) || (showCursor &amp;&amp; info.AccumulatedFrames == 0 &amp;&amp; info.LastMouseUpdateTime &lt;= LastProcessTime))</a>
<a name="ln423">            {</a>
<a name="ln424">                //Somehow, it was not possible to retrieve the resource, frame or metadata.</a>
<a name="ln425">                resource?.Dispose();</a>
<a name="ln426">                return FrameCount;</a>
<a name="ln427">            }</a>
<a name="ln428">            else if (showCursor &amp;&amp; info.AccumulatedFrames == 0 &amp;&amp; info.LastMouseUpdateTime &gt; LastProcessTime)</a>
<a name="ln429">            {</a>
<a name="ln430">                //Gets the cursor shape if the screen hasn't changed in between, so the cursor will be available for the next frame.</a>
<a name="ln431">                GetCursor(null, info, frame);</a>
<a name="ln432"> </a>
<a name="ln433">                resource.Dispose();</a>
<a name="ln434">                return FrameCount;</a>
<a name="ln435"> </a>
<a name="ln436">                //TODO: if only the mouse changed, but there's no frame accumulated, but there's data in the texture from the previous frame, I need to merge with the cursor and add to the list.</a>
<a name="ln437">            }</a>
<a name="ln438"> </a>
<a name="ln439">            //Saves the most recent capture time.</a>
<a name="ln440">            LastProcessTime = Math.Max(info.LastPresentTime, info.LastMouseUpdateTime);</a>
<a name="ln441"> </a>
<a name="ln442">            //Copy resource into memory that can be accessed by the CPU.</a>
<a name="ln443">            using (var screenTexture = resource.QueryInterface&lt;Texture2D&gt;())</a>
<a name="ln444">            {</a>
<a name="ln445">                if (showCursor)</a>
<a name="ln446">                {</a>
<a name="ln447">                    //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln448">                    Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0, new ResourceRegion(TrueLeft, TrueTop, 0, TrueRight, TrueBottom, 1), BackingTexture, 0);</a>
<a name="ln449"> </a>
<a name="ln450">                    //Copy the captured desktop texture into a staging texture, in order to show the mouse cursor and not make the captured texture dirty with it.</a>
<a name="ln451">                    Device.ImmediateContext.CopyResource(BackingTexture, StagingTexture);</a>
<a name="ln452"> </a>
<a name="ln453">                    //Gets the cursor image and merges with the staging texture.</a>
<a name="ln454">                    GetCursor(StagingTexture, info, frame);</a>
<a name="ln455">                }</a>
<a name="ln456">                else</a>
<a name="ln457">                {</a>
<a name="ln458">                    //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln459">                    Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0, new ResourceRegion(TrueLeft, TrueTop, 0, TrueRight, TrueBottom, 1), StagingTexture, 0);</a>
<a name="ln460">                }</a>
<a name="ln461">            }</a>
<a name="ln462"> </a>
<a name="ln463">            //Get the desktop capture texture.</a>
<a name="ln464">            var data = Device.ImmediateContext.MapSubresource(StagingTexture, 0, MapMode.Read, MapFlags.None, out var stream);</a>
<a name="ln465"> </a>
<a name="ln466">            if (data.IsEmpty)</a>
<a name="ln467">            {</a>
<a name="ln468">                Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln469">                stream?.Dispose();</a>
<a name="ln470">                resource.Dispose();</a>
<a name="ln471">                return FrameCount;</a>
<a name="ln472">            }</a>
<a name="ln473"> </a>
<a name="ln474">            #region Get image data</a>
<a name="ln475"> </a>
<a name="ln476">            //Set frame details.</a>
<a name="ln477">            FrameCount++;</a>
<a name="ln478">            frame.Path = $&quot;{Project.FullPath}{FrameCount}.png&quot;;</a>
<a name="ln479">            frame.Delay = FrameRate.GetMilliseconds();</a>
<a name="ln480">            frame.DataLength = stream.Length;</a>
<a name="ln481">            frame.Data = new byte[stream.Length];</a>
<a name="ln482"> </a>
<a name="ln483">            //BGRA32 is 4 bytes.</a>
<a name="ln484">            for (var height = 0; height &lt; Height; height++)</a>
<a name="ln485">            {</a>
<a name="ln486">                stream.Position = height * data.RowPitch;</a>
<a name="ln487">                Marshal.Copy(new IntPtr(stream.DataPointer.ToInt64() + height * data.RowPitch), frame.Data, height * Width * 4, Width * 4);</a>
<a name="ln488">            }</a>
<a name="ln489"> </a>
<a name="ln490">            BlockingCollection.Add(frame);</a>
<a name="ln491"> </a>
<a name="ln492">            #endregion</a>
<a name="ln493"> </a>
<a name="ln494">            Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln495">            stream.Dispose();</a>
<a name="ln496">            resource.Dispose();</a>
<a name="ln497"> </a>
<a name="ln498">            return FrameCount;</a>
<a name="ln499">        }</a>
<a name="ln500">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.WaitTimeout.Result.Code)</a>
<a name="ln501">        {</a>
<a name="ln502">            return FrameCount;</a>
<a name="ln503">        }</a>
<a name="ln504">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceRemoved.Result.Code || se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceReset.Result.Code)</a>
<a name="ln505">        {</a>
<a name="ln506">            //When the device gets lost or reset, the resources should be instantiated again.</a>
<a name="ln507">            DisposeInternal();</a>
<a name="ln508">            Initialize();</a>
<a name="ln509"> </a>
<a name="ln510">            return FrameCount;</a>
<a name="ln511">        }</a>
<a name="ln512">        catch (Exception ex)</a>
<a name="ln513">        {</a>
<a name="ln514">            LogWriter.Log(ex, &quot;It was not possible to finish capturing the frame with DirectX.&quot;);</a>
<a name="ln515"> </a>
<a name="ln516">            MajorCrashHappened = true;</a>
<a name="ln517"> </a>
<a name="ln518">            if (IsAcceptingFrames)</a>
<a name="ln519">                Application.Current.Dispatcher.Invoke(() =&gt; OnError.Invoke(ex));</a>
<a name="ln520"> </a>
<a name="ln521">            return FrameCount;</a>
<a name="ln522">        }</a>
<a name="ln523">        finally</a>
<a name="ln524">        {</a>
<a name="ln525">            try</a>
<a name="ln526">            {</a>
<a name="ln527">                //Only release the frame if there was a success in capturing it.</a>
<a name="ln528">                if (res.Success)</a>
<a name="ln529">                    DuplicatedOutput.ReleaseFrame();</a>
<a name="ln530">            }</a>
<a name="ln531">            catch (Exception e)</a>
<a name="ln532">            {</a>
<a name="ln533">                LogWriter.Log(e, &quot;It was not possible to release the frame.&quot;);</a>
<a name="ln534">            }</a>
<a name="ln535">        }</a>
<a name="ln536">    }</a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">    public override void Save(FrameInfo info)</a>
<a name="ln540">    {</a>
<a name="ln541">        System.Diagnostics.Debug.WriteLine(&quot;Length:&quot; + info.Data.Length + &quot; &quot; + _fileStream.Length);</a>
<a name="ln542"> </a>
<a name="ln543">        _compressStream.WriteBytes(info.Data);</a>
<a name="ln544">        _compressStream.Flush();</a>
<a name="ln545"> </a>
<a name="ln546">        info.Data = null;</a>
<a name="ln547"> </a>
<a name="ln548">        Project.Frames.Add(info);</a>
<a name="ln549">    }</a>
<a name="ln550"> </a>
<a name="ln551">    public override async Task Stop()</a>
<a name="ln552">    {</a>
<a name="ln553">        if (!WasStarted)</a>
<a name="ln554">            return;</a>
<a name="ln555"> </a>
<a name="ln556">        //Stop the recording first.</a>
<a name="ln557">        await base.Stop();</a>
<a name="ln558"> </a>
<a name="ln559">        //Then close the streams.</a>
<a name="ln560">        //await _compressStream.FlushAsync();</a>
<a name="ln561">        await _compressStream.DisposeAsync();</a>
<a name="ln562"> </a>
<a name="ln563">        await _bufferedStream.FlushAsync();</a>
<a name="ln564">        await _fileStream.FlushAsync();</a>
<a name="ln565"> </a>
<a name="ln566">        await _bufferedStream.DisposeAsync();</a>
<a name="ln567">        await _fileStream.DisposeAsync();</a>
<a name="ln568">    }</a>
<a name="ln569"> </a>
<a name="ln570"> </a>
<a name="ln571">    public int Capture2(FrameInfo frame)</a>
<a name="ln572">    {</a>
<a name="ln573">        var res = new Result(-1);</a>
<a name="ln574"> </a>
<a name="ln575">        try</a>
<a name="ln576">        {</a>
<a name="ln577">            //Try to get the duplicated output frame within given time.</a>
<a name="ln578">            res = DuplicatedOutput.TryAcquireNextFrame(0, out var info, out var resource);</a>
<a name="ln579"> </a>
<a name="ln580">            //Somehow, it was not possible to retrieve the resource or any frame.</a>
<a name="ln581">            if (res.Failure || resource == null || info.AccumulatedFrames == 0)</a>
<a name="ln582">            {</a>
<a name="ln583">                resource?.Dispose();</a>
<a name="ln584">                return FrameCount;</a>
<a name="ln585">            }</a>
<a name="ln586"> </a>
<a name="ln587">            //Copy resource into memory that can be accessed by the CPU.</a>
<a name="ln588">            using (var screenTexture = resource.QueryInterface&lt;Texture2D&gt;())</a>
<a name="ln589">            {</a>
<a name="ln590">                //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln591">                Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0, new ResourceRegion(TrueLeft, TrueTop, 0, TrueRight, TrueBottom, 1), StagingTexture, 0);</a>
<a name="ln592">            }</a>
<a name="ln593"> </a>
<a name="ln594">            //Get the desktop capture texture.</a>
<a name="ln595">            var data = Device.ImmediateContext.MapSubresource(StagingTexture, 0, MapMode.Read, MapFlags.None, out var stream);</a>
<a name="ln596"> </a>
<a name="ln597">            if (data.IsEmpty)</a>
<a name="ln598">            {</a>
<a name="ln599">                Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln600"> </a>
<a name="ln601">                stream?.Dispose();</a>
<a name="ln602">                resource.Dispose();</a>
<a name="ln603">                return FrameCount;</a>
<a name="ln604">            }</a>
<a name="ln605"> </a>
<a name="ln606">            #region Get image data</a>
<a name="ln607"> </a>
<a name="ln608">            //Set frame details.</a>
<a name="ln609">            FrameCount++;</a>
<a name="ln610">            frame.Path = $&quot;{Project.FullPath}{FrameCount}.png&quot;;</a>
<a name="ln611">            frame.Delay = FrameRate.GetMilliseconds();</a>
<a name="ln612">            frame.DataLength = stream.Length;</a>
<a name="ln613">            frame.Data = new byte[stream.Length];</a>
<a name="ln614"> </a>
<a name="ln615">            //BGRA32 is 4 bytes.</a>
<a name="ln616">            for (var height = 0; height &lt; Height; height++)</a>
<a name="ln617">            {</a>
<a name="ln618">                stream.Position = height * data.RowPitch;</a>
<a name="ln619">                Marshal.Copy(new IntPtr(stream.DataPointer.ToInt64() + height * data.RowPitch), frame.Data, height * Width * 4, Width * 4);</a>
<a name="ln620">            }</a>
<a name="ln621"> </a>
<a name="ln622">            BlockingCollection.Add(frame);</a>
<a name="ln623"> </a>
<a name="ln624">            #endregion</a>
<a name="ln625"> </a>
<a name="ln626">            Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln627"> </a>
<a name="ln628">            resource.Dispose();</a>
<a name="ln629">            return FrameCount;</a>
<a name="ln630">        }</a>
<a name="ln631">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.WaitTimeout.Result.Code)</a>
<a name="ln632">        {</a>
<a name="ln633">            return FrameCount;</a>
<a name="ln634">        }</a>
<a name="ln635">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceRemoved.Result.Code || se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceReset.Result.Code)</a>
<a name="ln636">        {</a>
<a name="ln637">            //When the device gets lost or reset, the resources should be instantiated again.</a>
<a name="ln638">            DisposeInternal();</a>
<a name="ln639">            Initialize();</a>
<a name="ln640"> </a>
<a name="ln641">            return FrameCount;</a>
<a name="ln642">        }</a>
<a name="ln643">        catch (Exception ex)</a>
<a name="ln644">        {</a>
<a name="ln645">            LogWriter.Log(ex, &quot;It was not possible to finish capturing the frame with DirectX.&quot;);</a>
<a name="ln646"> </a>
<a name="ln647">            Application.Current.Dispatcher.Invoke(() =&gt; OnError.Invoke(ex));</a>
<a name="ln648">            return FrameCount;</a>
<a name="ln649">        }</a>
<a name="ln650">        finally</a>
<a name="ln651">        {</a>
<a name="ln652">            try</a>
<a name="ln653">            {</a>
<a name="ln654">                //Only release the frame if there was a success in capturing it.</a>
<a name="ln655">                if (res.Success)</a>
<a name="ln656">                    DuplicatedOutput.ReleaseFrame();</a>
<a name="ln657">            }</a>
<a name="ln658">            catch (Exception e)</a>
<a name="ln659">            {</a>
<a name="ln660">                LogWriter.Log(e, &quot;It was not possible to release the frame.&quot;);</a>
<a name="ln661">            }</a>
<a name="ln662">        }</a>
<a name="ln663">    }</a>
<a name="ln664"> </a>
<a name="ln665">    public int CaptureWithCursor2(FrameInfo frame)</a>
<a name="ln666">    {</a>
<a name="ln667">        var res = new Result(-1);</a>
<a name="ln668"> </a>
<a name="ln669">        try</a>
<a name="ln670">        {</a>
<a name="ln671">            //Try to get the duplicated output frame within given time.</a>
<a name="ln672">            res = DuplicatedOutput.TryAcquireNextFrame(0, out var info, out var resource);</a>
<a name="ln673"> </a>
<a name="ln674">            //Checks how to proceed with the capture. It could have failed, or the screen, cursor or both could have been captured.</a>
<a name="ln675">            if (res.Failure || resource == null || (info.AccumulatedFrames == 0 &amp;&amp; info.LastMouseUpdateTime &lt;= LastProcessTime))</a>
<a name="ln676">            {</a>
<a name="ln677">                //Somehow, it was not possible to retrieve the resource, frame or metadata.</a>
<a name="ln678">                resource?.Dispose();</a>
<a name="ln679">                return FrameCount;</a>
<a name="ln680">            }</a>
<a name="ln681">            else if (info.AccumulatedFrames == 0 &amp;&amp; info.LastMouseUpdateTime &gt; LastProcessTime)</a>
<a name="ln682">            {</a>
<a name="ln683">                //Gets the cursor shape if the screen hasn't changed in between, so the cursor will be available for the next frame.</a>
<a name="ln684">                GetCursor(null, info, frame);</a>
<a name="ln685"> </a>
<a name="ln686">                resource.Dispose();</a>
<a name="ln687">                return FrameCount;</a>
<a name="ln688"> </a>
<a name="ln689">                //TODO: if only the mouse changed, but there's no frame accumulated, but there's data in the texture from the previous frame, I need to merge with the cursor and add to the list.</a>
<a name="ln690">            }</a>
<a name="ln691"> </a>
<a name="ln692">            //Saves the most recent capture time.</a>
<a name="ln693">            LastProcessTime = Math.Max(info.LastPresentTime, info.LastMouseUpdateTime);</a>
<a name="ln694"> </a>
<a name="ln695">            //Copy resource into memory that can be accessed by the CPU.</a>
<a name="ln696">            using (var screenTexture = resource.QueryInterface&lt;Texture2D&gt;())</a>
<a name="ln697">            {</a>
<a name="ln698">                //Copies from the screen texture only the area which the user wants to capture.</a>
<a name="ln699">                Device.ImmediateContext.CopySubresourceRegion(screenTexture, 0, new ResourceRegion(TrueLeft, TrueTop, 0, TrueRight, TrueBottom, 1), BackingTexture, 0);</a>
<a name="ln700"> </a>
<a name="ln701">                //Copy the captured desktop texture into a staging texture, in order to show the mouse cursor and not make the captured texture dirty with it.</a>
<a name="ln702">                Device.ImmediateContext.CopyResource(BackingTexture, StagingTexture);</a>
<a name="ln703"> </a>
<a name="ln704">                //Gets the cursor image and merges with the staging texture.</a>
<a name="ln705">                GetCursor(StagingTexture, info, frame);</a>
<a name="ln706">            }</a>
<a name="ln707"> </a>
<a name="ln708">            //Get the desktop capture texture.</a>
<a name="ln709">            var data = Device.ImmediateContext.MapSubresource(StagingTexture, 0, MapMode.Read, MapFlags.None, out var stream);</a>
<a name="ln710"> </a>
<a name="ln711">            if (data.IsEmpty)</a>
<a name="ln712">            {</a>
<a name="ln713">                Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln714">                stream?.Dispose();</a>
<a name="ln715">                resource.Dispose();</a>
<a name="ln716">                return FrameCount;</a>
<a name="ln717">            }</a>
<a name="ln718"> </a>
<a name="ln719">            #region Get image data</a>
<a name="ln720"> </a>
<a name="ln721">            //Set frame details.</a>
<a name="ln722">            FrameCount++;</a>
<a name="ln723">            frame.Path = $&quot;{Project.FullPath}{FrameCount}.png&quot;;</a>
<a name="ln724">            frame.Delay = FrameRate.GetMilliseconds();</a>
<a name="ln725">            frame.DataLength = stream.Length;</a>
<a name="ln726">            frame.Data = new byte[stream.Length];</a>
<a name="ln727"> </a>
<a name="ln728">            //BGRA32 is 4 bytes.</a>
<a name="ln729">            for (var height = 0; height &lt; Height; height++)</a>
<a name="ln730">            {</a>
<a name="ln731">                stream.Position = height * data.RowPitch;</a>
<a name="ln732">                Marshal.Copy(new IntPtr(stream.DataPointer.ToInt64() + height * data.RowPitch), frame.Data, height * Width * 4, Width * 4);</a>
<a name="ln733">            }</a>
<a name="ln734"> </a>
<a name="ln735">            BlockingCollection.Add(frame);</a>
<a name="ln736"> </a>
<a name="ln737">            #endregion</a>
<a name="ln738"> </a>
<a name="ln739">            Device.ImmediateContext.UnmapSubresource(StagingTexture, 0);</a>
<a name="ln740">            stream.Dispose();</a>
<a name="ln741">            resource.Dispose();</a>
<a name="ln742"> </a>
<a name="ln743">            return FrameCount;</a>
<a name="ln744">        }</a>
<a name="ln745">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.WaitTimeout.Result.Code)</a>
<a name="ln746">        {</a>
<a name="ln747">            return FrameCount;</a>
<a name="ln748">        }</a>
<a name="ln749">        catch (SharpDXException se) when (se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceRemoved.Result.Code || se.ResultCode.Code == SharpDX.DXGI.ResultCode.DeviceReset.Result.Code)</a>
<a name="ln750">        {</a>
<a name="ln751">            //When the device gets lost or reset, the resources should be instantiated again.</a>
<a name="ln752">            DisposeInternal();</a>
<a name="ln753">            Initialize();</a>
<a name="ln754"> </a>
<a name="ln755">            return FrameCount;</a>
<a name="ln756">        }</a>
<a name="ln757">        catch (Exception ex)</a>
<a name="ln758">        {</a>
<a name="ln759">            LogWriter.Log(ex, &quot;It was not possible to finish capturing the frame with DirectX.&quot;);</a>
<a name="ln760"> </a>
<a name="ln761">            MajorCrashHappened = true;</a>
<a name="ln762">            Application.Current.Dispatcher.Invoke(() =&gt; OnError.Invoke(ex));</a>
<a name="ln763">            return FrameCount;</a>
<a name="ln764">        }</a>
<a name="ln765">        finally</a>
<a name="ln766">        {</a>
<a name="ln767">            try</a>
<a name="ln768">            {</a>
<a name="ln769">                //Only release the frame if there was a success in capturing it.</a>
<a name="ln770">                if (res.Success)</a>
<a name="ln771">                    DuplicatedOutput.ReleaseFrame();</a>
<a name="ln772">            }</a>
<a name="ln773">            catch (Exception e)</a>
<a name="ln774">            {</a>
<a name="ln775">                LogWriter.Log(e, &quot;It was not possible to release the frame.&quot;);</a>
<a name="ln776">            }</a>
<a name="ln777">        }</a>
<a name="ln778">    }</a>
<a name="ln779">}</a>
</code></pre>
<div class="balloon" rel="132"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3095/" target="_blank">V3095</a> The 'Device.ImmediateContext' object was used before it was verified against null. Check lines: 132, 157.</p></div>
<div class="balloon" rel="343"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3095/" target="_blank">V3095</a> The 'Device.ImmediateContext' object was used before it was verified against null. Check lines: 343, 368.</p></div>
<div class="balloon" rel="71"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3125/" target="_blank">V3125</a> The 'resource' object was used after it was verified against null. Check lines: 71, 61.</p></div>
<div class="balloon" rel="142"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3125/" target="_blank">V3125</a> The 'stream' object was used after it was verified against null. Check lines: 142, 133.</p></div>
<div class="balloon" rel="230"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3125/" target="_blank">V3125</a> The 'resource' object was used after it was verified against null. Check lines: 230, 220.</p></div>
<div class="balloon" rel="353"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3125/" target="_blank">V3125</a> The 'stream' object was used after it was verified against null. Check lines: 353, 344.</p></div>
<div class="balloon" rel="480"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3125/" target="_blank">V3125</a> The 'stream' object was used after it was verified against null. Check lines: 480, 469.</p></div>
<div class="balloon" rel="612"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3125/" target="_blank">V3125</a> The 'stream' object was used after it was verified against null. Check lines: 612, 601.</p></div>
<div class="balloon" rel="725"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3125/" target="_blank">V3125</a> The 'stream' object was used after it was verified against null. Check lines: 725, 714.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>