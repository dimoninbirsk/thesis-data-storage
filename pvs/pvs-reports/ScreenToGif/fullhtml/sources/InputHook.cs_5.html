<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>InputHook.cs</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cs">
<a name="ln1">using System.ComponentModel;</a>
<a name="ln2">using System.Runtime.InteropServices;</a>
<a name="ln3">using System.Windows;</a>
<a name="ln4">using System.Windows.Input;</a>
<a name="ln5">using ScreenToGif.Domain.Enums.Native;</a>
<a name="ln6">using ScreenToGif.Domain.Events;</a>
<a name="ln7">using ScreenToGif.Domain.Models;</a>
<a name="ln8">using ScreenToGif.Native.External;</a>
<a name="ln9">using ScreenToGif.Native.Structs;</a>
<a name="ln10">using ScreenToGif.Util;</a>
<a name="ln11"> </a>
<a name="ln12">namespace ScreenToGif.Native.Helpers</a>
<a name="ln13">{</a>
<a name="ln14">    /// &lt;summary&gt;</a>
<a name="ln15">    /// This class allows you to tap keyboard and mouse and / or to detect their activity even when an</a>
<a name="ln16">    /// application runs in background or does not have any user interface at all. This class raises</a>
<a name="ln17">    /// common .NET events with KeyEventArgs and MouseEventArgs so you can easily retrieve any information you need.</a>
<a name="ln18">    /// &lt;/summary&gt;</a>
<a name="ln19">    public class InputHook</a>
<a name="ln20">    {</a>
<a name="ln21">        #region Windows constants from Winuser.h in Microsoft SDK.</a>
<a name="ln22"> </a>
<a name="ln23">        /// &lt;summary&gt;</a>
<a name="ln24">        /// Hook id for monitoring low-level mouse input events.</a>
<a name="ln25">        /// &lt;/summary&gt;</a>
<a name="ln26">        private const int HookMouseLowLevel = 14;</a>
<a name="ln27"> </a>
<a name="ln28">        /// &lt;summary&gt;</a>
<a name="ln29">        /// Hook id for monitoring low-level keyboard input events.</a>
<a name="ln30">        /// &lt;/summary&gt;</a>
<a name="ln31">        private const int HookKeyboardLowLevel = 13;</a>
<a name="ln32"> </a>
<a name="ln33">        /// &lt;summary&gt;</a>
<a name="ln34">        /// The WM_KEYDOWN message is posted to the window with the keyboard focus when a nonsystem</a>
<a name="ln35">        /// key is pressed. A nonsystem key is a key that is pressed when the ALT key is not pressed.</a>
<a name="ln36">        /// &lt;/summary&gt;</a>
<a name="ln37">        private const int MessageKeydown = 0x100;</a>
<a name="ln38"> </a>
<a name="ln39">        /// &lt;summary&gt;</a>
<a name="ln40">        /// The WM_KEYUP message is posted to the window with the keyboard focus when a nonsystem</a>
<a name="ln41">        /// key is released. A nonsystem key is a key that is pressed when the ALT key is not pressed,</a>
<a name="ln42">        /// or a keyboard key that is pressed when a window has the keyboard focus.</a>
<a name="ln43">        /// &lt;/summary&gt;</a>
<a name="ln44">        private const int MessageKeyUp = 0x101;</a>
<a name="ln45"> </a>
<a name="ln46">        /// &lt;summary&gt;</a>
<a name="ln47">        /// The WM_SYSKEYDOWN message is posted to the window with the keyboard focus when the user</a>
<a name="ln48">        /// presses the F10 key (which activates the menu bar) or holds down the ALT key and then</a>
<a name="ln49">        /// presses another key. It also occurs when no window currently has the keyboard focus;</a>
<a name="ln50">        /// in this case, the WM_SYSKEYDOWN message is sent to the active window. The window that</a>
<a name="ln51">        /// receives the message can distinguish between these two contexts by checking the context</a>
<a name="ln52">        /// code in the lParam parameter.</a>
<a name="ln53">        /// &lt;/summary&gt;</a>
<a name="ln54">        private const int MessageSystemKeyDown = 0x104;</a>
<a name="ln55"> </a>
<a name="ln56">        /// &lt;summary&gt;</a>
<a name="ln57">        /// The WM_SYSKEYUP message is posted to the window with the keyboard focus when the user</a>
<a name="ln58">        /// releases a key that was pressed while the ALT key was held down. It also occurs when no</a>
<a name="ln59">        /// window currently has the keyboard focus; in this case, the WM_SYSKEYUP message is sent</a>
<a name="ln60">        /// to the active window. The window that receives the message can distinguish between</a>
<a name="ln61">        /// these two contexts by checking the context code in the lParam parameter.</a>
<a name="ln62">        /// &lt;/summary&gt;</a>
<a name="ln63">        private const int MessageSystemKeyUp = 0x105;</a>
<a name="ln64"> </a>
<a name="ln65">        private const byte KeyShift = 0x10;</a>
<a name="ln66">        private const byte KeyCapital = 0x14;</a>
<a name="ln67">        private const byte KeyNumLock = 0x90;</a>
<a name="ln68"> </a>
<a name="ln69">        private const byte MouseFirstExtraButton = 0x0001;</a>
<a name="ln70">        private const byte MouseSecondExtraButton = 0x0002;</a>
<a name="ln71"> </a>
<a name="ln72">        #endregion</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">        #region Variables</a>
<a name="ln76"> </a>
<a name="ln77">        /// &lt;summary&gt;</a>
<a name="ln78">        /// Custom Mouse Event Handler.</a>
<a name="ln79">        /// &lt;/summary&gt;</a>
<a name="ln80">        public delegate void CustomMouseEventHandler(object sender, SimpleMouseGesture e);</a>
<a name="ln81"> </a>
<a name="ln82">        /// &lt;summary&gt;</a>
<a name="ln83">        /// Custom Key Event Handler.</a>
<a name="ln84">        /// &lt;/summary&gt;</a>
<a name="ln85">        public delegate void CustomKeyEventHandler(object sender, CustomKeyEventArgs e);</a>
<a name="ln86"> </a>
<a name="ln87">        /// &lt;summary&gt;</a>
<a name="ln88">        /// Custom KeyPress Event Handler.</a>
<a name="ln89">        /// &lt;/summary&gt;</a>
<a name="ln90">        public delegate void CustomKeyPressEventHandler(object sender, CustomKeyPressEventArgs e);</a>
<a name="ln91"> </a>
<a name="ln92">        /// &lt;summary&gt;</a>
<a name="ln93">        /// Custom KeyUp Event Handler.</a>
<a name="ln94">        /// &lt;/summary&gt;</a>
<a name="ln95">        public delegate void CustomKeyUpEventHandler(object sender, CustomKeyEventArgs e);</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">        /// &lt;summary&gt;</a>
<a name="ln99">        /// Occurs when the user moves the mouse, presses any mouse button or scrolls the wheel.</a>
<a name="ln100">        /// &lt;/summary&gt;</a>
<a name="ln101">        public event CustomMouseEventHandler OnMouseActivity;</a>
<a name="ln102"> </a>
<a name="ln103">        /// &lt;summary&gt;</a>
<a name="ln104">        /// Occurs when the user presses a key.</a>
<a name="ln105">        /// &lt;/summary&gt;</a>
<a name="ln106">        public event CustomKeyEventHandler KeyDown;</a>
<a name="ln107"> </a>
<a name="ln108">        ///// &lt;summary&gt;</a>
<a name="ln109">        ///// Occurs when the user presses and releases.</a>
<a name="ln110">        ///// &lt;/summary&gt;</a>
<a name="ln111">        public event CustomKeyPressEventHandler KeyPress;</a>
<a name="ln112"> </a>
<a name="ln113">        /// &lt;summary&gt;</a>
<a name="ln114">        /// Occurs when the user releases a key.</a>
<a name="ln115">        /// &lt;/summary&gt;</a>
<a name="ln116">        public event CustomKeyEventHandler KeyUp;</a>
<a name="ln117"> </a>
<a name="ln118">        /// &lt;summary&gt;</a>
<a name="ln119">        /// Stores the handle to the mouse hook procedure.</a>
<a name="ln120">        /// &lt;/summary&gt;</a>
<a name="ln121">        private int _mouseHookHandle = 0;</a>
<a name="ln122"> </a>
<a name="ln123">        /// &lt;summary&gt;</a>
<a name="ln124">        /// Stores the handle to the keyboard hook procedure.</a>
<a name="ln125">        /// &lt;/summary&gt;</a>
<a name="ln126">        private int _keyboardHookHandle = 0;</a>
<a name="ln127"> </a>
<a name="ln128">        /// &lt;summary&gt;</a>
<a name="ln129">        /// Declare MouseHookProcedure as HookProc type.</a>
<a name="ln130">        /// &lt;/summary&gt;</a>
<a name="ln131">        private static Delegates.HookProc _mouseHookProcedure;</a>
<a name="ln132"> </a>
<a name="ln133">        /// &lt;summary&gt;</a>
<a name="ln134">        /// Declare KeyboardHookProcedure as HookProc type.</a>
<a name="ln135">        /// &lt;/summary&gt;</a>
<a name="ln136">        private static Delegates.HookProc _keyboardHookProcedure;</a>
<a name="ln137"> </a>
<a name="ln138">        private MouseButtonState _leftButton = MouseButtonState.Released;</a>
<a name="ln139">        private MouseButtonState _rightButton = MouseButtonState.Released;</a>
<a name="ln140">        private MouseButtonState _middleButton = MouseButtonState.Released;</a>
<a name="ln141">        private MouseButtonState _extraButton = MouseButtonState.Released;</a>
<a name="ln142">        private MouseButtonState _extra2Button = MouseButtonState.Released;</a>
<a name="ln143"> </a>
<a name="ln144">        private static DateTime _lastClickTime;</a>
<a name="ln145">        private static int _clickCount;</a>
<a name="ln146">        private static bool _isDragging;</a>
<a name="ln147">        private static double _horizontalDragThreshold;</a>
<a name="ln148">        private static double _verticalDragThreshold;</a>
<a name="ln149">        private static PointW _dragStartPoint;</a>
<a name="ln150"> </a>
<a name="ln151">        #endregion</a>
<a name="ln152"> </a>
<a name="ln153">        #region Constructors</a>
<a name="ln154"> </a>
<a name="ln155">        /// &lt;summary&gt;</a>
<a name="ln156">        /// Creates an instance of UserActivityHook object and sets mouse and keyboard hooks.</a>
<a name="ln157">        /// &lt;/summary&gt;</a>
<a name="ln158">        /// &lt;exception cref=&quot;Win32Exception&quot;&gt;Any windows problem.&lt;/exception&gt;</a>
<a name="ln159">        public InputHook()</a>
<a name="ln160">        {</a>
<a name="ln161">            Start();</a>
<a name="ln162">        }</a>
<a name="ln163"> </a>
<a name="ln164">        /// &lt;summary&gt;</a>
<a name="ln165">        /// Creates an instance of UserActivityHook object and installs both or one of mouse and/or keyboard hooks and starts raising events</a>
<a name="ln166">        /// &lt;/summary&gt;</a>
<a name="ln167">        /// &lt;param name=&quot;installMouseHook&quot;&gt;&lt;b&gt;true&lt;/b&gt; if mouse events must be monitored&lt;/param&gt;</a>
<a name="ln168">        /// &lt;param name=&quot;installKeyboardHook&quot;&gt;&lt;b&gt;true&lt;/b&gt; if keyboard events must be monitored&lt;/param&gt;</a>
<a name="ln169">        /// &lt;exception cref=&quot;Win32Exception&quot;&gt;Any windows problem.&lt;/exception&gt;</a>
<a name="ln170">        /// &lt;remarks&gt;</a>
<a name="ln171">        /// To create an instance without installing hooks call new UserActivityHook(false, false)</a>
<a name="ln172">        /// &lt;/remarks&gt;</a>
<a name="ln173">        public InputHook(bool installMouseHook, bool installKeyboardHook)</a>
<a name="ln174">        {</a>
<a name="ln175">            Start(installMouseHook, installKeyboardHook);</a>
<a name="ln176">        }</a>
<a name="ln177"> </a>
<a name="ln178">        /// &lt;summary&gt;</a>
<a name="ln179">        /// Destruction.</a>
<a name="ln180">        /// &lt;/summary&gt;</a>
<a name="ln181">        ~InputHook()</a>
<a name="ln182">        {</a>
<a name="ln183">            //uninstall hooks and do not throw exceptions</a>
<a name="ln184">            Stop(true, true, false);</a>
<a name="ln185">        }</a>
<a name="ln186"> </a>
<a name="ln187">        #endregion</a>
<a name="ln188"> </a>
<a name="ln189">        #region Methods</a>
<a name="ln190"> </a>
<a name="ln191">        /// &lt;summary&gt;</a>
<a name="ln192">        /// Installs both mouse and keyboard hooks and starts raising events</a>
<a name="ln193">        /// &lt;/summary&gt;</a>
<a name="ln194">        /// &lt;exception cref=&quot;Win32Exception&quot;&gt;Any windows problem.&lt;/exception&gt;</a>
<a name="ln195">        public void Start()</a>
<a name="ln196">        {</a>
<a name="ln197">            Start(true, true);</a>
<a name="ln198">        }</a>
<a name="ln199"> </a>
<a name="ln200">        /// &lt;summary&gt;</a>
<a name="ln201">        /// Installs both or one of mouse and/or keyboard hooks and starts raising events</a>
<a name="ln202">        /// &lt;/summary&gt;</a>
<a name="ln203">        /// &lt;param name=&quot;installMouseHook&quot;&gt;&lt;b&gt;true&lt;/b&gt; if mouse events must be monitored&lt;/param&gt;</a>
<a name="ln204">        /// &lt;param name=&quot;installKeyboardHook&quot;&gt;&lt;b&gt;true&lt;/b&gt; if keyboard events must be monitored&lt;/param&gt;</a>
<a name="ln205">        /// &lt;exception cref=&quot;Win32Exception&quot;&gt;Any windows problem.&lt;/exception&gt;</a>
<a name="ln206">        public void Start(bool installMouseHook, bool installKeyboardHook)</a>
<a name="ln207">        {</a>
<a name="ln208">            //Install Mouse hook only if it is not installed and must be installed</a>
<a name="ln209">            if (_mouseHookHandle == 0 &amp;&amp; installMouseHook)</a>
<a name="ln210">            {</a>
<a name="ln211">                //Get minimum drag thresholds</a>
<a name="ln212">                _horizontalDragThreshold = SystemParameters.MinimumHorizontalDragDistance;</a>
<a name="ln213">                _verticalDragThreshold = SystemParameters.MinimumVerticalDragDistance;</a>
<a name="ln214"> </a>
<a name="ln215">                //Create an instance of HookProc.</a>
<a name="ln216">                _mouseHookProcedure = MouseHookProc;</a>
<a name="ln217"> </a>
<a name="ln218">                //Install hook.</a>
<a name="ln219">                _mouseHookHandle = User32.SetWindowsHookEx(HookMouseLowLevel, _mouseHookProcedure, IntPtr.Zero, 0);</a>
<a name="ln220"> </a>
<a name="ln221">                //If SetWindowsHookEx fails.</a>
<a name="ln222">                if (_mouseHookHandle == 0)</a>
<a name="ln223">                {</a>
<a name="ln224">                    //Returns the error code returned by the last unmanaged function called using platform invoke that has the DllImportAttribute.SetLastError flag set.</a>
<a name="ln225">                    var errorCode = Marshal.GetLastWin32Error();</a>
<a name="ln226"> </a>
<a name="ln227">                    //Cleans up.</a>
<a name="ln228">                    Stop(true, false, false);</a>
<a name="ln229"> </a>
<a name="ln230">                    //Initializes and throws a new instance of the Win32Exception class with the specified error.</a>
<a name="ln231">                    throw new Win32Exception(errorCode);</a>
<a name="ln232">                }</a>
<a name="ln233">            }</a>
<a name="ln234"> </a>
<a name="ln235">            //Install Keyboard hook only if it is not installed and must be installed</a>
<a name="ln236">            if (_keyboardHookHandle == 0 &amp;&amp; installKeyboardHook)</a>
<a name="ln237">            {</a>
<a name="ln238">                //Create an instance of HookProc.</a>
<a name="ln239">                _keyboardHookProcedure = KeyboardHookProc;</a>
<a name="ln240"> </a>
<a name="ln241">                //Install hook</a>
<a name="ln242">                _keyboardHookHandle = User32.SetWindowsHookEx(HookKeyboardLowLevel, _keyboardHookProcedure, IntPtr.Zero, 0);</a>
<a name="ln243"> </a>
<a name="ln244">                //If SetWindowsHookEx fails.</a>
<a name="ln245">                if (_keyboardHookHandle == 0)</a>
<a name="ln246">                {</a>
<a name="ln247">                    //Returns the error code returned by the last unmanaged function called using platform invoke that has the DllImportAttribute.SetLastError flag set.</a>
<a name="ln248">                    var errorCode = Marshal.GetLastWin32Error();</a>
<a name="ln249"> </a>
<a name="ln250">                    //Cleans up.</a>
<a name="ln251">                    Stop(false, true, false);</a>
<a name="ln252"> </a>
<a name="ln253">                    //Initializes and throws a new instance of the Win32Exception class with the specified error.</a>
<a name="ln254">                    throw new Win32Exception(errorCode);</a>
<a name="ln255">                }</a>
<a name="ln256">            }</a>
<a name="ln257">        }</a>
<a name="ln258"> </a>
<a name="ln259">        /// &lt;summary&gt;</a>
<a name="ln260">        /// Stops monitoring both mouse and keyboard events and raising events.</a>
<a name="ln261">        /// &lt;/summary&gt;</a>
<a name="ln262">        /// &lt;exception cref=&quot;Win32Exception&quot;&gt;Any windows problem.&lt;/exception&gt;</a>
<a name="ln263">        public void Stop()</a>
<a name="ln264">        {</a>
<a name="ln265">            Stop(true, true, true);</a>
<a name="ln266">        }</a>
<a name="ln267"> </a>
<a name="ln268">        /// &lt;summary&gt;</a>
<a name="ln269">        /// Stops monitoring both or one of mouse and/or keyboard events and raising events.</a>
<a name="ln270">        /// &lt;/summary&gt;</a>
<a name="ln271">        /// &lt;param name=&quot;uninstallMouseHook&quot;&gt;&lt;b&gt;true&lt;/b&gt; if mouse hook must be uninstalled&lt;/param&gt;</a>
<a name="ln272">        /// &lt;param name=&quot;uninstallKeyboardHook&quot;&gt;&lt;b&gt;true&lt;/b&gt; if keyboard hook must be uninstalled&lt;/param&gt;</a>
<a name="ln273">        /// &lt;param name=&quot;throwExceptions&quot;&gt;&lt;b&gt;true&lt;/b&gt; if exceptions which occurred during uninstalling must be thrown&lt;/param&gt;</a>
<a name="ln274">        /// &lt;exception cref=&quot;Win32Exception&quot;&gt;Any windows problem.&lt;/exception&gt;</a>
<a name="ln275">        public void Stop(bool uninstallMouseHook, bool uninstallKeyboardHook, bool throwExceptions)</a>
<a name="ln276">        {</a>
<a name="ln277">            //if mouse hook set and must be uninstalled</a>
<a name="ln278">            if (_mouseHookHandle != 0 &amp;&amp; uninstallMouseHook)</a>
<a name="ln279">            {</a>
<a name="ln280">                //Uninstalls the hook.</a>
<a name="ln281">                var retMouse = User32.UnhookWindowsHookEx(_mouseHookHandle);</a>
<a name="ln282"> </a>
<a name="ln283">                //Resets the invalid handle.</a>
<a name="ln284">                _mouseHookHandle = 0;</a>
<a name="ln285"> </a>
<a name="ln286">                //if failed and exception must be thrown.</a>
<a name="ln287">                if (retMouse == 0 &amp;&amp; throwExceptions)</a>
<a name="ln288">                {</a>
<a name="ln289">                    //Returns the error code returned by the last unmanaged function called using platform invoke that has the DllImportAttribute.SetLastError flag set.</a>
<a name="ln290">                    var errorCode = Marshal.GetLastWin32Error();</a>
<a name="ln291"> </a>
<a name="ln292">                    //Initializes and throws a new instance of the Win32Exception class with the specified error.</a>
<a name="ln293">                    throw new Win32Exception(errorCode);</a>
<a name="ln294">                }</a>
<a name="ln295">            }</a>
<a name="ln296"> </a>
<a name="ln297">            //If keyboard hook set and must be uninstalled</a>
<a name="ln298">            if (_keyboardHookHandle != 0 &amp;&amp; uninstallKeyboardHook)</a>
<a name="ln299">            {</a>
<a name="ln300">                //Uninstalls the hook.</a>
<a name="ln301">                var retKeyboard = User32.UnhookWindowsHookEx(_keyboardHookHandle);</a>
<a name="ln302"> </a>
<a name="ln303">                //Resets the invalid handle.</a>
<a name="ln304">                _keyboardHookHandle = 0;</a>
<a name="ln305"> </a>
<a name="ln306">                //If failed and exception must be thrown</a>
<a name="ln307">                if (retKeyboard == 0 &amp;&amp; throwExceptions)</a>
<a name="ln308">                {</a>
<a name="ln309">                    //Returns the error code returned by the last unmanaged function called using platform invoke that has the DllImportAttribute.SetLastError flag set.</a>
<a name="ln310">                    var errorCode = Marshal.GetLastWin32Error();</a>
<a name="ln311"> </a>
<a name="ln312">                    //Initializes and throws a new instance of the Win32Exception class with the specified error.</a>
<a name="ln313">                    throw new Win32Exception(errorCode);</a>
<a name="ln314">                }</a>
<a name="ln315">            }</a>
<a name="ln316">        }</a>
<a name="ln317"> </a>
<a name="ln318"> </a>
<a name="ln319">        private void DetectDoubleClick(NativeMouseEvents type, PointW point)</a>
<a name="ln320">        {</a>
<a name="ln321">            var deltaMs = DateTime.Now - _lastClickTime;</a>
<a name="ln322"> </a>
<a name="ln323">            _lastClickTime = DateTime.Now;</a>
<a name="ln324"> </a>
<a name="ln325">            if (deltaMs.TotalMilliseconds &lt;= User32.GetDoubleClickTime())</a>
<a name="ln326">                _clickCount++;</a>
<a name="ln327">            else</a>
<a name="ln328">                _clickCount = 1;</a>
<a name="ln329"> </a>
<a name="ln330">            if (_clickCount != 2)</a>
<a name="ln331">                return;</a>
<a name="ln332"> </a>
<a name="ln333">            OnMouseActivity?.Invoke(this, new SimpleMouseGesture(type, point.X, point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln334">            _clickCount = 0;</a>
<a name="ln335">        }</a>
<a name="ln336"> </a>
<a name="ln337">        /// &lt;summary&gt;</a>
<a name="ln338">        /// A callback function which will be called every time a mouse activity detected.</a>
<a name="ln339">        /// https://docs.microsoft.com/en-us/windows/win32/winmsg/lowlevelmouseproc</a>
<a name="ln340">        /// &lt;/summary&gt;</a>
<a name="ln341">        /// &lt;param name=&quot;code&quot;&gt;</a>
<a name="ln342">        /// Specifies whether the hook procedure must process the message.</a>
<a name="ln343">        /// If code is HC_ACTION, the hook procedure must process the message.</a>
<a name="ln344">        /// If code is less than zero, the hook procedure must pass the message to the</a>
<a name="ln345">        /// CallNextHookEx function without further processing and must return the value returned by CallNextHookEx.</a>
<a name="ln346">        /// &lt;/param&gt;</a>
<a name="ln347">        /// &lt;param name=&quot;type&quot;&gt;</a>
<a name="ln348">        /// Same as wParam. Specifies whether the message was sent by the current thread.</a>
<a name="ln349">        /// If the message was sent by the current thread, it is nonzero; otherwise, it is zero.</a>
<a name="ln350">        /// &lt;/param&gt;</a>
<a name="ln351">        /// &lt;param name=&quot;structure&quot;&gt;</a>
<a name="ln352">        /// Same as lParam. Pointer to a CWPSTRUCT structure that contains details about the message.</a>
<a name="ln353">        /// &lt;/param&gt;</a>
<a name="ln354">        /// &lt;returns&gt;</a>
<a name="ln355">        /// If nCode is less than zero, the hook procedure must return the value returned by CallNextHookEx.</a>
<a name="ln356">        /// If nCode is greater than or equal to zero, it is highly recommended that you call CallNextHookEx</a>
<a name="ln357">        /// and return the value it returns; otherwise, other applications that have installed WH_CALLWNDPROC</a>
<a name="ln358">        /// hooks will not receive hook notifications and may behave incorrectly as a result. If the hook</a>
<a name="ln359">        /// procedure does not call CallNextHookEx, the return value should be zero.</a>
<a name="ln360">        /// &lt;/returns&gt;</a>
<a name="ln361">        private IntPtr MouseHookProc(int code, uint type, IntPtr structure)</a>
<a name="ln362">        {</a>
<a name="ln363">            //If it's not Ok or no one listens to this event, call next hook.</a>
<a name="ln364">            if (code &lt; 0 || OnMouseActivity == null)</a>
<a name="ln365">                return User32.CallNextHookEx(_mouseHookHandle, code, type, structure);</a>
<a name="ln366"> </a>
<a name="ln367">            //Marshall the data from callback.</a>
<a name="ln368">            var mouse = (MouseHook) Marshal.PtrToStructure(structure, typeof(MouseHook));</a>
<a name="ln369">            var data = new WordLevel.WordUnion { Number = mouse.MouseData };</a>
<a name="ln370"> </a>
<a name="ln371">            #region Mouse actions</a>
<a name="ln372"> </a>
<a name="ln373">            switch ((NativeMouseEvents) type)</a>
<a name="ln374">            {</a>
<a name="ln375">                case NativeMouseEvents.MouseMove:</a>
<a name="ln376">                {</a>
<a name="ln377">                    if (!_isDragging &amp;&amp; _leftButton == MouseButtonState.Pressed)</a>
<a name="ln378">                    {</a>
<a name="ln379">                        var isXDragging = Math.Abs(mouse.Point.X - _dragStartPoint.X) &gt; SystemParameters.MinimumHorizontalDragDistance;</a>
<a name="ln380">                        var isYDragging = Math.Abs(mouse.Point.Y - _dragStartPoint.Y) &gt; SystemParameters.MinimumVerticalDragDistance;</a>
<a name="ln381"> </a>
<a name="ln382">                        _isDragging = isXDragging || isYDragging;</a>
<a name="ln383"> </a>
<a name="ln384">                        if (_isDragging)</a>
<a name="ln385">                        {</a>
<a name="ln386">                            OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.MouseDragStart, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln387">                            break;</a>
<a name="ln388">                        }</a>
<a name="ln389">                    }</a>
<a name="ln390"> </a>
<a name="ln391">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.MouseMove, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln392">                    break;</a>
<a name="ln393">                }</a>
<a name="ln394"> </a>
<a name="ln395">                case NativeMouseEvents.OutsideLeftButtonDown:</a>
<a name="ln396">                case NativeMouseEvents.LeftButtonDown:</a>
<a name="ln397">                {</a>
<a name="ln398">                    DetectDoubleClick(NativeMouseEvents.LeftButtonDoubleClick, mouse.Point);</a>
<a name="ln399"> </a>
<a name="ln400">                    _leftButton = MouseButtonState.Pressed;</a>
<a name="ln401">                    _dragStartPoint = mouse.Point;</a>
<a name="ln402"> </a>
<a name="ln403">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.LeftButtonDown, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln404">                    break;</a>
<a name="ln405">                }</a>
<a name="ln406"> </a>
<a name="ln407">                case NativeMouseEvents.OutsideLeftButtonUp:</a>
<a name="ln408">                case NativeMouseEvents.LeftButtonUp:</a>
<a name="ln409">                {</a>
<a name="ln410">                    //End drag.</a>
<a name="ln411">                    if (_isDragging)</a>
<a name="ln412">                    {</a>
<a name="ln413">                        OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.MouseDragEnd, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln414">                        _isDragging = false;</a>
<a name="ln415">                    }</a>
<a name="ln416"> </a>
<a name="ln417">                    _leftButton = MouseButtonState.Released;</a>
<a name="ln418">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.LeftButtonUp, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln419">                    break;</a>
<a name="ln420">                }</a>
<a name="ln421"> </a>
<a name="ln422">                case NativeMouseEvents.OutsideLeftButtonDoubleClick:</a>
<a name="ln423">                case NativeMouseEvents.LeftButtonDoubleClick:</a>
<a name="ln424">                {</a>
<a name="ln425">                    _leftButton = MouseButtonState.Pressed;</a>
<a name="ln426">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.LeftButtonDoubleClick, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln427">                    _leftButton = MouseButtonState.Released;</a>
<a name="ln428">                    break;</a>
<a name="ln429">                }</a>
<a name="ln430"> </a>
<a name="ln431">                case NativeMouseEvents.OutsideRightButtonDown:</a>
<a name="ln432">                case NativeMouseEvents.RightButtonDown:</a>
<a name="ln433">                {</a>
<a name="ln434">                    DetectDoubleClick(NativeMouseEvents.RightButtonDoubleClick, mouse.Point);</a>
<a name="ln435"> </a>
<a name="ln436">                    _rightButton = MouseButtonState.Pressed;</a>
<a name="ln437">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.RightButtonDown, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln438">                    break;</a>
<a name="ln439">                }</a>
<a name="ln440"> </a>
<a name="ln441">                case NativeMouseEvents.OutsideRightButtonUp:</a>
<a name="ln442">                case NativeMouseEvents.RightButtonUp:</a>
<a name="ln443">                {</a>
<a name="ln444">                    _rightButton = MouseButtonState.Released;</a>
<a name="ln445">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.RightButtonUp, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln446">                    break;</a>
<a name="ln447">                }</a>
<a name="ln448"> </a>
<a name="ln449">                case NativeMouseEvents.OutsideRightButtonDoubleClick:</a>
<a name="ln450">                case NativeMouseEvents.RightButtonDoubleClick:</a>
<a name="ln451">                {</a>
<a name="ln452">                    _rightButton = MouseButtonState.Pressed;</a>
<a name="ln453">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.RightButtonDoubleClick, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln454">                    _rightButton = MouseButtonState.Released;</a>
<a name="ln455">                    break;</a>
<a name="ln456">                }</a>
<a name="ln457"> </a>
<a name="ln458">                case NativeMouseEvents.OutsideMiddleButtonDown:</a>
<a name="ln459">                case NativeMouseEvents.MiddleButtonDown:</a>
<a name="ln460">                {</a>
<a name="ln461">                    DetectDoubleClick(NativeMouseEvents.MiddleButtonDoubleClick, mouse.Point);</a>
<a name="ln462"> </a>
<a name="ln463">                    _middleButton = MouseButtonState.Pressed;</a>
<a name="ln464">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.MiddleButtonDown, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln465">                    break;</a>
<a name="ln466">                }</a>
<a name="ln467"> </a>
<a name="ln468">                case NativeMouseEvents.OutsideMiddleButtonUp:</a>
<a name="ln469">                case NativeMouseEvents.MiddleButtonUp:</a>
<a name="ln470">                {</a>
<a name="ln471">                    _middleButton = MouseButtonState.Released;</a>
<a name="ln472">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.MiddleButtonUp, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln473">                    break;</a>
<a name="ln474">                }</a>
<a name="ln475"> </a>
<a name="ln476">                case NativeMouseEvents.OutsideMiddleButtonDoubleClick:</a>
<a name="ln477">                case NativeMouseEvents.MiddleButtonDoubleClick:</a>
<a name="ln478">                {</a>
<a name="ln479">                    _middleButton = MouseButtonState.Pressed;</a>
<a name="ln480">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.MiddleButtonDoubleClick, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln481">                    _middleButton = MouseButtonState.Released;</a>
<a name="ln482">                    break;</a>
<a name="ln483">                }</a>
<a name="ln484"> </a>
<a name="ln485">                case NativeMouseEvents.MouseWheel:</a>
<a name="ln486">                {</a>
<a name="ln487">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.MouseWheel, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button, data.High));</a>
<a name="ln488">                    break;</a>
<a name="ln489">                }</a>
<a name="ln490"> </a>
<a name="ln491">                case NativeMouseEvents.MouseWheelHorizontal:</a>
<a name="ln492">                {</a>
<a name="ln493">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.MouseWheelHorizontal, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button, data.High));</a>
<a name="ln494">                    break;</a>
<a name="ln495">                }</a>
<a name="ln496"> </a>
<a name="ln497">                case NativeMouseEvents.OutsideExtraButtonDown:</a>
<a name="ln498">                case NativeMouseEvents.ExtraButtonDown:</a>
<a name="ln499">                {</a>
<a name="ln500">                    DetectDoubleClick(NativeMouseEvents.ExtraButtonDoubleClick, mouse.Point);</a>
<a name="ln501"> </a>
<a name="ln502">                    if (data.High == MouseFirstExtraButton)</a>
<a name="ln503">                        _extraButton = MouseButtonState.Pressed;</a>
<a name="ln504">                    else</a>
<a name="ln505">                        _extra2Button = MouseButtonState.Pressed;</a>
<a name="ln506"> </a>
<a name="ln507">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.ExtraButtonDown, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln508">                    break;</a>
<a name="ln509">                }</a>
<a name="ln510"> </a>
<a name="ln511">                case NativeMouseEvents.OutsideExtraButtonDoubleClick:</a>
<a name="ln512">                case NativeMouseEvents.ExtraButtonDoubleClick:</a>
<a name="ln513">                {</a>
<a name="ln514">                    if (data.High == MouseFirstExtraButton)</a>
<a name="ln515">                        _extraButton = MouseButtonState.Pressed;</a>
<a name="ln516">                    else</a>
<a name="ln517">                        _extra2Button = MouseButtonState.Pressed;</a>
<a name="ln518"> </a>
<a name="ln519">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.ExtraButtonDoubleClick, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln520"> </a>
<a name="ln521">                    if (data.High == MouseFirstExtraButton)</a>
<a name="ln522">                        _extraButton = MouseButtonState.Released;</a>
<a name="ln523">                    else</a>
<a name="ln524">                        _extra2Button = MouseButtonState.Released;</a>
<a name="ln525">                    break;</a>
<a name="ln526">                }</a>
<a name="ln527"> </a>
<a name="ln528">                case NativeMouseEvents.OutsideExtraButtonUp:</a>
<a name="ln529">                case NativeMouseEvents.ExtraButtonUp:</a>
<a name="ln530">                {</a>
<a name="ln531">                    if (data.High == MouseFirstExtraButton)</a>
<a name="ln532">                        _extraButton = MouseButtonState.Released;</a>
<a name="ln533">                    else</a>
<a name="ln534">                        _extra2Button = MouseButtonState.Released;</a>
<a name="ln535"> </a>
<a name="ln536">                    OnMouseActivity?.Invoke(this, new SimpleMouseGesture(NativeMouseEvents.ExtraButtonUp, mouse.Point.X, mouse.Point.Y, _leftButton, _rightButton, _middleButton, _extraButton, _extra2Button));</a>
<a name="ln537">                    break;</a>
<a name="ln538">                }</a>
<a name="ln539"> </a>
<a name="ln540">                //default: I can't return now, it will break the click detector.</a>
<a name="ln541">                //return CallNextHookEx(hMouseHook, nCode, wParam, lParam);</a>
<a name="ln542">                //HU3HU3 - A little funny momment: I just frooze my cursor by returning 1 instead of calling the next hook. - Nicke</a>
<a name="ln543">                //Congrats to myself. ;D</a>
<a name="ln544">                //05:24 AM 01/02/2014 (day-month-year)</a>
<a name="ln545">            }</a>
<a name="ln546"> </a>
<a name="ln547">            #endregion</a>
<a name="ln548"> </a>
<a name="ln549">            //Call the next hook.</a>
<a name="ln550">            return User32.CallNextHookEx(_mouseHookHandle, code, type, structure);</a>
<a name="ln551">        }</a>
<a name="ln552"> </a>
<a name="ln553">        /// &lt;summary&gt;</a>
<a name="ln554">        /// A callback function which will be called every time a keyboard activity detected.</a>
<a name="ln555">        /// https://docs.microsoft.com/en-us/windows/win32/winmsg/lowlevelkeyboardproc</a>
<a name="ln556">        /// &lt;/summary&gt;</a>
<a name="ln557">        /// &lt;param name=&quot;code&quot;&gt;</a>
<a name="ln558">        /// Specifies whether the hook procedure must process the message.</a>
<a name="ln559">        /// If code is HC_ACTION, the hook procedure must process the message.</a>
<a name="ln560">        /// If code is less than zero, the hook procedure must pass the message to the</a>
<a name="ln561">        /// CallNextHookEx function without further processing and must return the</a>
<a name="ln562">        /// value returned by CallNextHookEx.</a>
<a name="ln563">        /// &lt;/param&gt;</a>
<a name="ln564">        /// &lt;param name=&quot;wParam&quot;&gt;</a>
<a name="ln565">        /// Specifies whether the message was sent by the current thread.</a>
<a name="ln566">        /// If the message was sent by the current thread, it is nonzero; otherwise, it is zero.</a>
<a name="ln567">        /// &lt;/param&gt;</a>
<a name="ln568">        /// &lt;param name=&quot;lParam&quot;&gt;</a>
<a name="ln569">        /// Pointer to a CWPSTRUCT structure that contains details about the message.</a>
<a name="ln570">        /// &lt;/param&gt;</a>
<a name="ln571">        /// &lt;returns&gt;</a>
<a name="ln572">        /// If code is less than zero, the hook procedure must return the value returned by CallNextHookEx.</a>
<a name="ln573">        /// If code is greater than or equal to zero, it is highly recommended that you call CallNextHookEx</a>
<a name="ln574">        /// and return the value it returns; otherwise, other applications that have installed WH_CALLWNDPROC</a>
<a name="ln575">        /// hooks will not receive hook notifications and may behave incorrectly as a result. If the hook</a>
<a name="ln576">        /// procedure does not call CallNextHookEx, the return value should be zero.</a>
<a name="ln577">        /// &lt;/returns&gt;</a>
<a name="ln578">        private IntPtr KeyboardHookProc(int code, uint wParam, IntPtr lParam)</a>
<a name="ln579">        {</a>
<a name="ln580">            //Indicates if any of the underlying events set the e.Handled flag.</a>
<a name="ln581">            var handled = false;</a>
<a name="ln582"> </a>
<a name="ln583">            //If it was Ok and there are no listeners.</a>
<a name="ln584">            if (code &lt; 0 || KeyDown == null &amp;&amp; KeyUp == null &amp;&amp; KeyPress == null)</a>
<a name="ln585">                return User32.CallNextHookEx(_keyboardHookHandle, code, wParam, lParam);</a>
<a name="ln586"> </a>
<a name="ln587">            //Read structure KeyboardHookStruct at lParam</a>
<a name="ln588">            var keyboard = (KeyboardHook)Marshal.PtrToStructure(lParam, typeof(KeyboardHook));</a>
<a name="ln589">            var isInjected = (keyboard.Flags &amp; 0x10) != 0;</a>
<a name="ln590"> </a>
<a name="ln591">            if (KeyDown != null &amp;&amp; (wParam == MessageKeydown || wParam == MessageSystemKeyDown))</a>
<a name="ln592">            {</a>
<a name="ln593">                #region Raise KeyDown</a>
<a name="ln594"> </a>
<a name="ln595">                var isDownShift = (User32.GetKeyState(KeyShift) &amp; 0x80) == 0x80;</a>
<a name="ln596">                var isDownCapslock = User32.GetKeyState(KeyCapital) != 0;</a>
<a name="ln597"> </a>
<a name="ln598"> </a>
<a name="ln599">                var e = new CustomKeyEventArgs(KeyInterop.KeyFromVirtualKey(keyboard.KeyCode), isDownCapslock ^ isDownShift, isInjected);</a>
<a name="ln600"> </a>
<a name="ln601">                KeyDown?.Invoke(this, e);</a>
<a name="ln602"> </a>
<a name="ln603">                handled = e.Handled;</a>
<a name="ln604"> </a>
<a name="ln605">                #endregion</a>
<a name="ln606">            }</a>
<a name="ln607"> </a>
<a name="ln608">            if (KeyPress != null &amp;&amp; wParam == MessageKeydown)</a>
<a name="ln609">            {</a>
<a name="ln610">                #region Raise KeyPress</a>
<a name="ln611"> </a>
<a name="ln612">                var isDownShift = (User32.GetKeyState(KeyShift) &amp; 0x80) == 0x80;</a>
<a name="ln613">                var isDownCapslock = User32.GetKeyState(KeyCapital) != 0;</a>
<a name="ln614"> </a>
<a name="ln615">                var keyState = new byte[256];</a>
<a name="ln616">                User32.GetKeyboardState(keyState);</a>
<a name="ln617">                var inBuffer = new byte[2];</a>
<a name="ln618"> </a>
<a name="ln619">                if (User32.ToAscii(keyboard.KeyCode, keyboard.ScanCode, keyState, inBuffer, keyboard.Flags) == 1)</a>
<a name="ln620">                {</a>
<a name="ln621">                    var key = (char)inBuffer[0];</a>
<a name="ln622">                    if (isDownCapslock ^ isDownShift &amp;&amp; char.IsLetter(key))</a>
<a name="ln623">                        key = char.ToUpper(key);</a>
<a name="ln624"> </a>
<a name="ln625">                    var e = new CustomKeyPressEventArgs(key);</a>
<a name="ln626">                    KeyPress?.Invoke(this, e);</a>
<a name="ln627"> </a>
<a name="ln628">                    handled = handled || e.Handled;</a>
<a name="ln629">                }</a>
<a name="ln630"> </a>
<a name="ln631">                #endregion</a>
<a name="ln632">            }</a>
<a name="ln633"> </a>
<a name="ln634">            if (KeyUp != null &amp;&amp; (wParam == MessageKeyUp || wParam == MessageSystemKeyUp))</a>
<a name="ln635">            {</a>
<a name="ln636">                #region Raise KeyUp</a>
<a name="ln637"> </a>
<a name="ln638">                var e = new CustomKeyEventArgs(KeyInterop.KeyFromVirtualKey(keyboard.KeyCode), false, isInjected);</a>
<a name="ln639"> </a>
<a name="ln640">                KeyUp?.Invoke(this, e);</a>
<a name="ln641"> </a>
<a name="ln642">                handled = handled || e.Handled;</a>
<a name="ln643"> </a>
<a name="ln644">                #endregion</a>
<a name="ln645">            }</a>
<a name="ln646"> </a>
<a name="ln647">            //If event handled in application do not handoff to other listeners.</a>
<a name="ln648">            return handled ? new IntPtr(1) : User32.CallNextHookEx(_keyboardHookHandle, code, wParam, lParam);</a>
<a name="ln649">        }</a>
<a name="ln650"> </a>
<a name="ln651">        #endregion</a>
<a name="ln652">    }</a>
<a name="ln653">}</a>
</code></pre>
<div class="balloon" rel="373"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3002/" target="_blank">V3002</a> The switch statement does not cover all values of the 'NativeMouseEvents' enum: MouseDragStart, MouseDragEnd.</p></div>
<div class="balloon" rel="584"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3130/" target="_blank">V3130</a> Priority of the '&amp;&amp;' operator is higher than that of the '||' operator. Possible missing parentheses.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>