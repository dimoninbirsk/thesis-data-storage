<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>SkipLocalsInit_Benchmark.cs</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cs">
<a name="ln1">﻿/*</a>
<a name="ln2"> *  BenchmarkDotNet v0.13.10, Ubuntu 22.04.3 LTS (Jammy Jellyfish)</a>
<a name="ln3"> *  AMD EPYC 7763, 1 CPU, 4 logical and 2 physical cores</a>
<a name="ln4"> *  .NET SDK 8.0.100</a>
<a name="ln5"> *    [Host]     : .NET 8.0.0 (8.0.23.53103), X64 RyuJIT AVX2</a>
<a name="ln6"> *    DefaultJob : .NET 8.0.0 (8.0.23.53103), X64 RyuJIT AVX2</a>
<a name="ln7"> *</a>
<a name="ln8"> *  | Method                         | Mean     | Error     | StdDev    | Ratio | Gen0     | Gen1     | Gen2     | Allocated | Alloc Ratio |</a>
<a name="ln9"> *  |------------------------------- |---------:|----------:|----------:|------:|---------:|---------:|---------:|----------:|------------:|</a>
<a name="ln10"> *  | AttackGenerator_Original       | 5.575 ms | 0.0278 ms | 0.0260 ms |  1.00 | 484.3750 | 484.3750 | 484.3750 |   2.25 MB |        1.00 |</a>
<a name="ln11"> *  | AttackGenerator_SkipLocalsInit | 5.574 ms | 0.0250 ms | 0.0222 ms |  1.00 | 468.7500 | 468.7500 | 468.7500 |   2.25 MB |        1.00 |</a>
<a name="ln12"> *  | AttackGenerator_Other          | 5.573 ms | 0.0333 ms | 0.0312 ms |  1.00 | 468.7500 | 468.7500 | 468.7500 |   2.25 MB |        1.00 |</a>
<a name="ln13"> */</a>
<a name="ln14"> </a>
<a name="ln15">using BenchmarkDotNet.Attributes;</a>
<a name="ln16">using Lynx.Model;</a>
<a name="ln17">using System.Runtime.CompilerServices;</a>
<a name="ln18"> </a>
<a name="ln19">namespace Lynx.Benchmark;</a>
<a name="ln20"> </a>
<a name="ln21">public class SkipLocalsInit_Benchmark : BaseBenchmark</a>
<a name="ln22">{</a>
<a name="ln23">    [Benchmark(Baseline = true)]</a>
<a name="ln24">    public ulong AttackGenerator_Original()</a>
<a name="ln25">    {</a>
<a name="ln26">        var KingAttacks = SkipLocalsInit_AttackGenerator_Original.InitializeKingAttacks();</a>
<a name="ln27">        var PawnAttacks = SkipLocalsInit_AttackGenerator_Original.InitializePawnAttacks();</a>
<a name="ln28">        var KnightAttacks = SkipLocalsInit_AttackGenerator_Original.InitializeKnightAttacks();</a>
<a name="ln29"> </a>
<a name="ln30">        var bishopOcuppancy = SkipLocalsInit_AttackGenerator_Original.InitializeBishopOccupancy();</a>
<a name="ln31">        var rookOcuppancy = SkipLocalsInit_AttackGenerator_Original.InitializeRookOccupancy();</a>
<a name="ln32"> </a>
<a name="ln33">        (var _bishopOccupancyMasks, var _bishopAttacks) = SkipLocalsInit_AttackGenerator_Original.InitializeBishopMagicAttacks();</a>
<a name="ln34">        (var _rookOccupancyMasks, var _rookAttacks) = SkipLocalsInit_AttackGenerator_Original.InitializeRookMagicAttacks();</a>
<a name="ln35"> </a>
<a name="ln36">        return KingAttacks[0] ^ PawnAttacks[0][0] ^ KnightAttacks[0] ^ _bishopOccupancyMasks[0]</a>
<a name="ln37">            ^ _rookOccupancyMasks[0] ^ _bishopAttacks[0, 0] ^ _rookAttacks[0, 0]</a>
<a name="ln38">            ^ bishopOcuppancy[0] ^ rookOcuppancy[0];</a>
<a name="ln39">    }</a>
<a name="ln40"> </a>
<a name="ln41">    [Benchmark]</a>
<a name="ln42">    public ulong AttackGenerator_SkipLocalsInit()</a>
<a name="ln43">    {</a>
<a name="ln44">        var KingAttacks = SkipLocalsInit_AttackGenerator_SkipLocalsInit.InitializeKingAttacks();</a>
<a name="ln45">        var PawnAttacks = SkipLocalsInit_AttackGenerator_SkipLocalsInit.InitializePawnAttacks();</a>
<a name="ln46">        var KnightAttacks = SkipLocalsInit_AttackGenerator_SkipLocalsInit.InitializeKnightAttacks();</a>
<a name="ln47"> </a>
<a name="ln48">        var bishopOcuppancy = SkipLocalsInit_AttackGenerator_SkipLocalsInit.InitializeBishopOccupancy();</a>
<a name="ln49">        var rookOcuppancy = SkipLocalsInit_AttackGenerator_SkipLocalsInit.InitializeRookOccupancy();</a>
<a name="ln50"> </a>
<a name="ln51">        (var _bishopOccupancyMasks, var _bishopAttacks) = SkipLocalsInit_AttackGenerator_SkipLocalsInit.InitializeBishopMagicAttacks();</a>
<a name="ln52">        (var _rookOccupancyMasks, var _rookAttacks) = SkipLocalsInit_AttackGenerator_SkipLocalsInit.InitializeRookMagicAttacks();</a>
<a name="ln53"> </a>
<a name="ln54">        return KingAttacks[0] ^ PawnAttacks[0, 0] ^ KnightAttacks[0] ^ _bishopOccupancyMasks[0]</a>
<a name="ln55">            ^ _rookOccupancyMasks[0] ^ _bishopAttacks[0, 0] ^ _rookAttacks[0, 0]</a>
<a name="ln56">            ^ bishopOcuppancy[0] ^ rookOcuppancy[0];</a>
<a name="ln57">    }</a>
<a name="ln58"> </a>
<a name="ln59">    [Benchmark]</a>
<a name="ln60">    public ulong AttackGenerator_Other()</a>
<a name="ln61">    {</a>
<a name="ln62">        var KingAttacks = SkipLocalsInit_AttackGenerator_Other.InitializeKingAttacks();</a>
<a name="ln63">        var PawnAttacks = SkipLocalsInit_AttackGenerator_Other.InitializePawnAttacks();</a>
<a name="ln64">        var KnightAttacks = SkipLocalsInit_AttackGenerator_Other.InitializeKnightAttacks();</a>
<a name="ln65"> </a>
<a name="ln66">        var bishopOcuppancy = SkipLocalsInit_AttackGenerator_Other.InitializeBishopOccupancy();</a>
<a name="ln67">        var rookOcuppancy = SkipLocalsInit_AttackGenerator_Other.InitializeRookOccupancy();</a>
<a name="ln68"> </a>
<a name="ln69">        (var _bishopOccupancyMasks, var _bishopAttacks) = SkipLocalsInit_AttackGenerator_Other.InitializeBishopMagicAttacks();</a>
<a name="ln70">        (var _rookOccupancyMasks, var _rookAttacks) = SkipLocalsInit_AttackGenerator_Other.InitializeRookMagicAttacks();</a>
<a name="ln71"> </a>
<a name="ln72">        return KingAttacks[0] ^ PawnAttacks[0][0] ^ KnightAttacks[0] ^ _bishopOccupancyMasks[0]</a>
<a name="ln73">            ^ _rookOccupancyMasks[0] ^ _bishopAttacks[0, 0] ^ _rookAttacks[0, 0]</a>
<a name="ln74">            ^ bishopOcuppancy[0] ^ rookOcuppancy[0];</a>
<a name="ln75">    }</a>
<a name="ln76"> </a>
<a name="ln77">    private static class SkipLocalsInit_AttackGenerator_Original</a>
<a name="ln78">    {</a>
<a name="ln79">        /// &lt;summary&gt;</a>
<a name="ln80">        /// BitBoard[isWhite, square]</a>
<a name="ln81">        /// &lt;/summary&gt;</a>
<a name="ln82">        public static BitBoard[][] InitializePawnAttacks()</a>
<a name="ln83">        {</a>
<a name="ln84">            BitBoard[][] pawnAttacks = [new BitBoard[64], new BitBoard[64]];</a>
<a name="ln85"> </a>
<a name="ln86">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln87">            {</a>
<a name="ln88">                pawnAttacks[0][square] = MaskPawnAttacks(square, isWhite: false);</a>
<a name="ln89">                pawnAttacks[1][square] = MaskPawnAttacks(square, isWhite: true);</a>
<a name="ln90">            }</a>
<a name="ln91"> </a>
<a name="ln92">            return pawnAttacks;</a>
<a name="ln93">        }</a>
<a name="ln94"> </a>
<a name="ln95">        public static BitBoard[] InitializeKnightAttacks()</a>
<a name="ln96">        {</a>
<a name="ln97">            BitBoard[] knightAttacks = new BitBoard[64];</a>
<a name="ln98"> </a>
<a name="ln99">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln100">            {</a>
<a name="ln101">                knightAttacks[square] = MaskKnightAttacks(square);</a>
<a name="ln102">            }</a>
<a name="ln103"> </a>
<a name="ln104">            return knightAttacks;</a>
<a name="ln105">        }</a>
<a name="ln106"> </a>
<a name="ln107">        public static BitBoard[] InitializeKingAttacks()</a>
<a name="ln108">        {</a>
<a name="ln109">            BitBoard[] kingAttacks = new BitBoard[64];</a>
<a name="ln110"> </a>
<a name="ln111">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln112">            {</a>
<a name="ln113">                kingAttacks[square] = MaskKingAttacks(square);</a>
<a name="ln114">            }</a>
<a name="ln115"> </a>
<a name="ln116">            return kingAttacks;</a>
<a name="ln117">        }</a>
<a name="ln118"> </a>
<a name="ln119">        public static BitBoard[] InitializeBishopOccupancy()</a>
<a name="ln120">        {</a>
<a name="ln121">            BitBoard[] bishopAttacks = new BitBoard[64];</a>
<a name="ln122"> </a>
<a name="ln123">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln124">            {</a>
<a name="ln125">                bishopAttacks[square] = MaskBishopOccupancy(square);</a>
<a name="ln126">            }</a>
<a name="ln127"> </a>
<a name="ln128">            return bishopAttacks;</a>
<a name="ln129">        }</a>
<a name="ln130"> </a>
<a name="ln131">        public static BitBoard[] InitializeRookOccupancy()</a>
<a name="ln132">        {</a>
<a name="ln133">            BitBoard[] rookAttacks = new BitBoard[64];</a>
<a name="ln134"> </a>
<a name="ln135">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln136">            {</a>
<a name="ln137">                rookAttacks[square] = MaskRookOccupancy(square);</a>
<a name="ln138">            }</a>
<a name="ln139"> </a>
<a name="ln140">            return rookAttacks;</a>
<a name="ln141">        }</a>
<a name="ln142"> </a>
<a name="ln143">        /// &lt;summary&gt;</a>
<a name="ln144">        /// Returns bishop occupancy masks and attacks</a>
<a name="ln145">        /// &lt;/summary&gt;</a>
<a name="ln146">        /// &lt;returns&gt;(BitBoard[64], BitBoard[64, 512])&lt;/returns&gt;</a>
<a name="ln147">        public static (BitBoard[] BishopOccupancyMasks, BitBoard[,] BishopAttacks) InitializeBishopMagicAttacks()</a>
<a name="ln148">        {</a>
<a name="ln149">            BitBoard[] occupancyMasks = new BitBoard[64];</a>
<a name="ln150">            BitBoard[,] attacks = new BitBoard[64, 512];</a>
<a name="ln151"> </a>
<a name="ln152">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln153">            {</a>
<a name="ln154">                occupancyMasks[square] = MaskBishopOccupancy(square);</a>
<a name="ln155"> </a>
<a name="ln156">                var relevantBitsCount = Constants.BishopRelevantOccupancyBits[square];</a>
<a name="ln157"> </a>
<a name="ln158">                int occupancyIndexes = (1 &lt;&lt; relevantBitsCount);</a>
<a name="ln159"> </a>
<a name="ln160">                for (int index = 0; index &lt; occupancyIndexes; ++index)</a>
<a name="ln161">                {</a>
<a name="ln162">                    var occupancy = SetBishopOrRookOccupancy(index, occupancyMasks[square]);</a>
<a name="ln163"> </a>
<a name="ln164">                    var magicIndex = (occupancy * Constants.BishopMagicNumbers[square]) &gt;&gt; (64 - relevantBitsCount);</a>
<a name="ln165"> </a>
<a name="ln166">                    attacks[square, magicIndex] = GenerateBishopAttacksOnTheFly(square, occupancy);</a>
<a name="ln167">                }</a>
<a name="ln168">            }</a>
<a name="ln169"> </a>
<a name="ln170">            return (occupancyMasks, attacks);</a>
<a name="ln171">        }</a>
<a name="ln172"> </a>
<a name="ln173">        /// &lt;summary&gt;</a>
<a name="ln174">        /// Returns rook occupancy masks and attacks</a>
<a name="ln175">        /// &lt;/summary&gt;</a>
<a name="ln176">        /// &lt;returns&gt;(BitBoard[64], BitBoard[64, 512])&lt;/returns&gt;</a>
<a name="ln177">        public static (BitBoard[] RookOccupancyMasks, BitBoard[,] RookAttacks) InitializeRookMagicAttacks()</a>
<a name="ln178">        {</a>
<a name="ln179">            BitBoard[] occupancyMasks = new BitBoard[64];</a>
<a name="ln180">            BitBoard[,] attacks = new BitBoard[64, 4096];</a>
<a name="ln181"> </a>
<a name="ln182">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln183">            {</a>
<a name="ln184">                occupancyMasks[square] = MaskRookOccupancy(square);</a>
<a name="ln185"> </a>
<a name="ln186">                var relevantBitsCount = Constants.RookRelevantOccupancyBits[square];</a>
<a name="ln187"> </a>
<a name="ln188">                int occupancyIndexes = (1 &lt;&lt; relevantBitsCount);</a>
<a name="ln189"> </a>
<a name="ln190">                for (int index = 0; index &lt; occupancyIndexes; ++index)</a>
<a name="ln191">                {</a>
<a name="ln192">                    var occupancy = SetBishopOrRookOccupancy(index, occupancyMasks[square]);</a>
<a name="ln193"> </a>
<a name="ln194">                    var magicIndex = (occupancy * Constants.RookMagicNumbers[square]) &gt;&gt; (64 - relevantBitsCount);</a>
<a name="ln195"> </a>
<a name="ln196">                    attacks[square, magicIndex] = GenerateRookAttacksOnTheFly(square, occupancy);</a>
<a name="ln197">                }</a>
<a name="ln198">            }</a>
<a name="ln199"> </a>
<a name="ln200">            return (occupancyMasks, attacks);</a>
<a name="ln201">        }</a>
<a name="ln202"> </a>
<a name="ln203">        public static BitBoard MaskPawnAttacks(int squareIndex, bool isWhite)</a>
<a name="ln204">        {</a>
<a name="ln205">            // Results attack bitboard</a>
<a name="ln206">            BitBoard attacks = default;</a>
<a name="ln207"> </a>
<a name="ln208">            // Piece bitboard</a>
<a name="ln209">            BitBoard bitBoard = default;</a>
<a name="ln210"> </a>
<a name="ln211">            // Set piece on board</a>
<a name="ln212">            bitBoard.SetBit(squareIndex);</a>
<a name="ln213"> </a>
<a name="ln214">            if (isWhite)</a>
<a name="ln215">            {</a>
<a name="ln216">                /*</a>
<a name="ln217">                 * 0 0 0 X 0</a>
<a name="ln218">                 * 0 0 1 0 0</a>
<a name="ln219">                 * 0 0 0 0 0</a>
<a name="ln220">                 */</a>
<a name="ln221">                var right = bitBoard &gt;&gt; 7;</a>
<a name="ln222">                if ((right &amp; Constants.NotAFile) != default)</a>
<a name="ln223">                {</a>
<a name="ln224">                    attacks |= right;</a>
<a name="ln225">                }</a>
<a name="ln226"> </a>
<a name="ln227">                /*</a>
<a name="ln228">                 * 0 X 0 0 0</a>
<a name="ln229">                 * 0 0 1 0 0</a>
<a name="ln230">                 * 0 0 0 0 0</a>
<a name="ln231">                 */</a>
<a name="ln232">                var left = bitBoard &gt;&gt; 9;</a>
<a name="ln233">                if ((left &amp; Constants.NotHFile) != default)</a>
<a name="ln234">                {</a>
<a name="ln235">                    attacks |= left;</a>
<a name="ln236">                }</a>
<a name="ln237">            }</a>
<a name="ln238">            else</a>
<a name="ln239">            {</a>
<a name="ln240">                /*</a>
<a name="ln241">                 * 0 0 0 0 0</a>
<a name="ln242">                 * 0 0 1 0 0</a>
<a name="ln243">                 * 0 X 0 0 0</a>
<a name="ln244">                 */</a>
<a name="ln245">                var left = bitBoard &lt;&lt; 7;</a>
<a name="ln246">                if ((left &amp; Constants.NotHFile) != default)</a>
<a name="ln247">                {</a>
<a name="ln248">                    attacks |= left;</a>
<a name="ln249">                }</a>
<a name="ln250"> </a>
<a name="ln251">                /*</a>
<a name="ln252">                 * 0 0 0 0 0</a>
<a name="ln253">                 * 0 0 1 0 0</a>
<a name="ln254">                 * 0 0 0 X 0</a>
<a name="ln255">                 */</a>
<a name="ln256">                var right = bitBoard &lt;&lt; 9;</a>
<a name="ln257">                if ((right &amp; Constants.NotAFile) != default)</a>
<a name="ln258">                {</a>
<a name="ln259">                    attacks |= right;</a>
<a name="ln260">                }</a>
<a name="ln261">            }</a>
<a name="ln262"> </a>
<a name="ln263">            return attacks;</a>
<a name="ln264">        }</a>
<a name="ln265"> </a>
<a name="ln266">        public static BitBoard MaskKnightAttacks(int squareIndex)</a>
<a name="ln267">        {</a>
<a name="ln268">            // Results attack bitboard</a>
<a name="ln269">            BitBoard attacks = default;</a>
<a name="ln270"> </a>
<a name="ln271">            // Piece bitboard</a>
<a name="ln272">            BitBoard bitBoard = default;</a>
<a name="ln273"> </a>
<a name="ln274">            // Set piece on board</a>
<a name="ln275">            bitBoard.SetBit(squareIndex);</a>
<a name="ln276"> </a>
<a name="ln277">            /*</a>
<a name="ln278">             * 0 X 0 0 0</a>
<a name="ln279">             * 0 0 0 0 0</a>
<a name="ln280">             * 0 0 1 0 0</a>
<a name="ln281">             * 0 0 0 0 0</a>
<a name="ln282">             * 0 0 0 0 0</a>
<a name="ln283">             */</a>
<a name="ln284">            var attack = bitBoard &gt;&gt; 17;</a>
<a name="ln285">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln286">            {</a>
<a name="ln287">                attacks |= attack;</a>
<a name="ln288">            }</a>
<a name="ln289"> </a>
<a name="ln290">            /*</a>
<a name="ln291">             * 0 0 0 X 0</a>
<a name="ln292">             * 0 0 0 0 0</a>
<a name="ln293">             * 0 0 1 0 0</a>
<a name="ln294">             * 0 0 0 0 0</a>
<a name="ln295">             * 0 0 0 0 0</a>
<a name="ln296">             */</a>
<a name="ln297">            attack = bitBoard &gt;&gt; 15;</a>
<a name="ln298">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln299">            {</a>
<a name="ln300">                attacks |= attack;</a>
<a name="ln301">            }</a>
<a name="ln302"> </a>
<a name="ln303">            /*</a>
<a name="ln304">             * 0 0 0 0 0</a>
<a name="ln305">             * 0 0 0 0 0</a>
<a name="ln306">             * 0 0 1 0 0</a>
<a name="ln307">             * 0 0 0 0 0</a>
<a name="ln308">             * 0 X 0 0 0</a>
<a name="ln309">             */</a>
<a name="ln310">            attack = bitBoard &lt;&lt; 15;</a>
<a name="ln311">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln312">            {</a>
<a name="ln313">                attacks |= attack;</a>
<a name="ln314">            }</a>
<a name="ln315"> </a>
<a name="ln316">            /*</a>
<a name="ln317">             * 0 0 0 0 0</a>
<a name="ln318">             * 0 0 0 0 0</a>
<a name="ln319">             * 0 0 1 0 0</a>
<a name="ln320">             * 0 0 0 0 0</a>
<a name="ln321">             * 0 0 0 X 0</a>
<a name="ln322">             */</a>
<a name="ln323">            attack = bitBoard &lt;&lt; 17;</a>
<a name="ln324">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln325">            {</a>
<a name="ln326">                attacks |= attack;</a>
<a name="ln327">            }</a>
<a name="ln328"> </a>
<a name="ln329">            /*</a>
<a name="ln330">             * 0 0 0 0 0</a>
<a name="ln331">             * X 0 0 0 0</a>
<a name="ln332">             * 0 0 1 0 0</a>
<a name="ln333">             * 0 0 0 0 0</a>
<a name="ln334">             * 0 0 0 0 0</a>
<a name="ln335">             */</a>
<a name="ln336">            attack = bitBoard &gt;&gt; 10;</a>
<a name="ln337">            if ((attack &amp; Constants.NotHGFiles) != default)</a>
<a name="ln338">            {</a>
<a name="ln339">                attacks |= attack;</a>
<a name="ln340">            }</a>
<a name="ln341"> </a>
<a name="ln342">            /*</a>
<a name="ln343">             * 0 0 0 0 0</a>
<a name="ln344">             * 0 0 0 0 X</a>
<a name="ln345">             * 0 0 1 0 0</a>
<a name="ln346">             * 0 0 0 0 0</a>
<a name="ln347">             * 0 0 0 0 0</a>
<a name="ln348">             */</a>
<a name="ln349">            attack = bitBoard &gt;&gt; 6;</a>
<a name="ln350">            if ((attack &amp; Constants.NotABFiles) != default)</a>
<a name="ln351">            {</a>
<a name="ln352">                attacks |= attack;</a>
<a name="ln353">            }</a>
<a name="ln354"> </a>
<a name="ln355">            /*</a>
<a name="ln356">             * 0 0 0 0 0</a>
<a name="ln357">             * 0 0 0 0 0</a>
<a name="ln358">             * 0 0 1 0 0</a>
<a name="ln359">             * X 0 0 0 0</a>
<a name="ln360">             * 0 0 0 0 0</a>
<a name="ln361">             */</a>
<a name="ln362">            attack = bitBoard &lt;&lt; 6;</a>
<a name="ln363">            if ((attack &amp; Constants.NotHGFiles) != default)</a>
<a name="ln364">            {</a>
<a name="ln365">                attacks |= attack;</a>
<a name="ln366">            }</a>
<a name="ln367"> </a>
<a name="ln368">            /*</a>
<a name="ln369">             * 0 0 0 0 0</a>
<a name="ln370">             * 0 0 0 0 0</a>
<a name="ln371">             * 0 0 1 0 0</a>
<a name="ln372">             * 0 0 0 0 X</a>
<a name="ln373">             * 0 0 0 0 0</a>
<a name="ln374">             */</a>
<a name="ln375">            attack = bitBoard &lt;&lt; 10;</a>
<a name="ln376">            if ((attack &amp; Constants.NotABFiles) != default)</a>
<a name="ln377">            {</a>
<a name="ln378">                attacks |= attack;</a>
<a name="ln379">            }</a>
<a name="ln380"> </a>
<a name="ln381">            return attacks;</a>
<a name="ln382">        }</a>
<a name="ln383"> </a>
<a name="ln384">        public static BitBoard MaskKingAttacks(int squareIndex)</a>
<a name="ln385">        {</a>
<a name="ln386">            // Results attack bitboard</a>
<a name="ln387">            BitBoard attacks = default;</a>
<a name="ln388"> </a>
<a name="ln389">            // Piece bitboard</a>
<a name="ln390">            BitBoard bitBoard = default;</a>
<a name="ln391"> </a>
<a name="ln392">            // Set piece on board</a>
<a name="ln393">            bitBoard.SetBit(squareIndex);</a>
<a name="ln394"> </a>
<a name="ln395">            /*</a>
<a name="ln396">             * X 0 0</a>
<a name="ln397">             * 0 1 0</a>
<a name="ln398">             * 0 0 0</a>
<a name="ln399">             */</a>
<a name="ln400">            var attack = bitBoard &gt;&gt; 9;</a>
<a name="ln401">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln402">            {</a>
<a name="ln403">                attacks |= attack;</a>
<a name="ln404">            }</a>
<a name="ln405"> </a>
<a name="ln406">            /*</a>
<a name="ln407">             * 0 X 0</a>
<a name="ln408">             * 0 1 0</a>
<a name="ln409">             * 0 0 0</a>
<a name="ln410">             */</a>
<a name="ln411">            attacks |= bitBoard &gt;&gt; 8;</a>
<a name="ln412"> </a>
<a name="ln413">            /*</a>
<a name="ln414">             * 0 0 X</a>
<a name="ln415">             * 0 1 0</a>
<a name="ln416">             * 0 0 0</a>
<a name="ln417">             */</a>
<a name="ln418">            attack = bitBoard &gt;&gt; 7;</a>
<a name="ln419">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln420">            {</a>
<a name="ln421">                attacks |= attack;</a>
<a name="ln422">            }</a>
<a name="ln423"> </a>
<a name="ln424">            /*</a>
<a name="ln425">             * 0 0 0</a>
<a name="ln426">             * X 1 0</a>
<a name="ln427">             * 0 0 0</a>
<a name="ln428">             */</a>
<a name="ln429">            attack = bitBoard &gt;&gt; 1;</a>
<a name="ln430">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln431">            {</a>
<a name="ln432">                attacks |= attack;</a>
<a name="ln433">            }</a>
<a name="ln434"> </a>
<a name="ln435">            /*</a>
<a name="ln436">             * 0 0 0</a>
<a name="ln437">             * 0 1 X</a>
<a name="ln438">             * 0 0 0</a>
<a name="ln439">             */</a>
<a name="ln440">            attack = bitBoard &lt;&lt; 1;</a>
<a name="ln441">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln442">            {</a>
<a name="ln443">                attacks |= attack;</a>
<a name="ln444">            }</a>
<a name="ln445"> </a>
<a name="ln446">            /*</a>
<a name="ln447">             * 0 0 0</a>
<a name="ln448">             * 0 1 0</a>
<a name="ln449">             * X 0 0</a>
<a name="ln450">             */</a>
<a name="ln451">            attack = bitBoard &lt;&lt; 7;</a>
<a name="ln452">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln453">            {</a>
<a name="ln454">                attacks |= attack;</a>
<a name="ln455">            }</a>
<a name="ln456"> </a>
<a name="ln457">            /*</a>
<a name="ln458">             * 0 0 0</a>
<a name="ln459">             * 0 1 0</a>
<a name="ln460">             * 0 X 0</a>
<a name="ln461">             */</a>
<a name="ln462">            attacks |= bitBoard &lt;&lt; 8;</a>
<a name="ln463"> </a>
<a name="ln464">            /*</a>
<a name="ln465">             * 0 0 0</a>
<a name="ln466">             * 0 1 0</a>
<a name="ln467">             * X 0 0</a>
<a name="ln468">             */</a>
<a name="ln469">            attack = bitBoard &lt;&lt; 9;</a>
<a name="ln470">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln471">            {</a>
<a name="ln472">                attacks |= attack;</a>
<a name="ln473">            }</a>
<a name="ln474"> </a>
<a name="ln475">            return attacks;</a>
<a name="ln476">        }</a>
<a name="ln477"> </a>
<a name="ln478">        /// &lt;summary&gt;</a>
<a name="ln479">        /// Returns relevant 'bishop occupancy squares' (attacks)</a>
<a name="ln480">        /// Outer squares don't matter in terms of occupancy (see https://www.chessprogramming.org/First_Rank_Attacks#TheOuterSquares)</a>
<a name="ln481">        /// Therefore, there are max 6 occupancy squares per direction (if a bishop is placed on a corner)</a>
<a name="ln482">        /// &lt;/summary&gt;</a>
<a name="ln483">        public static BitBoard MaskBishopOccupancy(int squareIndex)</a>
<a name="ln484">        {</a>
<a name="ln485">            // Results attack bitboard</a>
<a name="ln486">            BitBoard attacks = default;</a>
<a name="ln487"> </a>
<a name="ln488">            int rank, file;</a>
<a name="ln489"> </a>
<a name="ln490">            // Next target square within the attack ray of a sliding piece</a>
<a name="ln491">            int targetRank = Math.DivRem(squareIndex, 8, out int targetFile);</a>
<a name="ln492"> </a>
<a name="ln493">            // Mask relevant bishop occupancy bits (squares)</a>
<a name="ln494"> </a>
<a name="ln495">            /*</a>
<a name="ln496">             * 0 0 0 0 0</a>
<a name="ln497">             * 0 1 0 0 0</a>
<a name="ln498">             * 0 0 X 0 0        ↘️</a>
<a name="ln499">             * 0 0 0 X 0</a>
<a name="ln500">             * 0 0 0 0 0</a>
<a name="ln501">             */</a>
<a name="ln502">            for (rank = targetRank + 1, file = targetFile + 1; rank &lt;= 6 &amp;&amp; file &lt;= 6; ++rank, ++file)</a>
<a name="ln503">            {</a>
<a name="ln504">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln505">            }</a>
<a name="ln506"> </a>
<a name="ln507">            /*</a>
<a name="ln508">             * 0 0 0 0 0</a>
<a name="ln509">             * 0 X 0 0 0</a>
<a name="ln510">             * 0 0 X 0 0        ↖️</a>
<a name="ln511">             * 0 0 0 1 0</a>
<a name="ln512">             * 0 0 0 0 0</a>
<a name="ln513">             */</a>
<a name="ln514">            for (rank = targetRank - 1, file = targetFile - 1; rank &gt;= 1 &amp;&amp; file &gt;= 1; --rank, --file)</a>
<a name="ln515">            {</a>
<a name="ln516">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln517">            }</a>
<a name="ln518"> </a>
<a name="ln519">            /*</a>
<a name="ln520">             * 0 0 0 0 0</a>
<a name="ln521">             * 0 0 0 X 0</a>
<a name="ln522">             * 0 0 X 0 0        ↗️</a>
<a name="ln523">             * 0 1 0 0 0</a>
<a name="ln524">             * 0 0 0 0 0</a>
<a name="ln525">             */</a>
<a name="ln526">            for (rank = targetRank - 1, file = targetFile + 1; rank &gt;= 1 &amp;&amp; file &lt;= 6; --rank, ++file)</a>
<a name="ln527">            {</a>
<a name="ln528">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln529">            }</a>
<a name="ln530"> </a>
<a name="ln531">            /*</a>
<a name="ln532">             * 0 0 0 0 0</a>
<a name="ln533">             * 0 0 0 1 0</a>
<a name="ln534">             * 0 0 X 0 0        ↙️</a>
<a name="ln535">             * 0 X 0 0 0</a>
<a name="ln536">             * 0 0 0 0 0</a>
<a name="ln537">             */</a>
<a name="ln538">            for (rank = targetRank + 1, file = targetFile - 1; rank &lt;= 6 &amp;&amp; file &gt;= 1; ++rank, --file)</a>
<a name="ln539">            {</a>
<a name="ln540">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln541">            }</a>
<a name="ln542"> </a>
<a name="ln543">            return attacks;</a>
<a name="ln544">        }</a>
<a name="ln545"> </a>
<a name="ln546">        /// &lt;summary&gt;</a>
<a name="ln547">        /// Returns relevant 'rook occupancy squares' (attacks)</a>
<a name="ln548">        /// Outer squares don't matter in terms of occupancy (see https://www.chessprogramming.org/First_Rank_Attacks#TheOuterSquares)</a>
<a name="ln549">        /// Therefore, there are max 6 occupancy squares per direction (if a rook is placed on a corner)</a>
<a name="ln550">        /// &lt;/summary&gt;</a>
<a name="ln551">        public static BitBoard MaskRookOccupancy(int squareIndex)</a>
<a name="ln552">        {</a>
<a name="ln553">            // Results attack bitboard</a>
<a name="ln554">            BitBoard attacks = default;</a>
<a name="ln555"> </a>
<a name="ln556">            int rank, file;</a>
<a name="ln557"> </a>
<a name="ln558">            // Next target square within the attack ray of a sliding piece</a>
<a name="ln559">            int targetRank = Math.DivRem(squareIndex, 8, out int targetFile);</a>
<a name="ln560"> </a>
<a name="ln561">            // Mask relevant rook occupancy bits (squares)</a>
<a name="ln562"> </a>
<a name="ln563">            /*</a>
<a name="ln564">             * 0 0 0 0 0</a>
<a name="ln565">             * 0 0 0 0 0</a>
<a name="ln566">             * 1 X X X 0      →</a>
<a name="ln567">             * 0 0 0 0 0</a>
<a name="ln568">             * 0 0 0 0 0</a>
<a name="ln569">             */</a>
<a name="ln570">            for (file = targetFile + 1; file &lt;= 6; ++file)</a>
<a name="ln571">            {</a>
<a name="ln572">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(targetRank, file);</a>
<a name="ln573">            }</a>
<a name="ln574"> </a>
<a name="ln575">            /*</a>
<a name="ln576">             * 0 0 0 0 0</a>
<a name="ln577">             * 0 0 0 0 0</a>
<a name="ln578">             * 0 X X X 1        ←</a>
<a name="ln579">             * 0 0 0 0 0</a>
<a name="ln580">             * 0 0 0 0 0</a>
<a name="ln581">             */</a>
<a name="ln582">            for (file = targetFile - 1; file &gt;= 1; --file)</a>
<a name="ln583">            {</a>
<a name="ln584">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(targetRank, file);</a>
<a name="ln585">            }</a>
<a name="ln586"> </a>
<a name="ln587">            /*</a>
<a name="ln588">             * 0 0 1 0 0</a>
<a name="ln589">             * 0 0 X 0 0</a>
<a name="ln590">             * 0 0 X 0 0        ↓</a>
<a name="ln591">             * 0 0 X 0 0</a>
<a name="ln592">             * 0 0 0 0 0</a>
<a name="ln593">             */</a>
<a name="ln594">            for (rank = targetRank + 1; rank &lt;= 6; ++rank)</a>
<a name="ln595">            {</a>
<a name="ln596">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, targetFile);</a>
<a name="ln597">            }</a>
<a name="ln598"> </a>
<a name="ln599">            /*</a>
<a name="ln600">             * 0 0 0 0 0</a>
<a name="ln601">             * 0 0 X 0 0</a>
<a name="ln602">             * 0 0 X 0 0        ↑</a>
<a name="ln603">             * 0 0 X 0 0</a>
<a name="ln604">             * 0 0 1 0 0</a>
<a name="ln605">             */</a>
<a name="ln606">            for (rank = targetRank - 1; rank &gt;= 1; --rank)</a>
<a name="ln607">            {</a>
<a name="ln608">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, targetFile);</a>
<a name="ln609">            }</a>
<a name="ln610"> </a>
<a name="ln611">            return attacks;</a>
<a name="ln612">        }</a>
<a name="ln613"> </a>
<a name="ln614">        /// &lt;summary&gt;</a>
<a name="ln615">        /// Populate occupancy sets from Bishop or Rook attack masks depending on &lt;paramref name=&quot;index&quot;/&gt;</a>
<a name="ln616">        /// &lt;/summary&gt;</a>
<a name="ln617">        /// &lt;param name=&quot;index&quot;&gt;</a>
<a name="ln618">        /// Index within the range of possible occupancies within the bitboard.</a>
<a name="ln619">        /// Between 0 and &lt;paramref name=&quot;occupancyMask&quot;/&gt;.CountBits() - 1</a>
<a name="ln620">        /// &lt;/param&gt;</a>
<a name="ln621">        /// &lt;param name=&quot;occupancyMask&quot;&gt;Bishop or rook occupancy (&lt;see cref=&quot;AttackGenerator.MaskBishopOccupancy(int)&quot;/&gt; and &lt;see cref=&quot;AttackGenerator.MaskRookOccupancy(int)&quot;/&gt;)&lt;/param&gt;</a>
<a name="ln622">        /// &lt;returns&gt;An occupancy set for the given index&lt;/returns&gt;</a>
<a name="ln623">        public static BitBoard SetBishopOrRookOccupancy(int index, BitBoard occupancyMask)</a>
<a name="ln624">        {</a>
<a name="ln625">            var bitsInMask = occupancyMask.CountBits();</a>
<a name="ln626">            var occupancy = new BitBoard();</a>
<a name="ln627"> </a>
<a name="ln628">            // Loop over the range of bits within attack mask</a>
<a name="ln629">            for (int count = 0; count &lt; bitsInMask; ++count)</a>
<a name="ln630">            {</a>
<a name="ln631">                // Extract LS1B and reset it</a>
<a name="ln632">                int squareIndex = occupancyMask.GetLS1BIndex();</a>
<a name="ln633">                occupancyMask.PopBit(squareIndex);</a>
<a name="ln634"> </a>
<a name="ln635">                // Make sure occupancy is on board</a>
<a name="ln636">                if ((index &amp; (1 &lt;&lt; count)) != default)</a>
<a name="ln637">                {</a>
<a name="ln638">                    // Update occupancy</a>
<a name="ln639">                    occupancy.SetBit(squareIndex);</a>
<a name="ln640">                }</a>
<a name="ln641">            }</a>
<a name="ln642"> </a>
<a name="ln643">            return occupancy;</a>
<a name="ln644">        }</a>
<a name="ln645"> </a>
<a name="ln646">        public static BitBoard GenerateBishopAttacksOnTheFly(int squareIndex, BitBoard occupiedSquares)</a>
<a name="ln647">        {</a>
<a name="ln648">            // Results attack bitboard</a>
<a name="ln649">            BitBoard attacks = default;</a>
<a name="ln650"> </a>
<a name="ln651">            int rank, file;</a>
<a name="ln652"> </a>
<a name="ln653">            // Next target square within the attack ray of a sliding piece</a>
<a name="ln654">            int targetRank = Math.DivRem(squareIndex, 8, out int targetFile);</a>
<a name="ln655"> </a>
<a name="ln656">            // Generate bishop attacks</a>
<a name="ln657"> </a>
<a name="ln658">            /*</a>
<a name="ln659">             * 0 0 0 0 0</a>
<a name="ln660">             * 0 1 0 0 0</a>
<a name="ln661">             * 0 0 X 0 0        ↘️</a>
<a name="ln662">             * 0 0 0 X 0</a>
<a name="ln663">             * 0 0 0 0 0</a>
<a name="ln664">             */</a>
<a name="ln665">            for (rank = targetRank + 1, file = targetFile + 1; rank &lt;= 7 &amp;&amp; file &lt;= 7; ++rank, ++file)</a>
<a name="ln666">            {</a>
<a name="ln667">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln668">                attacks |= square;</a>
<a name="ln669"> </a>
<a name="ln670">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln671">                {</a>
<a name="ln672">                    break;</a>
<a name="ln673">                }</a>
<a name="ln674">            }</a>
<a name="ln675"> </a>
<a name="ln676">            /*</a>
<a name="ln677">             * 0 0 0 0 0</a>
<a name="ln678">             * 0 X 0 0 0</a>
<a name="ln679">             * 0 0 X 0 0        ↖️</a>
<a name="ln680">             * 0 0 0 1 0</a>
<a name="ln681">             * 0 0 0 0 0</a>
<a name="ln682">             */</a>
<a name="ln683">            for (rank = targetRank - 1, file = targetFile - 1; rank &gt;= 0 &amp;&amp; file &gt;= 0; --rank, --file)</a>
<a name="ln684">            {</a>
<a name="ln685">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln686">                attacks |= square;</a>
<a name="ln687"> </a>
<a name="ln688">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln689">                {</a>
<a name="ln690">                    break;</a>
<a name="ln691">                }</a>
<a name="ln692">            }</a>
<a name="ln693"> </a>
<a name="ln694">            /*</a>
<a name="ln695">             * 0 0 0 0 0</a>
<a name="ln696">             * 0 0 0 X 0</a>
<a name="ln697">             * 0 0 X 0 0        ↗️</a>
<a name="ln698">             * 0 1 0 0 0</a>
<a name="ln699">             * 0 0 0 0 0</a>
<a name="ln700">             */</a>
<a name="ln701">            for (rank = targetRank - 1, file = targetFile + 1; rank &gt;= 0 &amp;&amp; file &lt;= 7; --rank, ++file)</a>
<a name="ln702">            {</a>
<a name="ln703">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln704">                attacks |= square;</a>
<a name="ln705"> </a>
<a name="ln706">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln707">                {</a>
<a name="ln708">                    break;</a>
<a name="ln709">                }</a>
<a name="ln710">            }</a>
<a name="ln711"> </a>
<a name="ln712">            /*</a>
<a name="ln713">             * 0 0 0 0 0</a>
<a name="ln714">             * 0 0 0 1 0</a>
<a name="ln715">             * 0 0 X 0 0        ↙️</a>
<a name="ln716">             * 0 X 0 0 0</a>
<a name="ln717">             * 0 0 0 0 0</a>
<a name="ln718">             */</a>
<a name="ln719">            for (rank = targetRank + 1, file = targetFile - 1; rank &lt;= 7 &amp;&amp; file &gt;= 0; ++rank, --file)</a>
<a name="ln720">            {</a>
<a name="ln721">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln722">                attacks |= square;</a>
<a name="ln723"> </a>
<a name="ln724">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln725">                {</a>
<a name="ln726">                    break;</a>
<a name="ln727">                }</a>
<a name="ln728">            }</a>
<a name="ln729"> </a>
<a name="ln730">            return attacks;</a>
<a name="ln731">        }</a>
<a name="ln732"> </a>
<a name="ln733">        public static BitBoard GenerateRookAttacksOnTheFly(int squareIndex, BitBoard occupiedSquares)</a>
<a name="ln734">        {</a>
<a name="ln735">            // Results attack bitboard</a>
<a name="ln736">            BitBoard attacks = default;</a>
<a name="ln737"> </a>
<a name="ln738">            int rank, file;</a>
<a name="ln739"> </a>
<a name="ln740">            // Next target square within the attack ray of a sliding piece</a>
<a name="ln741">            int targetRank = Math.DivRem(squareIndex, 8, out int targetFile);</a>
<a name="ln742"> </a>
<a name="ln743">            // Generate rook attacks</a>
<a name="ln744"> </a>
<a name="ln745">            /*</a>
<a name="ln746">             * 0 0 0 0 0</a>
<a name="ln747">             * 0 0 0 0 0</a>
<a name="ln748">             * 1 X X X 0      →</a>
<a name="ln749">             * 0 0 0 0 0</a>
<a name="ln750">             * 0 0 0 0 0</a>
<a name="ln751">             */</a>
<a name="ln752">            for (file = targetFile + 1; file &lt;= 7; ++file)</a>
<a name="ln753">            {</a>
<a name="ln754">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(targetRank, file);</a>
<a name="ln755">                attacks |= square;</a>
<a name="ln756"> </a>
<a name="ln757">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln758">                {</a>
<a name="ln759">                    break;</a>
<a name="ln760">                }</a>
<a name="ln761">            }</a>
<a name="ln762"> </a>
<a name="ln763">            /*</a>
<a name="ln764">             * 0 0 0 0 0</a>
<a name="ln765">             * 0 0 0 0 0</a>
<a name="ln766">             * 0 X X X 1        ←</a>
<a name="ln767">             * 0 0 0 0 0</a>
<a name="ln768">             * 0 0 0 0 0</a>
<a name="ln769">             */</a>
<a name="ln770">            for (file = targetFile - 1; file &gt;= 0; --file)</a>
<a name="ln771">            {</a>
<a name="ln772">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(targetRank, file);</a>
<a name="ln773">                attacks |= square;</a>
<a name="ln774"> </a>
<a name="ln775">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln776">                {</a>
<a name="ln777">                    break;</a>
<a name="ln778">                }</a>
<a name="ln779">            }</a>
<a name="ln780"> </a>
<a name="ln781">            /*</a>
<a name="ln782">             * 0 0 1 0 0</a>
<a name="ln783">             * 0 0 X 0 0</a>
<a name="ln784">             * 0 0 X 0 0        ↓</a>
<a name="ln785">             * 0 0 X 0 0</a>
<a name="ln786">             * 0 0 0 0 0</a>
<a name="ln787">             */</a>
<a name="ln788">            for (rank = targetRank + 1; rank &lt;= 7; ++rank)</a>
<a name="ln789">            {</a>
<a name="ln790">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, targetFile);</a>
<a name="ln791">                attacks |= square;</a>
<a name="ln792"> </a>
<a name="ln793">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln794">                {</a>
<a name="ln795">                    break;</a>
<a name="ln796">                }</a>
<a name="ln797">            }</a>
<a name="ln798"> </a>
<a name="ln799">            /*</a>
<a name="ln800">             * 0 0 0 0 0</a>
<a name="ln801">             * 0 0 X 0 0</a>
<a name="ln802">             * 0 0 X 0 0        ↑</a>
<a name="ln803">             * 0 0 X 0 0</a>
<a name="ln804">             * 0 0 1 0 0</a>
<a name="ln805">             */</a>
<a name="ln806">            for (rank = targetRank - 1; rank &gt;= 0; --rank)</a>
<a name="ln807">            {</a>
<a name="ln808">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, targetFile);</a>
<a name="ln809">                attacks |= square;</a>
<a name="ln810"> </a>
<a name="ln811">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln812">                {</a>
<a name="ln813">                    break;</a>
<a name="ln814">                }</a>
<a name="ln815">            }</a>
<a name="ln816"> </a>
<a name="ln817">            return attacks;</a>
<a name="ln818">        }</a>
<a name="ln819">    }</a>
<a name="ln820"> </a>
<a name="ln821">    private static class SkipLocalsInit_AttackGenerator_SkipLocalsInit</a>
<a name="ln822">    {</a>
<a name="ln823">        /// &lt;summary&gt;</a>
<a name="ln824">        /// BitBoard[isWhite, square]</a>
<a name="ln825">        /// &lt;/summary&gt;</a>
<a name="ln826">        [SkipLocalsInit]</a>
<a name="ln827">        public static BitBoard[,] InitializePawnAttacks()</a>
<a name="ln828">        {</a>
<a name="ln829">            BitBoard[,] pawnAttacks = new BitBoard[2, 64];</a>
<a name="ln830"> </a>
<a name="ln831">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln832">            {</a>
<a name="ln833">                pawnAttacks[0, square] = MaskPawnAttacks(square, isWhite: false);</a>
<a name="ln834">                pawnAttacks[1, square] = MaskPawnAttacks(square, isWhite: true);</a>
<a name="ln835">            }</a>
<a name="ln836"> </a>
<a name="ln837">            return pawnAttacks;</a>
<a name="ln838">        }</a>
<a name="ln839"> </a>
<a name="ln840">        [SkipLocalsInit]</a>
<a name="ln841">        public static BitBoard[] InitializeKnightAttacks()</a>
<a name="ln842">        {</a>
<a name="ln843">            BitBoard[] knightAttacks = new BitBoard[64];</a>
<a name="ln844"> </a>
<a name="ln845">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln846">            {</a>
<a name="ln847">                knightAttacks[square] = MaskKnightAttacks(square);</a>
<a name="ln848">            }</a>
<a name="ln849"> </a>
<a name="ln850">            return knightAttacks;</a>
<a name="ln851">        }</a>
<a name="ln852"> </a>
<a name="ln853">        [SkipLocalsInit]</a>
<a name="ln854">        public static BitBoard[] InitializeKingAttacks()</a>
<a name="ln855">        {</a>
<a name="ln856">            BitBoard[] kingAttacks = new BitBoard[64];</a>
<a name="ln857"> </a>
<a name="ln858">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln859">            {</a>
<a name="ln860">                kingAttacks[square] = MaskKingAttacks(square);</a>
<a name="ln861">            }</a>
<a name="ln862"> </a>
<a name="ln863">            return kingAttacks;</a>
<a name="ln864">        }</a>
<a name="ln865"> </a>
<a name="ln866">        [SkipLocalsInit]</a>
<a name="ln867">        public static BitBoard[] InitializeBishopOccupancy()</a>
<a name="ln868">        {</a>
<a name="ln869">            BitBoard[] bishopAttacks = new BitBoard[64];</a>
<a name="ln870"> </a>
<a name="ln871">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln872">            {</a>
<a name="ln873">                bishopAttacks[square] = MaskBishopOccupancy(square);</a>
<a name="ln874">            }</a>
<a name="ln875"> </a>
<a name="ln876">            return bishopAttacks;</a>
<a name="ln877">        }</a>
<a name="ln878"> </a>
<a name="ln879">        [SkipLocalsInit]</a>
<a name="ln880">        public static BitBoard[] InitializeRookOccupancy()</a>
<a name="ln881">        {</a>
<a name="ln882">            BitBoard[] rookAttacks = new BitBoard[64];</a>
<a name="ln883"> </a>
<a name="ln884">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln885">            {</a>
<a name="ln886">                rookAttacks[square] = MaskRookOccupancy(square);</a>
<a name="ln887">            }</a>
<a name="ln888"> </a>
<a name="ln889">            return rookAttacks;</a>
<a name="ln890">        }</a>
<a name="ln891"> </a>
<a name="ln892">        /// &lt;summary&gt;</a>
<a name="ln893">        /// Returns bishop occupancy masks and attacks</a>
<a name="ln894">        /// &lt;/summary&gt;</a>
<a name="ln895">        /// &lt;returns&gt;(BitBoard[64], BitBoard[64, 512])&lt;/returns&gt;</a>
<a name="ln896">        [SkipLocalsInit]</a>
<a name="ln897">        public static (BitBoard[] BishopOccupancyMasks, BitBoard[,] BishopAttacks) InitializeBishopMagicAttacks()</a>
<a name="ln898">        {</a>
<a name="ln899">            BitBoard[] occupancyMasks = new BitBoard[64];</a>
<a name="ln900">            BitBoard[,] attacks = new BitBoard[64, 512];</a>
<a name="ln901"> </a>
<a name="ln902">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln903">            {</a>
<a name="ln904">                occupancyMasks[square] = MaskBishopOccupancy(square);</a>
<a name="ln905"> </a>
<a name="ln906">                var relevantBitsCount = Constants.BishopRelevantOccupancyBits[square];</a>
<a name="ln907"> </a>
<a name="ln908">                int occupancyIndexes = (1 &lt;&lt; relevantBitsCount);</a>
<a name="ln909"> </a>
<a name="ln910">                for (int index = 0; index &lt; occupancyIndexes; ++index)</a>
<a name="ln911">                {</a>
<a name="ln912">                    var occupancy = SetBishopOrRookOccupancy(index, occupancyMasks[square]);</a>
<a name="ln913"> </a>
<a name="ln914">                    var magicIndex = (occupancy * Constants.BishopMagicNumbers[square]) &gt;&gt; (64 - relevantBitsCount);</a>
<a name="ln915"> </a>
<a name="ln916">                    attacks[square, magicIndex] = GenerateBishopAttacksOnTheFly(square, occupancy);</a>
<a name="ln917">                }</a>
<a name="ln918">            }</a>
<a name="ln919"> </a>
<a name="ln920">            return (occupancyMasks, attacks);</a>
<a name="ln921">        }</a>
<a name="ln922"> </a>
<a name="ln923">        /// &lt;summary&gt;</a>
<a name="ln924">        /// Returns rook occupancy masks and attacks</a>
<a name="ln925">        /// &lt;/summary&gt;</a>
<a name="ln926">        /// &lt;returns&gt;(BitBoard[64], BitBoard[64, 512])&lt;/returns&gt;</a>
<a name="ln927">        [SkipLocalsInit]</a>
<a name="ln928">        public static (BitBoard[] RookOccupancyMasks, BitBoard[,] RookAttacks) InitializeRookMagicAttacks()</a>
<a name="ln929">        {</a>
<a name="ln930">            BitBoard[] occupancyMasks = new BitBoard[64];</a>
<a name="ln931">            BitBoard[,] attacks = new BitBoard[64, 4096];</a>
<a name="ln932"> </a>
<a name="ln933">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln934">            {</a>
<a name="ln935">                occupancyMasks[square] = MaskRookOccupancy(square);</a>
<a name="ln936"> </a>
<a name="ln937">                var relevantBitsCount = Constants.RookRelevantOccupancyBits[square];</a>
<a name="ln938"> </a>
<a name="ln939">                int occupancyIndexes = (1 &lt;&lt; relevantBitsCount);</a>
<a name="ln940"> </a>
<a name="ln941">                for (int index = 0; index &lt; occupancyIndexes; ++index)</a>
<a name="ln942">                {</a>
<a name="ln943">                    var occupancy = SetBishopOrRookOccupancy(index, occupancyMasks[square]);</a>
<a name="ln944"> </a>
<a name="ln945">                    var magicIndex = (occupancy * Constants.RookMagicNumbers[square]) &gt;&gt; (64 - relevantBitsCount);</a>
<a name="ln946"> </a>
<a name="ln947">                    attacks[square, magicIndex] = GenerateRookAttacksOnTheFly(square, occupancy);</a>
<a name="ln948">                }</a>
<a name="ln949">            }</a>
<a name="ln950"> </a>
<a name="ln951">            return (occupancyMasks, attacks);</a>
<a name="ln952">        }</a>
<a name="ln953"> </a>
<a name="ln954">        public static BitBoard MaskPawnAttacks(int squareIndex, bool isWhite)</a>
<a name="ln955">        {</a>
<a name="ln956">            // Results attack bitboard</a>
<a name="ln957">            BitBoard attacks = default;</a>
<a name="ln958"> </a>
<a name="ln959">            // Piece bitboard</a>
<a name="ln960">            BitBoard bitBoard = default;</a>
<a name="ln961"> </a>
<a name="ln962">            // Set piece on board</a>
<a name="ln963">            bitBoard.SetBit(squareIndex);</a>
<a name="ln964"> </a>
<a name="ln965">            if (isWhite)</a>
<a name="ln966">            {</a>
<a name="ln967">                /*</a>
<a name="ln968">                 * 0 0 0 X 0</a>
<a name="ln969">                 * 0 0 1 0 0</a>
<a name="ln970">                 * 0 0 0 0 0</a>
<a name="ln971">                 */</a>
<a name="ln972">                var right = bitBoard &gt;&gt; 7;</a>
<a name="ln973">                if ((right &amp; Constants.NotAFile) != default)</a>
<a name="ln974">                {</a>
<a name="ln975">                    attacks |= right;</a>
<a name="ln976">                }</a>
<a name="ln977"> </a>
<a name="ln978">                /*</a>
<a name="ln979">                 * 0 X 0 0 0</a>
<a name="ln980">                 * 0 0 1 0 0</a>
<a name="ln981">                 * 0 0 0 0 0</a>
<a name="ln982">                 */</a>
<a name="ln983">                var left = bitBoard &gt;&gt; 9;</a>
<a name="ln984">                if ((left &amp; Constants.NotHFile) != default)</a>
<a name="ln985">                {</a>
<a name="ln986">                    attacks |= left;</a>
<a name="ln987">                }</a>
<a name="ln988">            }</a>
<a name="ln989">            else</a>
<a name="ln990">            {</a>
<a name="ln991">                /*</a>
<a name="ln992">                 * 0 0 0 0 0</a>
<a name="ln993">                 * 0 0 1 0 0</a>
<a name="ln994">                 * 0 X 0 0 0</a>
<a name="ln995">                 */</a>
<a name="ln996">                var left = bitBoard &lt;&lt; 7;</a>
<a name="ln997">                if ((left &amp; Constants.NotHFile) != default)</a>
<a name="ln998">                {</a>
<a name="ln999">                    attacks |= left;</a>
<a name="ln1000">                }</a>
<a name="ln1001"> </a>
<a name="ln1002">                /*</a>
<a name="ln1003">                 * 0 0 0 0 0</a>
<a name="ln1004">                 * 0 0 1 0 0</a>
<a name="ln1005">                 * 0 0 0 X 0</a>
<a name="ln1006">                 */</a>
<a name="ln1007">                var right = bitBoard &lt;&lt; 9;</a>
<a name="ln1008">                if ((right &amp; Constants.NotAFile) != default)</a>
<a name="ln1009">                {</a>
<a name="ln1010">                    attacks |= right;</a>
<a name="ln1011">                }</a>
<a name="ln1012">            }</a>
<a name="ln1013"> </a>
<a name="ln1014">            return attacks;</a>
<a name="ln1015">        }</a>
<a name="ln1016"> </a>
<a name="ln1017">        public static BitBoard MaskKnightAttacks(int squareIndex)</a>
<a name="ln1018">        {</a>
<a name="ln1019">            // Results attack bitboard</a>
<a name="ln1020">            BitBoard attacks = default;</a>
<a name="ln1021"> </a>
<a name="ln1022">            // Piece bitboard</a>
<a name="ln1023">            BitBoard bitBoard = default;</a>
<a name="ln1024"> </a>
<a name="ln1025">            // Set piece on board</a>
<a name="ln1026">            bitBoard.SetBit(squareIndex);</a>
<a name="ln1027"> </a>
<a name="ln1028">            /*</a>
<a name="ln1029">             * 0 X 0 0 0</a>
<a name="ln1030">             * 0 0 0 0 0</a>
<a name="ln1031">             * 0 0 1 0 0</a>
<a name="ln1032">             * 0 0 0 0 0</a>
<a name="ln1033">             * 0 0 0 0 0</a>
<a name="ln1034">             */</a>
<a name="ln1035">            var attack = bitBoard &gt;&gt; 17;</a>
<a name="ln1036">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln1037">            {</a>
<a name="ln1038">                attacks |= attack;</a>
<a name="ln1039">            }</a>
<a name="ln1040"> </a>
<a name="ln1041">            /*</a>
<a name="ln1042">             * 0 0 0 X 0</a>
<a name="ln1043">             * 0 0 0 0 0</a>
<a name="ln1044">             * 0 0 1 0 0</a>
<a name="ln1045">             * 0 0 0 0 0</a>
<a name="ln1046">             * 0 0 0 0 0</a>
<a name="ln1047">             */</a>
<a name="ln1048">            attack = bitBoard &gt;&gt; 15;</a>
<a name="ln1049">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln1050">            {</a>
<a name="ln1051">                attacks |= attack;</a>
<a name="ln1052">            }</a>
<a name="ln1053"> </a>
<a name="ln1054">            /*</a>
<a name="ln1055">             * 0 0 0 0 0</a>
<a name="ln1056">             * 0 0 0 0 0</a>
<a name="ln1057">             * 0 0 1 0 0</a>
<a name="ln1058">             * 0 0 0 0 0</a>
<a name="ln1059">             * 0 X 0 0 0</a>
<a name="ln1060">             */</a>
<a name="ln1061">            attack = bitBoard &lt;&lt; 15;</a>
<a name="ln1062">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln1063">            {</a>
<a name="ln1064">                attacks |= attack;</a>
<a name="ln1065">            }</a>
<a name="ln1066"> </a>
<a name="ln1067">            /*</a>
<a name="ln1068">             * 0 0 0 0 0</a>
<a name="ln1069">             * 0 0 0 0 0</a>
<a name="ln1070">             * 0 0 1 0 0</a>
<a name="ln1071">             * 0 0 0 0 0</a>
<a name="ln1072">             * 0 0 0 X 0</a>
<a name="ln1073">             */</a>
<a name="ln1074">            attack = bitBoard &lt;&lt; 17;</a>
<a name="ln1075">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln1076">            {</a>
<a name="ln1077">                attacks |= attack;</a>
<a name="ln1078">            }</a>
<a name="ln1079"> </a>
<a name="ln1080">            /*</a>
<a name="ln1081">             * 0 0 0 0 0</a>
<a name="ln1082">             * X 0 0 0 0</a>
<a name="ln1083">             * 0 0 1 0 0</a>
<a name="ln1084">             * 0 0 0 0 0</a>
<a name="ln1085">             * 0 0 0 0 0</a>
<a name="ln1086">             */</a>
<a name="ln1087">            attack = bitBoard &gt;&gt; 10;</a>
<a name="ln1088">            if ((attack &amp; Constants.NotHGFiles) != default)</a>
<a name="ln1089">            {</a>
<a name="ln1090">                attacks |= attack;</a>
<a name="ln1091">            }</a>
<a name="ln1092"> </a>
<a name="ln1093">            /*</a>
<a name="ln1094">             * 0 0 0 0 0</a>
<a name="ln1095">             * 0 0 0 0 X</a>
<a name="ln1096">             * 0 0 1 0 0</a>
<a name="ln1097">             * 0 0 0 0 0</a>
<a name="ln1098">             * 0 0 0 0 0</a>
<a name="ln1099">             */</a>
<a name="ln1100">            attack = bitBoard &gt;&gt; 6;</a>
<a name="ln1101">            if ((attack &amp; Constants.NotABFiles) != default)</a>
<a name="ln1102">            {</a>
<a name="ln1103">                attacks |= attack;</a>
<a name="ln1104">            }</a>
<a name="ln1105"> </a>
<a name="ln1106">            /*</a>
<a name="ln1107">             * 0 0 0 0 0</a>
<a name="ln1108">             * 0 0 0 0 0</a>
<a name="ln1109">             * 0 0 1 0 0</a>
<a name="ln1110">             * X 0 0 0 0</a>
<a name="ln1111">             * 0 0 0 0 0</a>
<a name="ln1112">             */</a>
<a name="ln1113">            attack = bitBoard &lt;&lt; 6;</a>
<a name="ln1114">            if ((attack &amp; Constants.NotHGFiles) != default)</a>
<a name="ln1115">            {</a>
<a name="ln1116">                attacks |= attack;</a>
<a name="ln1117">            }</a>
<a name="ln1118"> </a>
<a name="ln1119">            /*</a>
<a name="ln1120">             * 0 0 0 0 0</a>
<a name="ln1121">             * 0 0 0 0 0</a>
<a name="ln1122">             * 0 0 1 0 0</a>
<a name="ln1123">             * 0 0 0 0 X</a>
<a name="ln1124">             * 0 0 0 0 0</a>
<a name="ln1125">             */</a>
<a name="ln1126">            attack = bitBoard &lt;&lt; 10;</a>
<a name="ln1127">            if ((attack &amp; Constants.NotABFiles) != default)</a>
<a name="ln1128">            {</a>
<a name="ln1129">                attacks |= attack;</a>
<a name="ln1130">            }</a>
<a name="ln1131"> </a>
<a name="ln1132">            return attacks;</a>
<a name="ln1133">        }</a>
<a name="ln1134"> </a>
<a name="ln1135">        public static BitBoard MaskKingAttacks(int squareIndex)</a>
<a name="ln1136">        {</a>
<a name="ln1137">            // Results attack bitboard</a>
<a name="ln1138">            BitBoard attacks = default;</a>
<a name="ln1139"> </a>
<a name="ln1140">            // Piece bitboard</a>
<a name="ln1141">            BitBoard bitBoard = default;</a>
<a name="ln1142"> </a>
<a name="ln1143">            // Set piece on board</a>
<a name="ln1144">            bitBoard.SetBit(squareIndex);</a>
<a name="ln1145"> </a>
<a name="ln1146">            /*</a>
<a name="ln1147">             * X 0 0</a>
<a name="ln1148">             * 0 1 0</a>
<a name="ln1149">             * 0 0 0</a>
<a name="ln1150">             */</a>
<a name="ln1151">            var attack = bitBoard &gt;&gt; 9;</a>
<a name="ln1152">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln1153">            {</a>
<a name="ln1154">                attacks |= attack;</a>
<a name="ln1155">            }</a>
<a name="ln1156"> </a>
<a name="ln1157">            /*</a>
<a name="ln1158">             * 0 X 0</a>
<a name="ln1159">             * 0 1 0</a>
<a name="ln1160">             * 0 0 0</a>
<a name="ln1161">             */</a>
<a name="ln1162">            attacks |= bitBoard &gt;&gt; 8;</a>
<a name="ln1163"> </a>
<a name="ln1164">            /*</a>
<a name="ln1165">             * 0 0 X</a>
<a name="ln1166">             * 0 1 0</a>
<a name="ln1167">             * 0 0 0</a>
<a name="ln1168">             */</a>
<a name="ln1169">            attack = bitBoard &gt;&gt; 7;</a>
<a name="ln1170">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln1171">            {</a>
<a name="ln1172">                attacks |= attack;</a>
<a name="ln1173">            }</a>
<a name="ln1174"> </a>
<a name="ln1175">            /*</a>
<a name="ln1176">             * 0 0 0</a>
<a name="ln1177">             * X 1 0</a>
<a name="ln1178">             * 0 0 0</a>
<a name="ln1179">             */</a>
<a name="ln1180">            attack = bitBoard &gt;&gt; 1;</a>
<a name="ln1181">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln1182">            {</a>
<a name="ln1183">                attacks |= attack;</a>
<a name="ln1184">            }</a>
<a name="ln1185"> </a>
<a name="ln1186">            /*</a>
<a name="ln1187">             * 0 0 0</a>
<a name="ln1188">             * 0 1 X</a>
<a name="ln1189">             * 0 0 0</a>
<a name="ln1190">             */</a>
<a name="ln1191">            attack = bitBoard &lt;&lt; 1;</a>
<a name="ln1192">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln1193">            {</a>
<a name="ln1194">                attacks |= attack;</a>
<a name="ln1195">            }</a>
<a name="ln1196"> </a>
<a name="ln1197">            /*</a>
<a name="ln1198">             * 0 0 0</a>
<a name="ln1199">             * 0 1 0</a>
<a name="ln1200">             * X 0 0</a>
<a name="ln1201">             */</a>
<a name="ln1202">            attack = bitBoard &lt;&lt; 7;</a>
<a name="ln1203">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln1204">            {</a>
<a name="ln1205">                attacks |= attack;</a>
<a name="ln1206">            }</a>
<a name="ln1207"> </a>
<a name="ln1208">            /*</a>
<a name="ln1209">             * 0 0 0</a>
<a name="ln1210">             * 0 1 0</a>
<a name="ln1211">             * 0 X 0</a>
<a name="ln1212">             */</a>
<a name="ln1213">            attacks |= bitBoard &lt;&lt; 8;</a>
<a name="ln1214"> </a>
<a name="ln1215">            /*</a>
<a name="ln1216">             * 0 0 0</a>
<a name="ln1217">             * 0 1 0</a>
<a name="ln1218">             * X 0 0</a>
<a name="ln1219">             */</a>
<a name="ln1220">            attack = bitBoard &lt;&lt; 9;</a>
<a name="ln1221">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln1222">            {</a>
<a name="ln1223">                attacks |= attack;</a>
<a name="ln1224">            }</a>
<a name="ln1225"> </a>
<a name="ln1226">            return attacks;</a>
<a name="ln1227">        }</a>
<a name="ln1228"> </a>
<a name="ln1229">        /// &lt;summary&gt;</a>
<a name="ln1230">        /// Returns relevant 'bishop occupancy squares' (attacks)</a>
<a name="ln1231">        /// Outer squares don't matter in terms of occupancy (see https://www.chessprogramming.org/First_Rank_Attacks#TheOuterSquares)</a>
<a name="ln1232">        /// Therefore, there are max 6 occupancy squares per direction (if a bishop is placed on a corner)</a>
<a name="ln1233">        /// &lt;/summary&gt;</a>
<a name="ln1234">        public static BitBoard MaskBishopOccupancy(int squareIndex)</a>
<a name="ln1235">        {</a>
<a name="ln1236">            // Results attack bitboard</a>
<a name="ln1237">            BitBoard attacks = default;</a>
<a name="ln1238"> </a>
<a name="ln1239">            int rank, file;</a>
<a name="ln1240"> </a>
<a name="ln1241">            // Next target square within the attack ray of a sliding piece</a>
<a name="ln1242">            int targetRank = Math.DivRem(squareIndex, 8, out int targetFile);</a>
<a name="ln1243"> </a>
<a name="ln1244">            // Mask relevant bishop occupancy bits (squares)</a>
<a name="ln1245"> </a>
<a name="ln1246">            /*</a>
<a name="ln1247">             * 0 0 0 0 0</a>
<a name="ln1248">             * 0 1 0 0 0</a>
<a name="ln1249">             * 0 0 X 0 0        ↘️</a>
<a name="ln1250">             * 0 0 0 X 0</a>
<a name="ln1251">             * 0 0 0 0 0</a>
<a name="ln1252">             */</a>
<a name="ln1253">            for (rank = targetRank + 1, file = targetFile + 1; rank &lt;= 6 &amp;&amp; file &lt;= 6; ++rank, ++file)</a>
<a name="ln1254">            {</a>
<a name="ln1255">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln1256">            }</a>
<a name="ln1257"> </a>
<a name="ln1258">            /*</a>
<a name="ln1259">             * 0 0 0 0 0</a>
<a name="ln1260">             * 0 X 0 0 0</a>
<a name="ln1261">             * 0 0 X 0 0        ↖️</a>
<a name="ln1262">             * 0 0 0 1 0</a>
<a name="ln1263">             * 0 0 0 0 0</a>
<a name="ln1264">             */</a>
<a name="ln1265">            for (rank = targetRank - 1, file = targetFile - 1; rank &gt;= 1 &amp;&amp; file &gt;= 1; --rank, --file)</a>
<a name="ln1266">            {</a>
<a name="ln1267">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln1268">            }</a>
<a name="ln1269"> </a>
<a name="ln1270">            /*</a>
<a name="ln1271">             * 0 0 0 0 0</a>
<a name="ln1272">             * 0 0 0 X 0</a>
<a name="ln1273">             * 0 0 X 0 0        ↗️</a>
<a name="ln1274">             * 0 1 0 0 0</a>
<a name="ln1275">             * 0 0 0 0 0</a>
<a name="ln1276">             */</a>
<a name="ln1277">            for (rank = targetRank - 1, file = targetFile + 1; rank &gt;= 1 &amp;&amp; file &lt;= 6; --rank, ++file)</a>
<a name="ln1278">            {</a>
<a name="ln1279">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln1280">            }</a>
<a name="ln1281"> </a>
<a name="ln1282">            /*</a>
<a name="ln1283">             * 0 0 0 0 0</a>
<a name="ln1284">             * 0 0 0 1 0</a>
<a name="ln1285">             * 0 0 X 0 0        ↙️</a>
<a name="ln1286">             * 0 X 0 0 0</a>
<a name="ln1287">             * 0 0 0 0 0</a>
<a name="ln1288">             */</a>
<a name="ln1289">            for (rank = targetRank + 1, file = targetFile - 1; rank &lt;= 6 &amp;&amp; file &gt;= 1; ++rank, --file)</a>
<a name="ln1290">            {</a>
<a name="ln1291">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln1292">            }</a>
<a name="ln1293"> </a>
<a name="ln1294">            return attacks;</a>
<a name="ln1295">        }</a>
<a name="ln1296"> </a>
<a name="ln1297">        /// &lt;summary&gt;</a>
<a name="ln1298">        /// Returns relevant 'rook occupancy squares' (attacks)</a>
<a name="ln1299">        /// Outer squares don't matter in terms of occupancy (see https://www.chessprogramming.org/First_Rank_Attacks#TheOuterSquares)</a>
<a name="ln1300">        /// Therefore, there are max 6 occupancy squares per direction (if a rook is placed on a corner)</a>
<a name="ln1301">        /// &lt;/summary&gt;</a>
<a name="ln1302">        public static BitBoard MaskRookOccupancy(int squareIndex)</a>
<a name="ln1303">        {</a>
<a name="ln1304">            // Results attack bitboard</a>
<a name="ln1305">            BitBoard attacks = default;</a>
<a name="ln1306"> </a>
<a name="ln1307">            int rank, file;</a>
<a name="ln1308"> </a>
<a name="ln1309">            // Next target square within the attack ray of a sliding piece</a>
<a name="ln1310">            int targetRank = Math.DivRem(squareIndex, 8, out int targetFile);</a>
<a name="ln1311"> </a>
<a name="ln1312">            // Mask relevant rook occupancy bits (squares)</a>
<a name="ln1313"> </a>
<a name="ln1314">            /*</a>
<a name="ln1315">             * 0 0 0 0 0</a>
<a name="ln1316">             * 0 0 0 0 0</a>
<a name="ln1317">             * 1 X X X 0      →</a>
<a name="ln1318">             * 0 0 0 0 0</a>
<a name="ln1319">             * 0 0 0 0 0</a>
<a name="ln1320">             */</a>
<a name="ln1321">            for (file = targetFile + 1; file &lt;= 6; ++file)</a>
<a name="ln1322">            {</a>
<a name="ln1323">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(targetRank, file);</a>
<a name="ln1324">            }</a>
<a name="ln1325"> </a>
<a name="ln1326">            /*</a>
<a name="ln1327">             * 0 0 0 0 0</a>
<a name="ln1328">             * 0 0 0 0 0</a>
<a name="ln1329">             * 0 X X X 1        ←</a>
<a name="ln1330">             * 0 0 0 0 0</a>
<a name="ln1331">             * 0 0 0 0 0</a>
<a name="ln1332">             */</a>
<a name="ln1333">            for (file = targetFile - 1; file &gt;= 1; --file)</a>
<a name="ln1334">            {</a>
<a name="ln1335">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(targetRank, file);</a>
<a name="ln1336">            }</a>
<a name="ln1337"> </a>
<a name="ln1338">            /*</a>
<a name="ln1339">             * 0 0 1 0 0</a>
<a name="ln1340">             * 0 0 X 0 0</a>
<a name="ln1341">             * 0 0 X 0 0        ↓</a>
<a name="ln1342">             * 0 0 X 0 0</a>
<a name="ln1343">             * 0 0 0 0 0</a>
<a name="ln1344">             */</a>
<a name="ln1345">            for (rank = targetRank + 1; rank &lt;= 6; ++rank)</a>
<a name="ln1346">            {</a>
<a name="ln1347">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, targetFile);</a>
<a name="ln1348">            }</a>
<a name="ln1349"> </a>
<a name="ln1350">            /*</a>
<a name="ln1351">             * 0 0 0 0 0</a>
<a name="ln1352">             * 0 0 X 0 0</a>
<a name="ln1353">             * 0 0 X 0 0        ↑</a>
<a name="ln1354">             * 0 0 X 0 0</a>
<a name="ln1355">             * 0 0 1 0 0</a>
<a name="ln1356">             */</a>
<a name="ln1357">            for (rank = targetRank - 1; rank &gt;= 1; --rank)</a>
<a name="ln1358">            {</a>
<a name="ln1359">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, targetFile);</a>
<a name="ln1360">            }</a>
<a name="ln1361"> </a>
<a name="ln1362">            return attacks;</a>
<a name="ln1363">        }</a>
<a name="ln1364"> </a>
<a name="ln1365">        /// &lt;summary&gt;</a>
<a name="ln1366">        /// Populate occupancy sets from Bishop or Rook attack masks depending on &lt;paramref name=&quot;index&quot;/&gt;</a>
<a name="ln1367">        /// &lt;/summary&gt;</a>
<a name="ln1368">        /// &lt;param name=&quot;index&quot;&gt;</a>
<a name="ln1369">        /// Index within the range of possible occupancies within the bitboard.</a>
<a name="ln1370">        /// Between 0 and &lt;paramref name=&quot;occupancyMask&quot;/&gt;.CountBits() - 1</a>
<a name="ln1371">        /// &lt;/param&gt;</a>
<a name="ln1372">        /// &lt;param name=&quot;occupancyMask&quot;&gt;Bishop or rook occupancy (&lt;see cref=&quot;AttackGenerator.MaskBishopOccupancy(int)&quot;/&gt; and &lt;see cref=&quot;AttackGenerator.MaskRookOccupancy(int)&quot;/&gt;)&lt;/param&gt;</a>
<a name="ln1373">        /// &lt;returns&gt;An occupancy set for the given index&lt;/returns&gt;</a>
<a name="ln1374">        public static BitBoard SetBishopOrRookOccupancy(int index, BitBoard occupancyMask)</a>
<a name="ln1375">        {</a>
<a name="ln1376">            var bitsInMask = occupancyMask.CountBits();</a>
<a name="ln1377">            var occupancy = new BitBoard();</a>
<a name="ln1378"> </a>
<a name="ln1379">            // Loop over the range of bits within attack mask</a>
<a name="ln1380">            for (int count = 0; count &lt; bitsInMask; ++count)</a>
<a name="ln1381">            {</a>
<a name="ln1382">                // Extract LS1B and reset it</a>
<a name="ln1383">                int squareIndex = occupancyMask.GetLS1BIndex();</a>
<a name="ln1384">                occupancyMask.PopBit(squareIndex);</a>
<a name="ln1385"> </a>
<a name="ln1386">                // Make sure occupancy is on board</a>
<a name="ln1387">                if ((index &amp; (1 &lt;&lt; count)) != default)</a>
<a name="ln1388">                {</a>
<a name="ln1389">                    // Update occupancy</a>
<a name="ln1390">                    occupancy.SetBit(squareIndex);</a>
<a name="ln1391">                }</a>
<a name="ln1392">            }</a>
<a name="ln1393"> </a>
<a name="ln1394">            return occupancy;</a>
<a name="ln1395">        }</a>
<a name="ln1396"> </a>
<a name="ln1397">        public static BitBoard GenerateBishopAttacksOnTheFly(int squareIndex, BitBoard occupiedSquares)</a>
<a name="ln1398">        {</a>
<a name="ln1399">            // Results attack bitboard</a>
<a name="ln1400">            BitBoard attacks = default;</a>
<a name="ln1401"> </a>
<a name="ln1402">            int rank, file;</a>
<a name="ln1403"> </a>
<a name="ln1404">            // Next target square within the attack ray of a sliding piece</a>
<a name="ln1405">            int targetRank = Math.DivRem(squareIndex, 8, out int targetFile);</a>
<a name="ln1406"> </a>
<a name="ln1407">            // Generate bishop attacks</a>
<a name="ln1408"> </a>
<a name="ln1409">            /*</a>
<a name="ln1410">             * 0 0 0 0 0</a>
<a name="ln1411">             * 0 1 0 0 0</a>
<a name="ln1412">             * 0 0 X 0 0        ↘️</a>
<a name="ln1413">             * 0 0 0 X 0</a>
<a name="ln1414">             * 0 0 0 0 0</a>
<a name="ln1415">             */</a>
<a name="ln1416">            for (rank = targetRank + 1, file = targetFile + 1; rank &lt;= 7 &amp;&amp; file &lt;= 7; ++rank, ++file)</a>
<a name="ln1417">            {</a>
<a name="ln1418">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln1419">                attacks |= square;</a>
<a name="ln1420"> </a>
<a name="ln1421">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln1422">                {</a>
<a name="ln1423">                    break;</a>
<a name="ln1424">                }</a>
<a name="ln1425">            }</a>
<a name="ln1426"> </a>
<a name="ln1427">            /*</a>
<a name="ln1428">             * 0 0 0 0 0</a>
<a name="ln1429">             * 0 X 0 0 0</a>
<a name="ln1430">             * 0 0 X 0 0        ↖️</a>
<a name="ln1431">             * 0 0 0 1 0</a>
<a name="ln1432">             * 0 0 0 0 0</a>
<a name="ln1433">             */</a>
<a name="ln1434">            for (rank = targetRank - 1, file = targetFile - 1; rank &gt;= 0 &amp;&amp; file &gt;= 0; --rank, --file)</a>
<a name="ln1435">            {</a>
<a name="ln1436">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln1437">                attacks |= square;</a>
<a name="ln1438"> </a>
<a name="ln1439">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln1440">                {</a>
<a name="ln1441">                    break;</a>
<a name="ln1442">                }</a>
<a name="ln1443">            }</a>
<a name="ln1444"> </a>
<a name="ln1445">            /*</a>
<a name="ln1446">             * 0 0 0 0 0</a>
<a name="ln1447">             * 0 0 0 X 0</a>
<a name="ln1448">             * 0 0 X 0 0        ↗️</a>
<a name="ln1449">             * 0 1 0 0 0</a>
<a name="ln1450">             * 0 0 0 0 0</a>
<a name="ln1451">             */</a>
<a name="ln1452">            for (rank = targetRank - 1, file = targetFile + 1; rank &gt;= 0 &amp;&amp; file &lt;= 7; --rank, ++file)</a>
<a name="ln1453">            {</a>
<a name="ln1454">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln1455">                attacks |= square;</a>
<a name="ln1456"> </a>
<a name="ln1457">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln1458">                {</a>
<a name="ln1459">                    break;</a>
<a name="ln1460">                }</a>
<a name="ln1461">            }</a>
<a name="ln1462"> </a>
<a name="ln1463">            /*</a>
<a name="ln1464">             * 0 0 0 0 0</a>
<a name="ln1465">             * 0 0 0 1 0</a>
<a name="ln1466">             * 0 0 X 0 0        ↙️</a>
<a name="ln1467">             * 0 X 0 0 0</a>
<a name="ln1468">             * 0 0 0 0 0</a>
<a name="ln1469">             */</a>
<a name="ln1470">            for (rank = targetRank + 1, file = targetFile - 1; rank &lt;= 7 &amp;&amp; file &gt;= 0; ++rank, --file)</a>
<a name="ln1471">            {</a>
<a name="ln1472">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln1473">                attacks |= square;</a>
<a name="ln1474"> </a>
<a name="ln1475">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln1476">                {</a>
<a name="ln1477">                    break;</a>
<a name="ln1478">                }</a>
<a name="ln1479">            }</a>
<a name="ln1480"> </a>
<a name="ln1481">            return attacks;</a>
<a name="ln1482">        }</a>
<a name="ln1483"> </a>
<a name="ln1484">        public static BitBoard GenerateRookAttacksOnTheFly(int squareIndex, BitBoard occupiedSquares)</a>
<a name="ln1485">        {</a>
<a name="ln1486">            // Results attack bitboard</a>
<a name="ln1487">            BitBoard attacks = default;</a>
<a name="ln1488"> </a>
<a name="ln1489">            int rank, file;</a>
<a name="ln1490"> </a>
<a name="ln1491">            // Next target square within the attack ray of a sliding piece</a>
<a name="ln1492">            int targetRank = Math.DivRem(squareIndex, 8, out int targetFile);</a>
<a name="ln1493"> </a>
<a name="ln1494">            // Generate rook attacks</a>
<a name="ln1495"> </a>
<a name="ln1496">            /*</a>
<a name="ln1497">             * 0 0 0 0 0</a>
<a name="ln1498">             * 0 0 0 0 0</a>
<a name="ln1499">             * 1 X X X 0      →</a>
<a name="ln1500">             * 0 0 0 0 0</a>
<a name="ln1501">             * 0 0 0 0 0</a>
<a name="ln1502">             */</a>
<a name="ln1503">            for (file = targetFile + 1; file &lt;= 7; ++file)</a>
<a name="ln1504">            {</a>
<a name="ln1505">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(targetRank, file);</a>
<a name="ln1506">                attacks |= square;</a>
<a name="ln1507"> </a>
<a name="ln1508">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln1509">                {</a>
<a name="ln1510">                    break;</a>
<a name="ln1511">                }</a>
<a name="ln1512">            }</a>
<a name="ln1513"> </a>
<a name="ln1514">            /*</a>
<a name="ln1515">             * 0 0 0 0 0</a>
<a name="ln1516">             * 0 0 0 0 0</a>
<a name="ln1517">             * 0 X X X 1        ←</a>
<a name="ln1518">             * 0 0 0 0 0</a>
<a name="ln1519">             * 0 0 0 0 0</a>
<a name="ln1520">             */</a>
<a name="ln1521">            for (file = targetFile - 1; file &gt;= 0; --file)</a>
<a name="ln1522">            {</a>
<a name="ln1523">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(targetRank, file);</a>
<a name="ln1524">                attacks |= square;</a>
<a name="ln1525"> </a>
<a name="ln1526">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln1527">                {</a>
<a name="ln1528">                    break;</a>
<a name="ln1529">                }</a>
<a name="ln1530">            }</a>
<a name="ln1531"> </a>
<a name="ln1532">            /*</a>
<a name="ln1533">             * 0 0 1 0 0</a>
<a name="ln1534">             * 0 0 X 0 0</a>
<a name="ln1535">             * 0 0 X 0 0        ↓</a>
<a name="ln1536">             * 0 0 X 0 0</a>
<a name="ln1537">             * 0 0 0 0 0</a>
<a name="ln1538">             */</a>
<a name="ln1539">            for (rank = targetRank + 1; rank &lt;= 7; ++rank)</a>
<a name="ln1540">            {</a>
<a name="ln1541">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, targetFile);</a>
<a name="ln1542">                attacks |= square;</a>
<a name="ln1543"> </a>
<a name="ln1544">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln1545">                {</a>
<a name="ln1546">                    break;</a>
<a name="ln1547">                }</a>
<a name="ln1548">            }</a>
<a name="ln1549"> </a>
<a name="ln1550">            /*</a>
<a name="ln1551">             * 0 0 0 0 0</a>
<a name="ln1552">             * 0 0 X 0 0</a>
<a name="ln1553">             * 0 0 X 0 0        ↑</a>
<a name="ln1554">             * 0 0 X 0 0</a>
<a name="ln1555">             * 0 0 1 0 0</a>
<a name="ln1556">             */</a>
<a name="ln1557">            for (rank = targetRank - 1; rank &gt;= 0; --rank)</a>
<a name="ln1558">            {</a>
<a name="ln1559">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, targetFile);</a>
<a name="ln1560">                attacks |= square;</a>
<a name="ln1561"> </a>
<a name="ln1562">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln1563">                {</a>
<a name="ln1564">                    break;</a>
<a name="ln1565">                }</a>
<a name="ln1566">            }</a>
<a name="ln1567"> </a>
<a name="ln1568">            return attacks;</a>
<a name="ln1569">        }</a>
<a name="ln1570">    }</a>
<a name="ln1571"> </a>
<a name="ln1572">    private static class SkipLocalsInit_AttackGenerator_Other</a>
<a name="ln1573">    {</a>
<a name="ln1574">        /// &lt;summary&gt;</a>
<a name="ln1575">        /// BitBoard[isWhite, square]</a>
<a name="ln1576">        /// &lt;/summary&gt;</a>
<a name="ln1577">        public static BitBoard[][] InitializePawnAttacks()</a>
<a name="ln1578">        {</a>
<a name="ln1579">            BitBoard[][] pawnAttacks = [new BitBoard[64], new BitBoard[64]];</a>
<a name="ln1580"> </a>
<a name="ln1581">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln1582">            {</a>
<a name="ln1583">                pawnAttacks[0][square] = MaskPawnAttacks(square, isWhite: false);</a>
<a name="ln1584">                pawnAttacks[1][square] = MaskPawnAttacks(square, isWhite: true);</a>
<a name="ln1585">            }</a>
<a name="ln1586"> </a>
<a name="ln1587">            return pawnAttacks;</a>
<a name="ln1588">        }</a>
<a name="ln1589"> </a>
<a name="ln1590">        public static BitBoard[] InitializeKnightAttacks()</a>
<a name="ln1591">        {</a>
<a name="ln1592">            return Enumerable.Range(0, 64)</a>
<a name="ln1593">                .Select(MaskKnightAttacks)</a>
<a name="ln1594">                .ToArray();</a>
<a name="ln1595">        }</a>
<a name="ln1596"> </a>
<a name="ln1597">        public static BitBoard[] InitializeKingAttacks()</a>
<a name="ln1598">        {</a>
<a name="ln1599">            return Enumerable.Range(0, 64)</a>
<a name="ln1600">                .Select(MaskKingAttacks)</a>
<a name="ln1601">                .ToArray();</a>
<a name="ln1602">        }</a>
<a name="ln1603"> </a>
<a name="ln1604">        public static BitBoard[] InitializeBishopOccupancy()</a>
<a name="ln1605">        {</a>
<a name="ln1606">            return Enumerable.Range(0, 64)</a>
<a name="ln1607">                .Select(MaskBishopOccupancy)</a>
<a name="ln1608">                .ToArray();</a>
<a name="ln1609">        }</a>
<a name="ln1610"> </a>
<a name="ln1611">        public static BitBoard[] InitializeRookOccupancy()</a>
<a name="ln1612">        {</a>
<a name="ln1613">            return Enumerable.Range(0, 64)</a>
<a name="ln1614">                .Select(MaskRookOccupancy)</a>
<a name="ln1615">                .ToArray();</a>
<a name="ln1616">        }</a>
<a name="ln1617"> </a>
<a name="ln1618">        /// &lt;summary&gt;</a>
<a name="ln1619">        /// Returns bishop occupancy masks and attacks</a>
<a name="ln1620">        /// &lt;/summary&gt;</a>
<a name="ln1621">        /// &lt;returns&gt;(BitBoard[64], BitBoard[64, 512])&lt;/returns&gt;</a>
<a name="ln1622">        public static (BitBoard[] BishopOccupancyMasks, BitBoard[,] BishopAttacks) InitializeBishopMagicAttacks()</a>
<a name="ln1623">        {</a>
<a name="ln1624">            BitBoard[] occupancyMasks = new BitBoard[64];</a>
<a name="ln1625">            BitBoard[,] attacks = new BitBoard[64, 512];</a>
<a name="ln1626"> </a>
<a name="ln1627">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln1628">            {</a>
<a name="ln1629">                occupancyMasks[square] = MaskBishopOccupancy(square);</a>
<a name="ln1630"> </a>
<a name="ln1631">                var relevantBitsCount = Constants.BishopRelevantOccupancyBits[square];</a>
<a name="ln1632"> </a>
<a name="ln1633">                int occupancyIndexes = (1 &lt;&lt; relevantBitsCount);</a>
<a name="ln1634"> </a>
<a name="ln1635">                for (int index = 0; index &lt; occupancyIndexes; ++index)</a>
<a name="ln1636">                {</a>
<a name="ln1637">                    var occupancy = SetBishopOrRookOccupancy(index, occupancyMasks[square]);</a>
<a name="ln1638"> </a>
<a name="ln1639">                    var magicIndex = (occupancy * Constants.BishopMagicNumbers[square]) &gt;&gt; (64 - relevantBitsCount);</a>
<a name="ln1640"> </a>
<a name="ln1641">                    attacks[square, magicIndex] = GenerateBishopAttacksOnTheFly(square, occupancy);</a>
<a name="ln1642">                }</a>
<a name="ln1643">            }</a>
<a name="ln1644"> </a>
<a name="ln1645">            return (occupancyMasks, attacks);</a>
<a name="ln1646">        }</a>
<a name="ln1647"> </a>
<a name="ln1648">        /// &lt;summary&gt;</a>
<a name="ln1649">        /// Returns rook occupancy masks and attacks</a>
<a name="ln1650">        /// &lt;/summary&gt;</a>
<a name="ln1651">        /// &lt;returns&gt;(BitBoard[64], BitBoard[64, 512])&lt;/returns&gt;</a>
<a name="ln1652">        public static (BitBoard[] RookOccupancyMasks, BitBoard[,] RookAttacks) InitializeRookMagicAttacks()</a>
<a name="ln1653">        {</a>
<a name="ln1654">            BitBoard[] occupancyMasks = new BitBoard[64];</a>
<a name="ln1655">            BitBoard[,] attacks = new BitBoard[64, 4096];</a>
<a name="ln1656"> </a>
<a name="ln1657">            for (int square = 0; square &lt; 64; ++square)</a>
<a name="ln1658">            {</a>
<a name="ln1659">                occupancyMasks[square] = MaskRookOccupancy(square);</a>
<a name="ln1660"> </a>
<a name="ln1661">                var relevantBitsCount = Constants.RookRelevantOccupancyBits[square];</a>
<a name="ln1662"> </a>
<a name="ln1663">                int occupancyIndexes = (1 &lt;&lt; relevantBitsCount);</a>
<a name="ln1664"> </a>
<a name="ln1665">                for (int index = 0; index &lt; occupancyIndexes; ++index)</a>
<a name="ln1666">                {</a>
<a name="ln1667">                    var occupancy = SetBishopOrRookOccupancy(index, occupancyMasks[square]);</a>
<a name="ln1668"> </a>
<a name="ln1669">                    var magicIndex = (occupancy * Constants.RookMagicNumbers[square]) &gt;&gt; (64 - relevantBitsCount);</a>
<a name="ln1670"> </a>
<a name="ln1671">                    attacks[square, magicIndex] = GenerateRookAttacksOnTheFly(square, occupancy);</a>
<a name="ln1672">                }</a>
<a name="ln1673">            }</a>
<a name="ln1674"> </a>
<a name="ln1675">            return (occupancyMasks, attacks);</a>
<a name="ln1676">        }</a>
<a name="ln1677"> </a>
<a name="ln1678">        public static BitBoard MaskPawnAttacks(int squareIndex, bool isWhite)</a>
<a name="ln1679">        {</a>
<a name="ln1680">            // Results attack bitboard</a>
<a name="ln1681">            BitBoard attacks = default;</a>
<a name="ln1682"> </a>
<a name="ln1683">            // Piece bitboard</a>
<a name="ln1684">            BitBoard bitBoard = default;</a>
<a name="ln1685"> </a>
<a name="ln1686">            // Set piece on board</a>
<a name="ln1687">            bitBoard.SetBit(squareIndex);</a>
<a name="ln1688"> </a>
<a name="ln1689">            if (isWhite)</a>
<a name="ln1690">            {</a>
<a name="ln1691">                /*</a>
<a name="ln1692">                 * 0 0 0 X 0</a>
<a name="ln1693">                 * 0 0 1 0 0</a>
<a name="ln1694">                 * 0 0 0 0 0</a>
<a name="ln1695">                 */</a>
<a name="ln1696">                var right = bitBoard &gt;&gt; 7;</a>
<a name="ln1697">                if ((right &amp; Constants.NotAFile) != default)</a>
<a name="ln1698">                {</a>
<a name="ln1699">                    attacks |= right;</a>
<a name="ln1700">                }</a>
<a name="ln1701"> </a>
<a name="ln1702">                /*</a>
<a name="ln1703">                 * 0 X 0 0 0</a>
<a name="ln1704">                 * 0 0 1 0 0</a>
<a name="ln1705">                 * 0 0 0 0 0</a>
<a name="ln1706">                 */</a>
<a name="ln1707">                var left = bitBoard &gt;&gt; 9;</a>
<a name="ln1708">                if ((left &amp; Constants.NotHFile) != default)</a>
<a name="ln1709">                {</a>
<a name="ln1710">                    attacks |= left;</a>
<a name="ln1711">                }</a>
<a name="ln1712">            }</a>
<a name="ln1713">            else</a>
<a name="ln1714">            {</a>
<a name="ln1715">                /*</a>
<a name="ln1716">                 * 0 0 0 0 0</a>
<a name="ln1717">                 * 0 0 1 0 0</a>
<a name="ln1718">                 * 0 X 0 0 0</a>
<a name="ln1719">                 */</a>
<a name="ln1720">                var left = bitBoard &lt;&lt; 7;</a>
<a name="ln1721">                if ((left &amp; Constants.NotHFile) != default)</a>
<a name="ln1722">                {</a>
<a name="ln1723">                    attacks |= left;</a>
<a name="ln1724">                }</a>
<a name="ln1725"> </a>
<a name="ln1726">                /*</a>
<a name="ln1727">                 * 0 0 0 0 0</a>
<a name="ln1728">                 * 0 0 1 0 0</a>
<a name="ln1729">                 * 0 0 0 X 0</a>
<a name="ln1730">                 */</a>
<a name="ln1731">                var right = bitBoard &lt;&lt; 9;</a>
<a name="ln1732">                if ((right &amp; Constants.NotAFile) != default)</a>
<a name="ln1733">                {</a>
<a name="ln1734">                    attacks |= right;</a>
<a name="ln1735">                }</a>
<a name="ln1736">            }</a>
<a name="ln1737"> </a>
<a name="ln1738">            return attacks;</a>
<a name="ln1739">        }</a>
<a name="ln1740"> </a>
<a name="ln1741">        public static BitBoard MaskKnightAttacks(int squareIndex)</a>
<a name="ln1742">        {</a>
<a name="ln1743">            // Results attack bitboard</a>
<a name="ln1744">            BitBoard attacks = default;</a>
<a name="ln1745"> </a>
<a name="ln1746">            // Piece bitboard</a>
<a name="ln1747">            BitBoard bitBoard = default;</a>
<a name="ln1748"> </a>
<a name="ln1749">            // Set piece on board</a>
<a name="ln1750">            bitBoard.SetBit(squareIndex);</a>
<a name="ln1751"> </a>
<a name="ln1752">            /*</a>
<a name="ln1753">             * 0 X 0 0 0</a>
<a name="ln1754">             * 0 0 0 0 0</a>
<a name="ln1755">             * 0 0 1 0 0</a>
<a name="ln1756">             * 0 0 0 0 0</a>
<a name="ln1757">             * 0 0 0 0 0</a>
<a name="ln1758">             */</a>
<a name="ln1759">            var attack = bitBoard &gt;&gt; 17;</a>
<a name="ln1760">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln1761">            {</a>
<a name="ln1762">                attacks |= attack;</a>
<a name="ln1763">            }</a>
<a name="ln1764"> </a>
<a name="ln1765">            /*</a>
<a name="ln1766">             * 0 0 0 X 0</a>
<a name="ln1767">             * 0 0 0 0 0</a>
<a name="ln1768">             * 0 0 1 0 0</a>
<a name="ln1769">             * 0 0 0 0 0</a>
<a name="ln1770">             * 0 0 0 0 0</a>
<a name="ln1771">             */</a>
<a name="ln1772">            attack = bitBoard &gt;&gt; 15;</a>
<a name="ln1773">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln1774">            {</a>
<a name="ln1775">                attacks |= attack;</a>
<a name="ln1776">            }</a>
<a name="ln1777"> </a>
<a name="ln1778">            /*</a>
<a name="ln1779">             * 0 0 0 0 0</a>
<a name="ln1780">             * 0 0 0 0 0</a>
<a name="ln1781">             * 0 0 1 0 0</a>
<a name="ln1782">             * 0 0 0 0 0</a>
<a name="ln1783">             * 0 X 0 0 0</a>
<a name="ln1784">             */</a>
<a name="ln1785">            attack = bitBoard &lt;&lt; 15;</a>
<a name="ln1786">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln1787">            {</a>
<a name="ln1788">                attacks |= attack;</a>
<a name="ln1789">            }</a>
<a name="ln1790"> </a>
<a name="ln1791">            /*</a>
<a name="ln1792">             * 0 0 0 0 0</a>
<a name="ln1793">             * 0 0 0 0 0</a>
<a name="ln1794">             * 0 0 1 0 0</a>
<a name="ln1795">             * 0 0 0 0 0</a>
<a name="ln1796">             * 0 0 0 X 0</a>
<a name="ln1797">             */</a>
<a name="ln1798">            attack = bitBoard &lt;&lt; 17;</a>
<a name="ln1799">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln1800">            {</a>
<a name="ln1801">                attacks |= attack;</a>
<a name="ln1802">            }</a>
<a name="ln1803"> </a>
<a name="ln1804">            /*</a>
<a name="ln1805">             * 0 0 0 0 0</a>
<a name="ln1806">             * X 0 0 0 0</a>
<a name="ln1807">             * 0 0 1 0 0</a>
<a name="ln1808">             * 0 0 0 0 0</a>
<a name="ln1809">             * 0 0 0 0 0</a>
<a name="ln1810">             */</a>
<a name="ln1811">            attack = bitBoard &gt;&gt; 10;</a>
<a name="ln1812">            if ((attack &amp; Constants.NotHGFiles) != default)</a>
<a name="ln1813">            {</a>
<a name="ln1814">                attacks |= attack;</a>
<a name="ln1815">            }</a>
<a name="ln1816"> </a>
<a name="ln1817">            /*</a>
<a name="ln1818">             * 0 0 0 0 0</a>
<a name="ln1819">             * 0 0 0 0 X</a>
<a name="ln1820">             * 0 0 1 0 0</a>
<a name="ln1821">             * 0 0 0 0 0</a>
<a name="ln1822">             * 0 0 0 0 0</a>
<a name="ln1823">             */</a>
<a name="ln1824">            attack = bitBoard &gt;&gt; 6;</a>
<a name="ln1825">            if ((attack &amp; Constants.NotABFiles) != default)</a>
<a name="ln1826">            {</a>
<a name="ln1827">                attacks |= attack;</a>
<a name="ln1828">            }</a>
<a name="ln1829"> </a>
<a name="ln1830">            /*</a>
<a name="ln1831">             * 0 0 0 0 0</a>
<a name="ln1832">             * 0 0 0 0 0</a>
<a name="ln1833">             * 0 0 1 0 0</a>
<a name="ln1834">             * X 0 0 0 0</a>
<a name="ln1835">             * 0 0 0 0 0</a>
<a name="ln1836">             */</a>
<a name="ln1837">            attack = bitBoard &lt;&lt; 6;</a>
<a name="ln1838">            if ((attack &amp; Constants.NotHGFiles) != default)</a>
<a name="ln1839">            {</a>
<a name="ln1840">                attacks |= attack;</a>
<a name="ln1841">            }</a>
<a name="ln1842"> </a>
<a name="ln1843">            /*</a>
<a name="ln1844">             * 0 0 0 0 0</a>
<a name="ln1845">             * 0 0 0 0 0</a>
<a name="ln1846">             * 0 0 1 0 0</a>
<a name="ln1847">             * 0 0 0 0 X</a>
<a name="ln1848">             * 0 0 0 0 0</a>
<a name="ln1849">             */</a>
<a name="ln1850">            attack = bitBoard &lt;&lt; 10;</a>
<a name="ln1851">            if ((attack &amp; Constants.NotABFiles) != default)</a>
<a name="ln1852">            {</a>
<a name="ln1853">                attacks |= attack;</a>
<a name="ln1854">            }</a>
<a name="ln1855"> </a>
<a name="ln1856">            return attacks;</a>
<a name="ln1857">        }</a>
<a name="ln1858"> </a>
<a name="ln1859">        public static BitBoard MaskKingAttacks(int squareIndex)</a>
<a name="ln1860">        {</a>
<a name="ln1861">            // Results attack bitboard</a>
<a name="ln1862">            BitBoard attacks = default;</a>
<a name="ln1863"> </a>
<a name="ln1864">            // Piece bitboard</a>
<a name="ln1865">            BitBoard bitBoard = default;</a>
<a name="ln1866"> </a>
<a name="ln1867">            // Set piece on board</a>
<a name="ln1868">            bitBoard.SetBit(squareIndex);</a>
<a name="ln1869"> </a>
<a name="ln1870">            /*</a>
<a name="ln1871">             * X 0 0</a>
<a name="ln1872">             * 0 1 0</a>
<a name="ln1873">             * 0 0 0</a>
<a name="ln1874">             */</a>
<a name="ln1875">            var attack = bitBoard &gt;&gt; 9;</a>
<a name="ln1876">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln1877">            {</a>
<a name="ln1878">                attacks |= attack;</a>
<a name="ln1879">            }</a>
<a name="ln1880"> </a>
<a name="ln1881">            /*</a>
<a name="ln1882">             * 0 X 0</a>
<a name="ln1883">             * 0 1 0</a>
<a name="ln1884">             * 0 0 0</a>
<a name="ln1885">             */</a>
<a name="ln1886">            attacks |= bitBoard &gt;&gt; 8;</a>
<a name="ln1887"> </a>
<a name="ln1888">            /*</a>
<a name="ln1889">             * 0 0 X</a>
<a name="ln1890">             * 0 1 0</a>
<a name="ln1891">             * 0 0 0</a>
<a name="ln1892">             */</a>
<a name="ln1893">            attack = bitBoard &gt;&gt; 7;</a>
<a name="ln1894">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln1895">            {</a>
<a name="ln1896">                attacks |= attack;</a>
<a name="ln1897">            }</a>
<a name="ln1898"> </a>
<a name="ln1899">            /*</a>
<a name="ln1900">             * 0 0 0</a>
<a name="ln1901">             * X 1 0</a>
<a name="ln1902">             * 0 0 0</a>
<a name="ln1903">             */</a>
<a name="ln1904">            attack = bitBoard &gt;&gt; 1;</a>
<a name="ln1905">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln1906">            {</a>
<a name="ln1907">                attacks |= attack;</a>
<a name="ln1908">            }</a>
<a name="ln1909"> </a>
<a name="ln1910">            /*</a>
<a name="ln1911">             * 0 0 0</a>
<a name="ln1912">             * 0 1 X</a>
<a name="ln1913">             * 0 0 0</a>
<a name="ln1914">             */</a>
<a name="ln1915">            attack = bitBoard &lt;&lt; 1;</a>
<a name="ln1916">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln1917">            {</a>
<a name="ln1918">                attacks |= attack;</a>
<a name="ln1919">            }</a>
<a name="ln1920"> </a>
<a name="ln1921">            /*</a>
<a name="ln1922">             * 0 0 0</a>
<a name="ln1923">             * 0 1 0</a>
<a name="ln1924">             * X 0 0</a>
<a name="ln1925">             */</a>
<a name="ln1926">            attack = bitBoard &lt;&lt; 7;</a>
<a name="ln1927">            if ((attack &amp; Constants.NotHFile) != default)</a>
<a name="ln1928">            {</a>
<a name="ln1929">                attacks |= attack;</a>
<a name="ln1930">            }</a>
<a name="ln1931"> </a>
<a name="ln1932">            /*</a>
<a name="ln1933">             * 0 0 0</a>
<a name="ln1934">             * 0 1 0</a>
<a name="ln1935">             * 0 X 0</a>
<a name="ln1936">             */</a>
<a name="ln1937">            attacks |= bitBoard &lt;&lt; 8;</a>
<a name="ln1938"> </a>
<a name="ln1939">            /*</a>
<a name="ln1940">             * 0 0 0</a>
<a name="ln1941">             * 0 1 0</a>
<a name="ln1942">             * X 0 0</a>
<a name="ln1943">             */</a>
<a name="ln1944">            attack = bitBoard &lt;&lt; 9;</a>
<a name="ln1945">            if ((attack &amp; Constants.NotAFile) != default)</a>
<a name="ln1946">            {</a>
<a name="ln1947">                attacks |= attack;</a>
<a name="ln1948">            }</a>
<a name="ln1949"> </a>
<a name="ln1950">            return attacks;</a>
<a name="ln1951">        }</a>
<a name="ln1952"> </a>
<a name="ln1953">        /// &lt;summary&gt;</a>
<a name="ln1954">        /// Returns relevant 'bishop occupancy squares' (attacks)</a>
<a name="ln1955">        /// Outer squares don't matter in terms of occupancy (see https://www.chessprogramming.org/First_Rank_Attacks#TheOuterSquares)</a>
<a name="ln1956">        /// Therefore, there are max 6 occupancy squares per direction (if a bishop is placed on a corner)</a>
<a name="ln1957">        /// &lt;/summary&gt;</a>
<a name="ln1958">        public static BitBoard MaskBishopOccupancy(int squareIndex)</a>
<a name="ln1959">        {</a>
<a name="ln1960">            // Results attack bitboard</a>
<a name="ln1961">            BitBoard attacks = default;</a>
<a name="ln1962"> </a>
<a name="ln1963">            int rank, file;</a>
<a name="ln1964"> </a>
<a name="ln1965">            // Next target square within the attack ray of a sliding piece</a>
<a name="ln1966">            int targetRank = Math.DivRem(squareIndex, 8, out int targetFile);</a>
<a name="ln1967"> </a>
<a name="ln1968">            // Mask relevant bishop occupancy bits (squares)</a>
<a name="ln1969"> </a>
<a name="ln1970">            /*</a>
<a name="ln1971">             * 0 0 0 0 0</a>
<a name="ln1972">             * 0 1 0 0 0</a>
<a name="ln1973">             * 0 0 X 0 0        ↘️</a>
<a name="ln1974">             * 0 0 0 X 0</a>
<a name="ln1975">             * 0 0 0 0 0</a>
<a name="ln1976">             */</a>
<a name="ln1977">            for (rank = targetRank + 1, file = targetFile + 1; rank &lt;= 6 &amp;&amp; file &lt;= 6; ++rank, ++file)</a>
<a name="ln1978">            {</a>
<a name="ln1979">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln1980">            }</a>
<a name="ln1981"> </a>
<a name="ln1982">            /*</a>
<a name="ln1983">             * 0 0 0 0 0</a>
<a name="ln1984">             * 0 X 0 0 0</a>
<a name="ln1985">             * 0 0 X 0 0        ↖️</a>
<a name="ln1986">             * 0 0 0 1 0</a>
<a name="ln1987">             * 0 0 0 0 0</a>
<a name="ln1988">             */</a>
<a name="ln1989">            for (rank = targetRank - 1, file = targetFile - 1; rank &gt;= 1 &amp;&amp; file &gt;= 1; --rank, --file)</a>
<a name="ln1990">            {</a>
<a name="ln1991">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln1992">            }</a>
<a name="ln1993"> </a>
<a name="ln1994">            /*</a>
<a name="ln1995">             * 0 0 0 0 0</a>
<a name="ln1996">             * 0 0 0 X 0</a>
<a name="ln1997">             * 0 0 X 0 0        ↗️</a>
<a name="ln1998">             * 0 1 0 0 0</a>
<a name="ln1999">             * 0 0 0 0 0</a>
<a name="ln2000">             */</a>
<a name="ln2001">            for (rank = targetRank - 1, file = targetFile + 1; rank &gt;= 1 &amp;&amp; file &lt;= 6; --rank, ++file)</a>
<a name="ln2002">            {</a>
<a name="ln2003">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln2004">            }</a>
<a name="ln2005"> </a>
<a name="ln2006">            /*</a>
<a name="ln2007">             * 0 0 0 0 0</a>
<a name="ln2008">             * 0 0 0 1 0</a>
<a name="ln2009">             * 0 0 X 0 0        ↙️</a>
<a name="ln2010">             * 0 X 0 0 0</a>
<a name="ln2011">             * 0 0 0 0 0</a>
<a name="ln2012">             */</a>
<a name="ln2013">            for (rank = targetRank + 1, file = targetFile - 1; rank &lt;= 6 &amp;&amp; file &gt;= 1; ++rank, --file)</a>
<a name="ln2014">            {</a>
<a name="ln2015">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln2016">            }</a>
<a name="ln2017"> </a>
<a name="ln2018">            return attacks;</a>
<a name="ln2019">        }</a>
<a name="ln2020"> </a>
<a name="ln2021">        /// &lt;summary&gt;</a>
<a name="ln2022">        /// Returns relevant 'rook occupancy squares' (attacks)</a>
<a name="ln2023">        /// Outer squares don't matter in terms of occupancy (see https://www.chessprogramming.org/First_Rank_Attacks#TheOuterSquares)</a>
<a name="ln2024">        /// Therefore, there are max 6 occupancy squares per direction (if a rook is placed on a corner)</a>
<a name="ln2025">        /// &lt;/summary&gt;</a>
<a name="ln2026">        public static BitBoard MaskRookOccupancy(int squareIndex)</a>
<a name="ln2027">        {</a>
<a name="ln2028">            // Results attack bitboard</a>
<a name="ln2029">            BitBoard attacks = default;</a>
<a name="ln2030"> </a>
<a name="ln2031">            int rank, file;</a>
<a name="ln2032"> </a>
<a name="ln2033">            // Next target square within the attack ray of a sliding piece</a>
<a name="ln2034">            int targetRank = Math.DivRem(squareIndex, 8, out int targetFile);</a>
<a name="ln2035"> </a>
<a name="ln2036">            // Mask relevant rook occupancy bits (squares)</a>
<a name="ln2037"> </a>
<a name="ln2038">            /*</a>
<a name="ln2039">             * 0 0 0 0 0</a>
<a name="ln2040">             * 0 0 0 0 0</a>
<a name="ln2041">             * 1 X X X 0      →</a>
<a name="ln2042">             * 0 0 0 0 0</a>
<a name="ln2043">             * 0 0 0 0 0</a>
<a name="ln2044">             */</a>
<a name="ln2045">            for (file = targetFile + 1; file &lt;= 6; ++file)</a>
<a name="ln2046">            {</a>
<a name="ln2047">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(targetRank, file);</a>
<a name="ln2048">            }</a>
<a name="ln2049"> </a>
<a name="ln2050">            /*</a>
<a name="ln2051">             * 0 0 0 0 0</a>
<a name="ln2052">             * 0 0 0 0 0</a>
<a name="ln2053">             * 0 X X X 1        ←</a>
<a name="ln2054">             * 0 0 0 0 0</a>
<a name="ln2055">             * 0 0 0 0 0</a>
<a name="ln2056">             */</a>
<a name="ln2057">            for (file = targetFile - 1; file &gt;= 1; --file)</a>
<a name="ln2058">            {</a>
<a name="ln2059">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(targetRank, file);</a>
<a name="ln2060">            }</a>
<a name="ln2061"> </a>
<a name="ln2062">            /*</a>
<a name="ln2063">             * 0 0 1 0 0</a>
<a name="ln2064">             * 0 0 X 0 0</a>
<a name="ln2065">             * 0 0 X 0 0        ↓</a>
<a name="ln2066">             * 0 0 X 0 0</a>
<a name="ln2067">             * 0 0 0 0 0</a>
<a name="ln2068">             */</a>
<a name="ln2069">            for (rank = targetRank + 1; rank &lt;= 6; ++rank)</a>
<a name="ln2070">            {</a>
<a name="ln2071">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, targetFile);</a>
<a name="ln2072">            }</a>
<a name="ln2073"> </a>
<a name="ln2074">            /*</a>
<a name="ln2075">             * 0 0 0 0 0</a>
<a name="ln2076">             * 0 0 X 0 0</a>
<a name="ln2077">             * 0 0 X 0 0        ↑</a>
<a name="ln2078">             * 0 0 X 0 0</a>
<a name="ln2079">             * 0 0 1 0 0</a>
<a name="ln2080">             */</a>
<a name="ln2081">            for (rank = targetRank - 1; rank &gt;= 1; --rank)</a>
<a name="ln2082">            {</a>
<a name="ln2083">                attacks |= 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, targetFile);</a>
<a name="ln2084">            }</a>
<a name="ln2085"> </a>
<a name="ln2086">            return attacks;</a>
<a name="ln2087">        }</a>
<a name="ln2088"> </a>
<a name="ln2089">        /// &lt;summary&gt;</a>
<a name="ln2090">        /// Populate occupancy sets from Bishop or Rook attack masks depending on &lt;paramref name=&quot;index&quot;/&gt;</a>
<a name="ln2091">        /// &lt;/summary&gt;</a>
<a name="ln2092">        /// &lt;param name=&quot;index&quot;&gt;</a>
<a name="ln2093">        /// Index within the range of possible occupancies within the bitboard.</a>
<a name="ln2094">        /// Between 0 and &lt;paramref name=&quot;occupancyMask&quot;/&gt;.CountBits() - 1</a>
<a name="ln2095">        /// &lt;/param&gt;</a>
<a name="ln2096">        /// &lt;param name=&quot;occupancyMask&quot;&gt;Bishop or rook occupancy (&lt;see cref=&quot;AttackGenerator.MaskBishopOccupancy(int)&quot;/&gt; and &lt;see cref=&quot;AttackGenerator.MaskRookOccupancy(int)&quot;/&gt;)&lt;/param&gt;</a>
<a name="ln2097">        /// &lt;returns&gt;An occupancy set for the given index&lt;/returns&gt;</a>
<a name="ln2098">        public static BitBoard SetBishopOrRookOccupancy(int index, BitBoard occupancyMask)</a>
<a name="ln2099">        {</a>
<a name="ln2100">            var bitsInMask = occupancyMask.CountBits();</a>
<a name="ln2101">            var occupancy = new BitBoard();</a>
<a name="ln2102"> </a>
<a name="ln2103">            // Loop over the range of bits within attack mask</a>
<a name="ln2104">            for (int count = 0; count &lt; bitsInMask; ++count)</a>
<a name="ln2105">            {</a>
<a name="ln2106">                // Extract LS1B and reset it</a>
<a name="ln2107">                int squareIndex = occupancyMask.GetLS1BIndex();</a>
<a name="ln2108">                occupancyMask.PopBit(squareIndex);</a>
<a name="ln2109"> </a>
<a name="ln2110">                // Make sure occupancy is on board</a>
<a name="ln2111">                if ((index &amp; (1 &lt;&lt; count)) != default)</a>
<a name="ln2112">                {</a>
<a name="ln2113">                    // Update occupancy</a>
<a name="ln2114">                    occupancy.SetBit(squareIndex);</a>
<a name="ln2115">                }</a>
<a name="ln2116">            }</a>
<a name="ln2117"> </a>
<a name="ln2118">            return occupancy;</a>
<a name="ln2119">        }</a>
<a name="ln2120"> </a>
<a name="ln2121">        public static BitBoard GenerateBishopAttacksOnTheFly(int squareIndex, BitBoard occupiedSquares)</a>
<a name="ln2122">        {</a>
<a name="ln2123">            // Results attack bitboard</a>
<a name="ln2124">            BitBoard attacks = default;</a>
<a name="ln2125"> </a>
<a name="ln2126">            int rank, file;</a>
<a name="ln2127"> </a>
<a name="ln2128">            // Next target square within the attack ray of a sliding piece</a>
<a name="ln2129">            int targetRank = Math.DivRem(squareIndex, 8, out int targetFile);</a>
<a name="ln2130"> </a>
<a name="ln2131">            // Generate bishop attacks</a>
<a name="ln2132"> </a>
<a name="ln2133">            /*</a>
<a name="ln2134">             * 0 0 0 0 0</a>
<a name="ln2135">             * 0 1 0 0 0</a>
<a name="ln2136">             * 0 0 X 0 0        ↘️</a>
<a name="ln2137">             * 0 0 0 X 0</a>
<a name="ln2138">             * 0 0 0 0 0</a>
<a name="ln2139">             */</a>
<a name="ln2140">            for (rank = targetRank + 1, file = targetFile + 1; rank &lt;= 7 &amp;&amp; file &lt;= 7; ++rank, ++file)</a>
<a name="ln2141">            {</a>
<a name="ln2142">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln2143">                attacks |= square;</a>
<a name="ln2144"> </a>
<a name="ln2145">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln2146">                {</a>
<a name="ln2147">                    break;</a>
<a name="ln2148">                }</a>
<a name="ln2149">            }</a>
<a name="ln2150"> </a>
<a name="ln2151">            /*</a>
<a name="ln2152">             * 0 0 0 0 0</a>
<a name="ln2153">             * 0 X 0 0 0</a>
<a name="ln2154">             * 0 0 X 0 0        ↖️</a>
<a name="ln2155">             * 0 0 0 1 0</a>
<a name="ln2156">             * 0 0 0 0 0</a>
<a name="ln2157">             */</a>
<a name="ln2158">            for (rank = targetRank - 1, file = targetFile - 1; rank &gt;= 0 &amp;&amp; file &gt;= 0; --rank, --file)</a>
<a name="ln2159">            {</a>
<a name="ln2160">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln2161">                attacks |= square;</a>
<a name="ln2162"> </a>
<a name="ln2163">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln2164">                {</a>
<a name="ln2165">                    break;</a>
<a name="ln2166">                }</a>
<a name="ln2167">            }</a>
<a name="ln2168"> </a>
<a name="ln2169">            /*</a>
<a name="ln2170">             * 0 0 0 0 0</a>
<a name="ln2171">             * 0 0 0 X 0</a>
<a name="ln2172">             * 0 0 X 0 0        ↗️</a>
<a name="ln2173">             * 0 1 0 0 0</a>
<a name="ln2174">             * 0 0 0 0 0</a>
<a name="ln2175">             */</a>
<a name="ln2176">            for (rank = targetRank - 1, file = targetFile + 1; rank &gt;= 0 &amp;&amp; file &lt;= 7; --rank, ++file)</a>
<a name="ln2177">            {</a>
<a name="ln2178">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln2179">                attacks |= square;</a>
<a name="ln2180"> </a>
<a name="ln2181">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln2182">                {</a>
<a name="ln2183">                    break;</a>
<a name="ln2184">                }</a>
<a name="ln2185">            }</a>
<a name="ln2186"> </a>
<a name="ln2187">            /*</a>
<a name="ln2188">             * 0 0 0 0 0</a>
<a name="ln2189">             * 0 0 0 1 0</a>
<a name="ln2190">             * 0 0 X 0 0        ↙️</a>
<a name="ln2191">             * 0 X 0 0 0</a>
<a name="ln2192">             * 0 0 0 0 0</a>
<a name="ln2193">             */</a>
<a name="ln2194">            for (rank = targetRank + 1, file = targetFile - 1; rank &lt;= 7 &amp;&amp; file &gt;= 0; ++rank, --file)</a>
<a name="ln2195">            {</a>
<a name="ln2196">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, file);</a>
<a name="ln2197">                attacks |= square;</a>
<a name="ln2198"> </a>
<a name="ln2199">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln2200">                {</a>
<a name="ln2201">                    break;</a>
<a name="ln2202">                }</a>
<a name="ln2203">            }</a>
<a name="ln2204"> </a>
<a name="ln2205">            return attacks;</a>
<a name="ln2206">        }</a>
<a name="ln2207"> </a>
<a name="ln2208">        public static BitBoard GenerateRookAttacksOnTheFly(int squareIndex, BitBoard occupiedSquares)</a>
<a name="ln2209">        {</a>
<a name="ln2210">            // Results attack bitboard</a>
<a name="ln2211">            BitBoard attacks = default;</a>
<a name="ln2212"> </a>
<a name="ln2213">            int rank, file;</a>
<a name="ln2214"> </a>
<a name="ln2215">            // Next target square within the attack ray of a sliding piece</a>
<a name="ln2216">            int targetRank = Math.DivRem(squareIndex, 8, out int targetFile);</a>
<a name="ln2217"> </a>
<a name="ln2218">            // Generate rook attacks</a>
<a name="ln2219"> </a>
<a name="ln2220">            /*</a>
<a name="ln2221">             * 0 0 0 0 0</a>
<a name="ln2222">             * 0 0 0 0 0</a>
<a name="ln2223">             * 1 X X X 0      →</a>
<a name="ln2224">             * 0 0 0 0 0</a>
<a name="ln2225">             * 0 0 0 0 0</a>
<a name="ln2226">             */</a>
<a name="ln2227">            for (file = targetFile + 1; file &lt;= 7; ++file)</a>
<a name="ln2228">            {</a>
<a name="ln2229">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(targetRank, file);</a>
<a name="ln2230">                attacks |= square;</a>
<a name="ln2231"> </a>
<a name="ln2232">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln2233">                {</a>
<a name="ln2234">                    break;</a>
<a name="ln2235">                }</a>
<a name="ln2236">            }</a>
<a name="ln2237"> </a>
<a name="ln2238">            /*</a>
<a name="ln2239">             * 0 0 0 0 0</a>
<a name="ln2240">             * 0 0 0 0 0</a>
<a name="ln2241">             * 0 X X X 1        ←</a>
<a name="ln2242">             * 0 0 0 0 0</a>
<a name="ln2243">             * 0 0 0 0 0</a>
<a name="ln2244">             */</a>
<a name="ln2245">            for (file = targetFile - 1; file &gt;= 0; --file)</a>
<a name="ln2246">            {</a>
<a name="ln2247">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(targetRank, file);</a>
<a name="ln2248">                attacks |= square;</a>
<a name="ln2249"> </a>
<a name="ln2250">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln2251">                {</a>
<a name="ln2252">                    break;</a>
<a name="ln2253">                }</a>
<a name="ln2254">            }</a>
<a name="ln2255"> </a>
<a name="ln2256">            /*</a>
<a name="ln2257">             * 0 0 1 0 0</a>
<a name="ln2258">             * 0 0 X 0 0</a>
<a name="ln2259">             * 0 0 X 0 0        ↓</a>
<a name="ln2260">             * 0 0 X 0 0</a>
<a name="ln2261">             * 0 0 0 0 0</a>
<a name="ln2262">             */</a>
<a name="ln2263">            for (rank = targetRank + 1; rank &lt;= 7; ++rank)</a>
<a name="ln2264">            {</a>
<a name="ln2265">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, targetFile);</a>
<a name="ln2266">                attacks |= square;</a>
<a name="ln2267"> </a>
<a name="ln2268">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln2269">                {</a>
<a name="ln2270">                    break;</a>
<a name="ln2271">                }</a>
<a name="ln2272">            }</a>
<a name="ln2273"> </a>
<a name="ln2274">            /*</a>
<a name="ln2275">             * 0 0 0 0 0</a>
<a name="ln2276">             * 0 0 X 0 0</a>
<a name="ln2277">             * 0 0 X 0 0        ↑</a>
<a name="ln2278">             * 0 0 X 0 0</a>
<a name="ln2279">             * 0 0 1 0 0</a>
<a name="ln2280">             */</a>
<a name="ln2281">            for (rank = targetRank - 1; rank &gt;= 0; --rank)</a>
<a name="ln2282">            {</a>
<a name="ln2283">                ulong square = 1UL &lt;&lt; BitBoardExtensions.SquareIndex(rank, targetFile);</a>
<a name="ln2284">                attacks |= square;</a>
<a name="ln2285"> </a>
<a name="ln2286">                if ((square &amp; occupiedSquares) != default)</a>
<a name="ln2287">                {</a>
<a name="ln2288">                    break;</a>
<a name="ln2289">                }</a>
<a name="ln2290">            }</a>
<a name="ln2291"> </a>
<a name="ln2292">            return attacks;</a>
<a name="ln2293">        }</a>
<a name="ln2294">    }</a>
<a name="ln2295">}</a>
</code></pre>
<div class="balloon" rel="411"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3060/" target="_blank">V3060</a> A value of variable is not modified. Consider inspecting the expression. It is possible that other value should be present instead of '0'.</p></div>
<div class="balloon" rel="462"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3060/" target="_blank">V3060</a> A value of variable is not modified. Consider inspecting the expression. It is possible that other value should be present instead of '0'.</p></div>
<div class="balloon" rel="1162"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3060/" target="_blank">V3060</a> A value of variable is not modified. Consider inspecting the expression. It is possible that other value should be present instead of '0'.</p></div>
<div class="balloon" rel="1213"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3060/" target="_blank">V3060</a> A value of variable is not modified. Consider inspecting the expression. It is possible that other value should be present instead of '0'.</p></div>
<div class="balloon" rel="1886"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3060/" target="_blank">V3060</a> A value of variable is not modified. Consider inspecting the expression. It is possible that other value should be present instead of '0'.</p></div>
<div class="balloon" rel="1937"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3060/" target="_blank">V3060</a> A value of variable is not modified. Consider inspecting the expression. It is possible that other value should be present instead of '0'.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>