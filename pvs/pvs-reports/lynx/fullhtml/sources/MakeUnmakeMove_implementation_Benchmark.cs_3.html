<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>MakeUnmakeMove_implementation_Benchmark.cs</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cs">
<a name="ln1">ï»¿/*</a>
<a name="ln2"> *</a>
<a name="ln3"> *  BenchmarkDotNet v0.13.12, Ubuntu 22.04.3 LTS (Jammy Jellyfish)</a>
<a name="ln4"> *  AMD EPYC 7763, 1 CPU, 4 logical and 2 physical cores</a>
<a name="ln5"> *  .NET SDK 8.0.101</a>
<a name="ln6"> *    [Host]     : .NET 8.0.1 (8.0.123.58001), X64 RyuJIT AVX2</a>
<a name="ln7"> *    DefaultJob : .NET 8.0.1 (8.0.123.58001), X64 RyuJIT AVX2</a>
<a name="ln8"> *</a>
<a name="ln9"> *  | Method                                             | data                 | Mean         | Error       | StdDev      | Ratio | Gen0       | Allocated     | Alloc Ratio |</a>
<a name="ln10"> *  |--------------------------------------------------- |--------------------- |-------------:|------------:|------------:|------:|-----------:|--------------:|------------:|</a>
<a name="ln11"> *  | NewPosition                                        | (2K2r(...)1, 6) [38] | 397,636.8 us | 1,175.57 us |   917.81 us |  1.00 | 13000.0000 | 1069286.11 KB |        1.00 |</a>
<a name="ln12"> *  | MakeUnmakeMove_Original                            | (2K2r(...)1, 6) [38] | 440,829.8 us | 2,429.95 us | 2,272.97 us |  1.11 |  3000.0000 |  278498.13 KB |        0.26 |</a>
<a name="ln13"> *  | MakeUnmakeMove_WithZobristKey                      | (2K2r(...)1, 6) [38] | 280,883.6 us | 3,071.18 us | 2,722.52 us |  0.71 |  3000.0000 |  278497.61 KB |        0.26 |</a>
<a name="ln14"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (2K2r(...)1, 6) [38] |  22,239.5 us |    93.62 us |    82.99 us |  0.06 |   406.2500 |   35056.14 KB |        0.03 |</a>
<a name="ln15"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (2K2r(...)1, 6) [38] |  21,462.0 us |   131.14 us |   122.67 us |  0.05 |   406.2500 |   35056.14 KB |        0.03 |</a>
<a name="ln16"> *  |                                                    |                      |              |             |             |       |            |               |             |</a>
<a name="ln17"> *  | NewPosition                                        | (3K4/(...)1, 6) [38] | 392,544.0 us | 1,401.80 us | 1,094.43 us |  1.00 | 13000.0000 | 1069286.11 KB |       1.000 |</a>
<a name="ln18"> *  | MakeUnmakeMove_Original                            | (3K4/(...)1, 6) [38] | 442,075.5 us | 3,344.91 us | 2,965.17 us |  1.13 |  3000.0000 |  278498.13 KB |       0.260 |</a>
<a name="ln19"> *  | MakeUnmakeMove_WithZobristKey                      | (3K4/(...)1, 6) [38] | 284,606.2 us | 1,503.41 us | 1,332.74 us |  0.73 |  3000.0000 |  278497.61 KB |       0.260 |</a>
<a name="ln20"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (3K4/(...)1, 6) [38] |  21,033.2 us |    32.48 us |    25.36 us |  0.05 |    62.5000 |    5446.33 KB |       0.005 |</a>
<a name="ln21"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (3K4/(...)1, 6) [38] |  20,827.3 us |    99.09 us |    92.69 us |  0.05 |    62.5000 |    5446.33 KB |       0.005 |</a>
<a name="ln22"> *  |                                                    |                      |              |             |             |       |            |               |             |</a>
<a name="ln23"> *  | NewPosition                                        | (8/p7(...)-, 6) [37] |  14,260.2 us |    46.97 us |    43.94 us |  1.00 |   515.6250 |    42915.8 KB |        1.00 |</a>
<a name="ln24"> *  | MakeUnmakeMove_Original                            | (8/p7(...)-, 6) [37] |  16,042.8 us |    43.61 us |    34.05 us |  1.12 |   187.5000 |   17113.08 KB |        0.40 |</a>
<a name="ln25"> *  | MakeUnmakeMove_WithZobristKey                      | (8/p7(...)-, 6) [37] |  10,309.4 us |    28.15 us |    24.95 us |  0.72 |   203.1250 |   17113.07 KB |        0.40 |</a>
<a name="ln26"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (8/p7(...)-, 6) [37] |   4,650.9 us |    29.48 us |    27.58 us |  0.33 |   101.5625 |    8398.54 KB |        0.20 |</a>
<a name="ln27"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (8/p7(...)-, 6) [37] |   4,650.4 us |    30.97 us |    27.46 us |  0.33 |   101.5625 |    8398.54 KB |        0.20 |</a>
<a name="ln28"> *  |                                                    |                      |              |             |             |       |            |               |             |</a>
<a name="ln29"> *  | NewPosition                                        | (r3k2(...)1, 4) [73] | 329,451.7 us | 1,566.86 us | 1,465.64 us | 1.000 |  9500.0000 |  801233.01 KB |       1.000 |</a>
<a name="ln30"> *  | MakeUnmakeMove_Original                            | (r3k2(...)1, 4) [73] | 331,610.6 us |   419.38 us |   327.42 us | 1.006 |  1000.0000 |  104639.41 KB |       0.131 |</a>
<a name="ln31"> *  | MakeUnmakeMove_WithZobristKey                      | (r3k2(...)1, 4) [73] | 249,777.8 us | 2,035.13 us | 1,903.66 us | 0.758 |  1000.0000 |  104638.89 KB |       0.131 |</a>
<a name="ln32"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (r3k2(...)1, 4) [73] |     163.1 us |     0.33 us |     0.27 us | 0.000 |     1.2207 |     102.76 KB |       0.000 |</a>
<a name="ln33"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (r3k2(...)1, 4) [73] |     161.1 us |     2.51 us |     2.35 us | 0.000 |     1.2207 |     102.76 KB |       0.000 |</a>
<a name="ln34"> *  |                                                    |                      |              |             |             |       |            |               |             |</a>
<a name="ln35"> *  | NewPosition                                        | (r4rk(...)0, 4) [77] | 310,900.6 us | 1,324.89 us | 1,034.39 us | 1.000 |  9000.0000 |  765557.21 KB |       1.000 |</a>
<a name="ln36"> *  | MakeUnmakeMove_Original                            | (r4rk(...)0, 4) [77] | 282,021.9 us | 1,572.90 us | 1,471.30 us | 0.907 |  1000.0000 |   96332.98 KB |       0.126 |</a>
<a name="ln37"> *  | MakeUnmakeMove_WithZobristKey                      | (r4rk(...)0, 4) [77] | 213,212.4 us | 1,601.03 us | 1,497.60 us | 0.685 |  1000.0000 |   96332.81 KB |       0.126 |</a>
<a name="ln38"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (r4rk(...)0, 4) [77] |     348.3 us |     2.25 us |     2.11 us | 0.001 |     2.4414 |      208.5 KB |       0.000 |</a>
<a name="ln39"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (r4rk(...)0, 4) [77] |     340.1 us |     1.96 us |     1.74 us | 0.001 |     2.4414 |      208.5 KB |       0.000 |</a>
<a name="ln40"> *  |                                                    |                      |              |             |             |       |            |               |             |</a>
<a name="ln41"> *  | NewPosition                                        | (rnbq(...)1, 4) [61] |  17,400.8 us |   200.22 us |   187.28 us |  1.00 |   531.2500 |   43733.27 KB |       1.000 |</a>
<a name="ln42"> *  | MakeUnmakeMove_Original                            | (rnbq(...)1, 4) [61] |  15,707.5 us |    22.23 us |    19.71 us |  0.90 |    93.7500 |    9760.59 KB |       0.223 |</a>
<a name="ln43"> *  | MakeUnmakeMove_WithZobristKey                      | (rnbq(...)1, 4) [61] |  11,660.6 us |    53.70 us |    50.23 us |  0.67 |   109.3750 |    9760.58 KB |       0.223 |</a>
<a name="ln44"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (rnbq(...)1, 4) [61] |     228.4 us |     0.39 us |     0.36 us |  0.01 |     2.6855 |     220.02 KB |       0.005 |</a>
<a name="ln45"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (rnbq(...)1, 4) [61] |     247.4 us |     1.68 us |     1.57 us |  0.01 |     2.4414 |     220.02 KB |       0.005 |</a>
<a name="ln46"> *</a>
<a name="ln47"> *</a>
<a name="ln48"> *  BenchmarkDotNet v0.13.12, Windows 10 (10.0.20348.2159) (Hyper-V)</a>
<a name="ln49"> *  AMD EPYC 7763, 1 CPU, 4 logical and 2 physical cores</a>
<a name="ln50"> *  .NET SDK 8.0.101</a>
<a name="ln51"> *    [Host]     : .NET 8.0.1 (8.0.123.58001), X64 RyuJIT AVX2</a>
<a name="ln52"> *    DefaultJob : .NET 8.0.1 (8.0.123.58001), X64 RyuJIT AVX2</a>
<a name="ln53"> *</a>
<a name="ln54"> *  | Method                                             | data                 | Mean         | Error       | StdDev      | Ratio | RatioSD | Gen0       | Gen1      | Allocated     | Alloc Ratio |</a>
<a name="ln55"> *  |--------------------------------------------------- |--------------------- |-------------:|------------:|------------:|------:|--------:|-----------:|----------:|--------------:|------------:|</a>
<a name="ln56"> *  | NewPosition                                        | (2K2r(...)1, 6) [38] | 362,623.0 us | 7,118.07 us | 8,197.18 us |  1.00 |    0.00 | 65000.0000 | 1000.0000 | 1069285.13 KB |        1.00 |</a>
<a name="ln57"> *  | MakeUnmakeMove_Original                            | (2K2r(...)1, 6) [38] | 469,134.5 us | 7,765.80 us | 7,264.13 us |  1.29 |    0.04 | 17000.0000 |         - |   278497.8 KB |        0.26 |</a>
<a name="ln58"> *  | MakeUnmakeMove_WithZobristKey                      | (2K2r(...)1, 6) [38] | 262,467.8 us | 5,146.64 us | 7,703.25 us |  0.73 |    0.02 | 17000.0000 |         - |  278497.45 KB |        0.26 |</a>
<a name="ln59"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (2K2r(...)1, 6) [38] |  21,355.4 us |   155.29 us |   145.26 us |  0.06 |    0.00 |  2125.0000 |   31.2500 |   35057.84 KB |        0.03 |</a>
<a name="ln60"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (2K2r(...)1, 6) [38] |  21,132.3 us |   205.52 us |   192.24 us |  0.06 |    0.00 |  2125.0000 |   31.2500 |   35057.84 KB |        0.03 |</a>
<a name="ln61"> *  |                                                    |                      |              |             |             |       |         |            |           |               |             |</a>
<a name="ln62"> *  | NewPosition                                        | (3K4/(...)1, 6) [38] | 317,801.2 us | 3,109.67 us | 2,908.79 us |  1.00 |    0.00 | 65000.0000 | 1000.0000 | 1069285.42 KB |       1.000 |</a>
<a name="ln63"> *  | MakeUnmakeMove_Original                            | (3K4/(...)1, 6) [38] | 447,091.0 us | 2,146.22 us | 2,007.57 us |  1.41 |    0.01 | 17000.0000 |         - |   278497.8 KB |       0.260 |</a>
<a name="ln64"> *  | MakeUnmakeMove_WithZobristKey                      | (3K4/(...)1, 6) [38] | 270,516.0 us | 1,031.18 us |   914.11 us |  0.85 |    0.01 | 17000.0000 |         - |  278497.45 KB |       0.260 |</a>
<a name="ln65"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (3K4/(...)1, 6) [38] |  21,649.2 us |    58.64 us |    54.85 us |  0.07 |    0.00 |   312.5000 |         - |    5447.08 KB |       0.005 |</a>
<a name="ln66"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (3K4/(...)1, 6) [38] |  21,053.5 us |   120.87 us |    94.36 us |  0.07 |    0.00 |   312.5000 |         - |    5447.08 KB |       0.005 |</a>
<a name="ln67"> *  |                                                    |                      |              |             |             |       |         |            |           |               |             |</a>
<a name="ln68"> *  | NewPosition                                        | (8/p7(...)-, 6) [37] |  13,088.8 us |   259.00 us |   242.27 us |  1.00 |    0.00 |  2625.0000 |   62.5000 |   42917.22 KB |        1.00 |</a>
<a name="ln69"> *  | MakeUnmakeMove_Original                            | (8/p7(...)-, 6) [37] |  16,455.7 us |   224.85 us |   210.32 us |  1.26 |    0.02 |  1031.2500 |         - |   17115.45 KB |        0.40 |</a>
<a name="ln70"> *  | MakeUnmakeMove_WithZobristKey                      | (8/p7(...)-, 6) [37] |  10,077.0 us |    67.46 us |    63.10 us |  0.77 |    0.02 |  1046.8750 |   15.6250 |   17115.44 KB |        0.40 |</a>
<a name="ln71"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (8/p7(...)-, 6) [37] |   4,534.2 us |    49.09 us |    45.92 us |  0.35 |    0.01 |   507.8125 |    7.8125 |    8399.77 KB |        0.20 |</a>
<a name="ln72"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (8/p7(...)-, 6) [37] |   4,543.6 us |    46.58 us |    41.29 us |  0.35 |    0.01 |   507.8125 |    7.8125 |    8399.77 KB |        0.20 |</a>
<a name="ln73"> *  |                                                    |                      |              |             |             |       |         |            |           |               |             |</a>
<a name="ln74"> *  | NewPosition                                        | (r3k2(...)1, 4) [73] | 287,097.0 us | 5,167.07 us | 4,580.48 us | 1.000 |    0.00 | 49000.0000 |  500.0000 |  801232.84 KB |       1.000 |</a>
<a name="ln75"> *  | MakeUnmakeMove_Original                            | (r3k2(...)1, 4) [73] | 434,386.8 us | 1,566.22 us | 1,388.41 us | 1.513 |    0.02 |  6000.0000 |         - |  104639.09 KB |       0.131 |</a>
<a name="ln76"> *  | MakeUnmakeMove_WithZobristKey                      | (r3k2(...)1, 4) [73] | 257,067.5 us |   987.63 us |   923.83 us | 0.895 |    0.01 |  6000.0000 |         - |  104638.73 KB |       0.131 |</a>
<a name="ln77"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (r3k2(...)1, 4) [73] |     164.6 us |     0.64 us |     0.60 us | 0.001 |    0.00 |     6.1035 |         - |     102.78 KB |       0.000 |</a>
<a name="ln78"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (r3k2(...)1, 4) [73] |     166.6 us |     2.61 us |     2.44 us | 0.001 |    0.00 |     6.1035 |         - |     102.78 KB |       0.000 |</a>
<a name="ln79"> *  |                                                    |                      |              |             |             |       |         |            |           |               |             |</a>
<a name="ln80"> *  | NewPosition                                        | (r4rk(...)0, 4) [77] | 265,197.6 us | 3,409.14 us | 3,188.91 us | 1.000 |    0.00 | 46500.0000 |  500.0000 |  765557.05 KB |       1.000 |</a>
<a name="ln81"> *  | MakeUnmakeMove_Original                            | (r4rk(...)0, 4) [77] | 275,395.6 us |   628.77 us |   557.39 us | 1.038 |    0.01 |  5500.0000 |         - |   96332.82 KB |       0.126 |</a>
<a name="ln82"> *  | MakeUnmakeMove_WithZobristKey                      | (r4rk(...)0, 4) [77] | 206,780.7 us |   743.40 us |   580.39 us | 0.779 |    0.01 |  5666.6667 |         - |    96332.7 KB |       0.126 |</a>
<a name="ln83"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (r4rk(...)0, 4) [77] |     347.7 us |     0.50 us |     0.39 us | 0.001 |    0.00 |    12.6953 |         - |     208.53 KB |       0.000 |</a>
<a name="ln84"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (r4rk(...)0, 4) [77] |     341.5 us |     1.03 us |     0.97 us | 0.001 |    0.00 |    12.6953 |         - |     208.53 KB |       0.000 |</a>
<a name="ln85"> *  |                                                    |                      |              |             |             |       |         |            |           |               |             |</a>
<a name="ln86"> *  | NewPosition                                        | (rnbq(...)1, 4) [61] |  14,317.8 us |   137.40 us |   128.52 us |  1.00 |    0.00 |  2671.8750 |   31.2500 |   43734.68 KB |       1.000 |</a>
<a name="ln87"> *  | MakeUnmakeMove_Original                            | (rnbq(...)1, 4) [61] |  15,662.9 us |    37.47 us |    33.22 us |  1.09 |    0.01 |   593.7500 |         - |    9762.01 KB |       0.223 |</a>
<a name="ln88"> *  | MakeUnmakeMove_WithZobristKey                      | (rnbq(...)1, 4) [61] |  11,864.3 us |    40.01 us |    35.47 us |  0.83 |    0.01 |   593.7500 |         - |       9762 KB |       0.223 |</a>
<a name="ln89"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (rnbq(...)1, 4) [61] |     226.2 us |     1.48 us |     1.31 us |  0.02 |    0.00 |    13.4277 |         - |     220.05 KB |       0.005 |</a>
<a name="ln90"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (rnbq(...)1, 4) [61] |     247.4 us |     1.40 us |     1.17 us |  0.02 |    0.00 |    13.1836 |         - |     220.05 KB |       0.005 |</a>
<a name="ln91"> *</a>
<a name="ln92"> *</a>
<a name="ln93"> *  BenchmarkDotNet v0.13.12, macOS Monterey 12.7.2 (21G1974) [Darwin 21.6.0]</a>
<a name="ln94"> *  Intel Core i7-8700B CPU 3.20GHz (Max: 3.19GHz) (Coffee Lake), 1 CPU, 4 logical and 4 physical cores</a>
<a name="ln95"> *  .NET SDK 8.0.101</a>
<a name="ln96"> *    [Host]     : .NET 8.0.1 (8.0.123.58001), X64 RyuJIT AVX2</a>
<a name="ln97"> *    DefaultJob : .NET 8.0.1 (8.0.123.58001), X64 RyuJIT AVX2</a>
<a name="ln98"> *</a>
<a name="ln99"> *  | Method                                             | data                 | Mean         | Error        | StdDev       | Median       | Ratio | RatioSD | Gen0        | Gen1      | Allocated     | Alloc Ratio |</a>
<a name="ln100"> *  |--------------------------------------------------- |--------------------- |-------------:|-------------:|-------------:|-------------:|------:|--------:|------------:|----------:|--------------:|------------:|</a>
<a name="ln101"> *  | NewPosition                                        | (2K2r(...)1, 6) [38] | 596,556.4 us | 23,284.29 us | 67,921.36 us | 572,548.9 us |  1.00 |    0.00 | 174000.0000 | 2000.0000 | 1069286.11 KB |        1.00 |</a>
<a name="ln102"> *  | MakeUnmakeMove_Original                            | (2K2r(...)1, 6) [38] | 581,562.8 us | 32,111.07 us | 92,647.79 us | 569,710.1 us |  0.99 |    0.18 |  45000.0000 |         - |  278498.13 KB |        0.26 |</a>
<a name="ln103"> *  | MakeUnmakeMove_WithZobristKey                      | (2K2r(...)1, 6) [38] | 385,904.5 us | 20,523.47 us | 60,513.91 us | 367,557.5 us |  0.66 |    0.12 |  45000.0000 |  500.0000 |  278497.61 KB |        0.26 |</a>
<a name="ln104"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (2K2r(...)1, 6) [38] |  26,102.9 us |    553.67 us |  1,552.56 us |  25,638.0 us |  0.04 |    0.01 |   5718.7500 |   62.5000 |   35057.85 KB |        0.03 |</a>
<a name="ln105"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (2K2r(...)1, 6) [38] |  23,625.7 us |    431.98 us |    697.56 us |  23,592.0 us |  0.04 |    0.00 |   5718.7500 |   62.5000 |   35057.85 KB |        0.03 |</a>
<a name="ln106"> *  |                                                    |                      |              |              |              |              |       |         |             |           |               |             |</a>
<a name="ln107"> *  | NewPosition                                        | (3K4/(...)1, 6) [38] | 520,639.0 us | 11,233.39 us | 31,499.62 us | 515,944.3 us |  1.00 |    0.00 | 174000.0000 | 2000.0000 | 1069286.11 KB |       1.000 |</a>
<a name="ln108"> *  | MakeUnmakeMove_Original                            | (3K4/(...)1, 6) [38] | 487,835.4 us |  9,495.67 us | 21,433.32 us | 481,627.1 us |  0.94 |    0.07 |  45000.0000 |         - |  278498.13 KB |       0.260 |</a>
<a name="ln109"> *  | MakeUnmakeMove_WithZobristKey                      | (3K4/(...)1, 6) [38] | 369,615.4 us | 13,953.87 us | 39,584.82 us | 365,639.3 us |  0.71 |    0.08 |  45000.0000 |  500.0000 |  278497.61 KB |       0.260 |</a>
<a name="ln110"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (3K4/(...)1, 6) [38] |  27,328.3 us |  1,008.16 us |  2,908.77 us |  26,738.7 us |  0.05 |    0.01 |    875.0000 |         - |    5448.71 KB |       0.005 |</a>
<a name="ln111"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (3K4/(...)1, 6) [38] |  23,015.6 us |    553.61 us |  1,606.12 us |  22,453.1 us |  0.04 |    0.00 |    875.0000 |         - |    5448.71 KB |       0.005 |</a>
<a name="ln112"> *  |                                                    |                      |              |              |              |              |       |         |             |           |               |             |</a>
<a name="ln113"> *  | NewPosition                                        | (8/p7(...)-, 6) [37] |  18,770.8 us |    371.77 us |    890.73 us |  18,935.4 us |  1.00 |    0.00 |   7000.0000 |  125.0000 |   42917.24 KB |        1.00 |</a>
<a name="ln114"> *  | MakeUnmakeMove_Original                            | (8/p7(...)-, 6) [37] |  17,203.1 us |    340.58 us |    782.54 us |  17,155.4 us |  0.92 |    0.06 |   2781.2500 |   31.2500 |   17115.46 KB |        0.40 |</a>
<a name="ln115"> *  | MakeUnmakeMove_WithZobristKey                      | (8/p7(...)-, 6) [37] |  12,017.8 us |    239.95 us |    344.13 us |  12,025.8 us |  0.65 |    0.03 |   2781.2500 |   46.8750 |   17115.45 KB |        0.40 |</a>
<a name="ln116"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (8/p7(...)-, 6) [37] |   5,453.7 us |    106.75 us |    109.62 us |   5,443.5 us |  0.30 |    0.02 |   1367.1875 |   23.4375 |    8401.25 KB |        0.20 |</a>
<a name="ln117"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (8/p7(...)-, 6) [37] |   5,295.0 us |    105.24 us |    195.07 us |   5,260.0 us |  0.29 |    0.02 |   1367.1875 |   23.4375 |    8401.25 KB |        0.20 |</a>
<a name="ln118"> *  |                                                    |                      |              |              |              |              |       |         |             |           |               |             |</a>
<a name="ln119"> *  | NewPosition                                        | (r3k2(...)1, 4) [73] | 521,874.5 us | 27,099.15 us | 78,187.23 us | 481,362.9 us | 1.000 |    0.00 | 130000.0000 | 1000.0000 |  801233.53 KB |       1.000 |</a>
<a name="ln120"> *  | MakeUnmakeMove_Original                            | (r3k2(...)1, 4) [73] | 367,470.0 us |  4,942.33 us |  6,426.42 us | 366,073.7 us | 0.686 |    0.10 |  17000.0000 |         - |  104639.41 KB |       0.131 |</a>
<a name="ln121"> *  | MakeUnmakeMove_WithZobristKey                      | (r3k2(...)1, 4) [73] | 301,125.9 us |  3,070.02 us |  2,396.87 us | 300,703.8 us | 0.594 |    0.06 |  17000.0000 |         - |  104638.89 KB |       0.131 |</a>
<a name="ln122"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (r3k2(...)1, 4) [73] |     163.3 us |      2.86 us |      2.39 us |     164.2 us | 0.000 |    0.00 |     16.6016 |         - |     102.81 KB |       0.000 |</a>
<a name="ln123"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (r3k2(...)1, 4) [73] |     168.6 us |      2.50 us |      2.22 us |     168.4 us | 0.000 |    0.00 |     16.6016 |         - |     102.81 KB |       0.000 |</a>
<a name="ln124"> *  |                                                    |                      |              |              |              |              |       |         |             |           |               |             |</a>
<a name="ln125"> *  | NewPosition                                        | (r4rk(...)0, 4) [77] | 386,108.7 us |  7,594.60 us |  8,126.14 us | 387,721.3 us | 1.000 |    0.00 | 124000.0000 | 1000.0000 |  765557.73 KB |       1.000 |</a>
<a name="ln126"> *  | MakeUnmakeMove_Original                            | (r4rk(...)0, 4) [77] | 308,136.0 us |  5,898.38 us |  6,792.58 us | 307,536.4 us | 0.798 |    0.03 |  15500.0000 |         - |   96332.98 KB |       0.126 |</a>
<a name="ln127"> *  | MakeUnmakeMove_WithZobristKey                      | (r4rk(...)0, 4) [77] | 236,499.4 us |  3,099.38 us |  2,899.16 us | 237,067.0 us | 0.610 |    0.01 |  15666.6667 |         - |   96332.81 KB |       0.126 |</a>
<a name="ln128"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (r4rk(...)0, 4) [77] |     312.4 us |      6.07 us |      5.67 us |     312.1 us | 0.001 |    0.00 |     33.6914 |         - |      208.6 KB |       0.000 |</a>
<a name="ln129"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (r4rk(...)0, 4) [77] |     363.2 us |      6.15 us |      5.75 us |     362.3 us | 0.001 |    0.00 |     33.6914 |         - |      208.6 KB |       0.000 |</a>
<a name="ln130"> *  |                                                    |                      |              |              |              |              |       |         |             |           |               |             |</a>
<a name="ln131"> *  | NewPosition                                        | (rnbq(...)1, 4) [61] |  20,415.4 us |    380.05 us |    355.50 us |  20,395.0 us |  1.00 |    0.00 |   7125.0000 |   93.7500 |    43734.7 KB |       1.000 |</a>
<a name="ln132"> *  | MakeUnmakeMove_Original                            | (rnbq(...)1, 4) [61] |  16,943.5 us |    144.12 us |    120.35 us |  16,999.3 us |  0.83 |    0.02 |   1593.7500 |         - |    9763.26 KB |       0.223 |</a>
<a name="ln133"> *  | MakeUnmakeMove_WithZobristKey                      | (rnbq(...)1, 4) [61] |  13,816.4 us |    273.34 us |    355.42 us |  13,743.5 us |  0.69 |    0.02 |   1593.7500 |   15.6250 |    9763.24 KB |       0.223 |</a>
<a name="ln134"> *  | MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove | (rnbq(...)1, 4) [61] |     251.5 us |      3.29 us |      2.91 us |     251.1 us |  0.01 |    0.00 |     35.6445 |         - |     220.12 KB |       0.005 |</a>
<a name="ln135"> *  | MakeUnmakeMove_WithZobristKey_SwitchSpecialMove    | (rnbq(...)1, 4) [61] |     316.3 us |      2.19 us |      2.05 us |     315.9 us |  0.02 |    0.00 |     35.6445 |         - |     220.12 KB |       0.005 |</a>
<a name="ln136"> *</a>
<a name="ln137"> */</a>
<a name="ln138"> </a>
<a name="ln139">#pragma warning disable S101, S1854 // Types should be named in PascalCase</a>
<a name="ln140"> </a>
<a name="ln141">using BenchmarkDotNet.Attributes;</a>
<a name="ln142">using Lynx.Model;</a>
<a name="ln143">using System.Runtime.CompilerServices;</a>
<a name="ln144"> </a>
<a name="ln145">namespace Lynx.Benchmark;</a>
<a name="ln146">public class MakeUnmakeMove_implementation_Benchmark : BaseBenchmark</a>
<a name="ln147">{</a>
<a name="ln148">    public static IEnumerable&lt;(string, int)&gt; Data =&gt;</a>
<a name="ln149">    [</a>
<a name="ln150">        (Constants.InitialPositionFEN, 4),</a>
<a name="ln151">        (Constants.TrickyTestPositionFEN, 4),</a>
<a name="ln152">        (&quot;r4rk1/1pp1qppp/p1np1n2/2b1p1B1/2B1P1b1/P1NP1N2/1PP1QPPP/R4RK1 w - - 0 10&quot;, 4),</a>
<a name="ln153">        (&quot;3K4/8/8/8/8/8/4p3/2k2R2 b - - 0 1&quot;, 6),</a>
<a name="ln154">        (&quot;2K2r2/4P3/8/8/8/8/8/3k4 w - - 0 1&quot;, 6),</a>
<a name="ln155">        (&quot;8/p7/8/1P6/K1k3p1/6P1/7P/8 w - -&quot;, 6),</a>
<a name="ln156">    ];</a>
<a name="ln157"> </a>
<a name="ln158">    [Benchmark(Baseline = true)]</a>
<a name="ln159">    [ArgumentsSource(nameof(Data))]</a>
<a name="ln160">    public long NewPosition((string Fen, int Depth) data) =&gt; MakeMovePerft.ResultsImpl_Original(new(data.Fen), data.Depth, default);</a>
<a name="ln161"> </a>
<a name="ln162">    [Benchmark]</a>
<a name="ln163">    [ArgumentsSource(nameof(Data))]</a>
<a name="ln164">    public long MakeUnmakeMove_Original((string Fen, int Depth) data) =&gt; MakeMovePerft.ResultsImpl_MakeUnmakeMove(new(data.Fen), data.Depth, default);</a>
<a name="ln165"> </a>
<a name="ln166">    [Benchmark]</a>
<a name="ln167">    [ArgumentsSource(nameof(Data))]</a>
<a name="ln168">    public long MakeUnmakeMove_WithZobristKey((string Fen, int Depth) data) =&gt; MakeMovePerft.ResultsImpl_MakeUnmakeMove_WithZobritsKey(new(data.Fen), data.Depth, default);</a>
<a name="ln169"> </a>
<a name="ln170">    [Benchmark]</a>
<a name="ln171">    [ArgumentsSource(nameof(Data))]</a>
<a name="ln172">    public long MakeUnmakeMove_WithZobristKey_PreSwitchSpecialMove((string Fen, int Depth) data) =&gt; MakeMovePerft.ResultsImpl_MakeUnmakeMove_WithZobritsKey_PreSwitchSpecialMove(new(data.Fen), data.Depth, default);</a>
<a name="ln173"> </a>
<a name="ln174">    [Benchmark]</a>
<a name="ln175">    [ArgumentsSource(nameof(Data))]</a>
<a name="ln176">    public long MakeUnmakeMove_WithZobristKey_SwitchSpecialMove((string Fen, int Depth) data) =&gt; MakeMovePerft.ResultsImpl_MakeUnmakeMove_WithZobritsKey_SwitchSpecialMove(new(data.Fen), data.Depth, default);</a>
<a name="ln177"> </a>
<a name="ln178">    public static class MakeMovePerft</a>
<a name="ln179">    {</a>
<a name="ln180">        public static long ResultsImpl_Original(MakeMovePosition position, int depth, long nodes)</a>
<a name="ln181">        {</a>
<a name="ln182">            if (depth != 0)</a>
<a name="ln183">            {</a>
<a name="ln184">                foreach (var move in MakeMoveMoveGenerator.GenerateAllMoves(position))</a>
<a name="ln185">                {</a>
<a name="ln186">                    var newPosition = new MakeMovePosition(position, move);</a>
<a name="ln187"> </a>
<a name="ln188">                    if (newPosition.WasProduceByAValidMove())</a>
<a name="ln189">                    {</a>
<a name="ln190">                        nodes = ResultsImpl_Original(newPosition, depth - 1, nodes);</a>
<a name="ln191">                    }</a>
<a name="ln192">                }</a>
<a name="ln193"> </a>
<a name="ln194">                return nodes;</a>
<a name="ln195">            }</a>
<a name="ln196"> </a>
<a name="ln197">            return ++nodes;</a>
<a name="ln198">        }</a>
<a name="ln199"> </a>
<a name="ln200">        public static long ResultsImpl_MakeUnmakeMove(MakeMovePosition position, int depth, long nodes)</a>
<a name="ln201">        {</a>
<a name="ln202">            if (depth != 0)</a>
<a name="ln203">            {</a>
<a name="ln204">                foreach (var move in MakeMoveMoveGenerator.GenerateAllMoves(position))</a>
<a name="ln205">                {</a>
<a name="ln206">                    //_gameStates.Push(position.MakeMove(move));</a>
<a name="ln207">                    var state = position.MakeMove_Original(move);</a>
<a name="ln208"> </a>
<a name="ln209">                    if (position.WasProduceByAValidMove())</a>
<a name="ln210">                    {</a>
<a name="ln211">                        nodes = ResultsImpl_MakeUnmakeMove(position, depth - 1, nodes);</a>
<a name="ln212">                    }</a>
<a name="ln213">                    //position.UnmakeMove(move, _gameStates.Pop());</a>
<a name="ln214">                    position.UnmakeMove_Original(move, state);</a>
<a name="ln215">                }</a>
<a name="ln216"> </a>
<a name="ln217">                return nodes;</a>
<a name="ln218">            }</a>
<a name="ln219"> </a>
<a name="ln220">            return ++nodes;</a>
<a name="ln221">        }</a>
<a name="ln222"> </a>
<a name="ln223">        public static long ResultsImpl_MakeUnmakeMove_WithZobritsKey(MakeMovePosition position, int depth, long nodes)</a>
<a name="ln224">        {</a>
<a name="ln225">            if (depth != 0)</a>
<a name="ln226">            {</a>
<a name="ln227">                foreach (var move in MakeMoveMoveGenerator.GenerateAllMoves(position))</a>
<a name="ln228">                {</a>
<a name="ln229">                    //_gameStates.Push(position.MakeMove(move));</a>
<a name="ln230">                    var state = position.MakeMove_WithZobristKey(move);</a>
<a name="ln231"> </a>
<a name="ln232">                    if (position.WasProduceByAValidMove())</a>
<a name="ln233">                    {</a>
<a name="ln234">                        nodes = ResultsImpl_MakeUnmakeMove_WithZobritsKey(position, depth - 1, nodes);</a>
<a name="ln235">                    }</a>
<a name="ln236">                    //position.UnmakeMove(move, _gameStates.Pop());</a>
<a name="ln237">                    position.UnmakeMove_WithZobristKey(move, state);</a>
<a name="ln238">                }</a>
<a name="ln239"> </a>
<a name="ln240">                return nodes;</a>
<a name="ln241">            }</a>
<a name="ln242"> </a>
<a name="ln243">            return ++nodes;</a>
<a name="ln244">        }</a>
<a name="ln245"> </a>
<a name="ln246">        public static long ResultsImpl_MakeUnmakeMove_WithZobritsKey_PreSwitchSpecialMove(MakeMovePosition position, int depth, long nodes)</a>
<a name="ln247">        {</a>
<a name="ln248">            if (depth != 0)</a>
<a name="ln249">            {</a>
<a name="ln250">                foreach (var move in MakeMoveMoveGenerator.GenerateAllMoves(position))</a>
<a name="ln251">                {</a>
<a name="ln252">                    //_gameStates.Push(position.MakeMove(move));</a>
<a name="ln253">                    var state = position.MakeMove_WithZobristKey_PreSwitchSpecialMove(move);</a>
<a name="ln254"> </a>
<a name="ln255">                    if (position.WasProduceByAValidMove())</a>
<a name="ln256">                    {</a>
<a name="ln257">                        nodes = ResultsImpl_MakeUnmakeMove_WithZobritsKey_PreSwitchSpecialMove(position, depth - 1, nodes);</a>
<a name="ln258">                    }</a>
<a name="ln259">                    //position.UnmakeMove(move, _gameStates.Pop());</a>
<a name="ln260">                    position.UnmakeMove_WithZobristKey_PreSwitchSpecialMove(move, state);</a>
<a name="ln261">                }</a>
<a name="ln262"> </a>
<a name="ln263">                return nodes;</a>
<a name="ln264">            }</a>
<a name="ln265"> </a>
<a name="ln266">            return ++nodes;</a>
<a name="ln267">        }</a>
<a name="ln268"> </a>
<a name="ln269">        public static long ResultsImpl_MakeUnmakeMove_WithZobritsKey_SwitchSpecialMove(MakeMovePosition position, int depth, long nodes)</a>
<a name="ln270">        {</a>
<a name="ln271">            if (depth != 0)</a>
<a name="ln272">            {</a>
<a name="ln273">                foreach (var move in MakeMoveMoveGenerator.GenerateAllMoves(position))</a>
<a name="ln274">                {</a>
<a name="ln275">                    //_gameStates.Push(position.MakeMove(move));</a>
<a name="ln276">                    var state = position.MakeMove_WithZobristKey_SwitchSpecialMove(move);</a>
<a name="ln277"> </a>
<a name="ln278">                    if (position.WasProduceByAValidMove())</a>
<a name="ln279">                    {</a>
<a name="ln280">                        nodes = ResultsImpl_MakeUnmakeMove_WithZobritsKey_SwitchSpecialMove(position, depth - 1, nodes);</a>
<a name="ln281">                    }</a>
<a name="ln282">                    //position.UnmakeMove(move, _gameStates.Pop());</a>
<a name="ln283">                    position.UnmakeMove_WithZobristKey_SwitchSpecialMove(move, state);</a>
<a name="ln284">                }</a>
<a name="ln285"> </a>
<a name="ln286">                return nodes;</a>
<a name="ln287">            }</a>
<a name="ln288"> </a>
<a name="ln289">            return ++nodes;</a>
<a name="ln290">        }</a>
<a name="ln291">    }</a>
<a name="ln292"> </a>
<a name="ln293">    public struct MakeMovePosition</a>
<a name="ln294">    {</a>
<a name="ln295">        public ulong UniqueIdentifier { get; private set; }</a>
<a name="ln296"> </a>
<a name="ln297">        public BitBoard[] PieceBitBoards { get; }</a>
<a name="ln298"> </a>
<a name="ln299">        public BitBoard[] OccupancyBitBoards { get; }</a>
<a name="ln300"> </a>
<a name="ln301">        public int[] Board { get; }</a>
<a name="ln302"> </a>
<a name="ln303">        public Side Side { get; private set; }</a>
<a name="ln304"> </a>
<a name="ln305">        public BoardSquare EnPassant { get; private set; }</a>
<a name="ln306"> </a>
<a name="ln307">        public byte Castle { get; private set; }</a>
<a name="ln308"> </a>
<a name="ln309">        public MakeMovePosition(string fen) : this(FENParser.ParseFEN(fen))</a>
<a name="ln310">        {</a>
<a name="ln311">        }</a>
<a name="ln312"> </a>
<a name="ln313">        public MakeMovePosition((BitBoard[] PieceBitBoards, BitBoard[] OccupancyBitBoards, int[] board, Side Side, byte Castle, BoardSquare EnPassant,</a>
<a name="ln314">            int HalfMoveClock/*, int FullMoveCounter*/) parsedFEN)</a>
<a name="ln315">        {</a>
<a name="ln316">            PieceBitBoards = parsedFEN.PieceBitBoards;</a>
<a name="ln317">            OccupancyBitBoards = parsedFEN.OccupancyBitBoards;</a>
<a name="ln318">            Board = parsedFEN.board;</a>
<a name="ln319">            Side = parsedFEN.Side;</a>
<a name="ln320">            Castle = parsedFEN.Castle;</a>
<a name="ln321">            EnPassant = parsedFEN.EnPassant;</a>
<a name="ln322"> </a>
<a name="ln323">            UniqueIdentifier = MakeMoveZobristTable.PositionHash(this);</a>
<a name="ln324">        }</a>
<a name="ln325"> </a>
<a name="ln326">        /// &lt;summary&gt;</a>
<a name="ln327">        /// Clone constructor</a>
<a name="ln328">        /// &lt;/summary&gt;</a>
<a name="ln329">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln330">        public MakeMovePosition(MakeMovePosition position)</a>
<a name="ln331">        {</a>
<a name="ln332">            UniqueIdentifier = position.UniqueIdentifier;</a>
<a name="ln333">            PieceBitBoards = new BitBoard[12];</a>
<a name="ln334">            Array.Copy(position.PieceBitBoards, PieceBitBoards, position.PieceBitBoards.Length);</a>
<a name="ln335"> </a>
<a name="ln336">            OccupancyBitBoards = new BitBoard[3];</a>
<a name="ln337">            Array.Copy(position.OccupancyBitBoards, OccupancyBitBoards, position.OccupancyBitBoards.Length);</a>
<a name="ln338"> </a>
<a name="ln339">            Board = new int[64];</a>
<a name="ln340">            Array.Copy(position.Board, Board, position.Board.Length);</a>
<a name="ln341"> </a>
<a name="ln342">            Side = position.Side;</a>
<a name="ln343">            Castle = position.Castle;</a>
<a name="ln344">            EnPassant = position.EnPassant;</a>
<a name="ln345">        }</a>
<a name="ln346"> </a>
<a name="ln347">        /// &lt;summary&gt;</a>
<a name="ln348">        /// Null moves constructor</a>
<a name="ln349">        /// &lt;/summary&gt;</a>
<a name="ln350">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln351">#pragma warning disable RCS1163, IDE0060 // Unused parameter.</a>
<a name="ln352">        public MakeMovePosition(MakeMovePosition position, bool nullMove)</a>
<a name="ln353">        {</a>
<a name="ln354">            UniqueIdentifier = position.UniqueIdentifier;</a>
<a name="ln355">            PieceBitBoards = new BitBoard[12];</a>
<a name="ln356">            Array.Copy(position.PieceBitBoards, PieceBitBoards, position.PieceBitBoards.Length);</a>
<a name="ln357"> </a>
<a name="ln358">            OccupancyBitBoards = new BitBoard[3];</a>
<a name="ln359">            Array.Copy(position.OccupancyBitBoards, OccupancyBitBoards, position.OccupancyBitBoards.Length);</a>
<a name="ln360"> </a>
<a name="ln361">            Board = new int[64];</a>
<a name="ln362">            Array.Copy(position.Board, Board, position.Board.Length);</a>
<a name="ln363"> </a>
<a name="ln364">            Side = (Side)Utils.OppositeSide(position.Side);</a>
<a name="ln365">            Castle = position.Castle;</a>
<a name="ln366">            EnPassant = BoardSquare.noSquare;</a>
<a name="ln367"> </a>
<a name="ln368">            UniqueIdentifier ^=</a>
<a name="ln369">                ZobristTable.SideHash()</a>
<a name="ln370">                ^ ZobristTable.EnPassantHash((int)position.EnPassant);</a>
<a name="ln371">        }</a>
<a name="ln372"> </a>
<a name="ln373">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln374">        public MakeMovePosition(MakeMovePosition position, Move move) : this(position)</a>
<a name="ln375">        {</a>
<a name="ln376">            var oldSide = Side;</a>
<a name="ln377">            var offset = Utils.PieceOffset(oldSide);</a>
<a name="ln378">            var oppositeSide = Utils.OppositeSide(oldSide);</a>
<a name="ln379"> </a>
<a name="ln380">            int sourceSquare = move.SourceSquare();</a>
<a name="ln381">            int targetSquare = move.TargetSquare();</a>
<a name="ln382">            int piece = move.Piece();</a>
<a name="ln383">            int promotedPiece = move.PromotedPiece();</a>
<a name="ln384"> </a>
<a name="ln385">            var newPiece = piece;</a>
<a name="ln386">            if (promotedPiece != default)</a>
<a name="ln387">            {</a>
<a name="ln388">                newPiece = promotedPiece;</a>
<a name="ln389">            }</a>
<a name="ln390"> </a>
<a name="ln391">            EnPassant = BoardSquare.noSquare;</a>
<a name="ln392"> </a>
<a name="ln393">            PieceBitBoards[piece].PopBit(sourceSquare);</a>
<a name="ln394">            OccupancyBitBoards[(int)Side].PopBit(sourceSquare);</a>
<a name="ln395"> </a>
<a name="ln396">            PieceBitBoards[newPiece].SetBit(targetSquare);</a>
<a name="ln397">            OccupancyBitBoards[(int)Side].SetBit(targetSquare);</a>
<a name="ln398"> </a>
<a name="ln399">            UniqueIdentifier ^=</a>
<a name="ln400">                ZobristTable.SideHash()</a>
<a name="ln401">                ^ ZobristTable.PieceHash(sourceSquare, piece)</a>
<a name="ln402">                ^ ZobristTable.PieceHash(targetSquare, newPiece)</a>
<a name="ln403">                ^ ZobristTable.EnPassantHash((int)position.EnPassant)</a>
<a name="ln404">                ^ ZobristTable.CastleHash(position.Castle);</a>
<a name="ln405"> </a>
<a name="ln406">            if (move.IsCapture())</a>
<a name="ln407">            {</a>
<a name="ln408">                var oppositeSideOffset = Utils.PieceOffset(oppositeSide);</a>
<a name="ln409">                var oppositePawnIndex = (int)Piece.P + oppositeSideOffset;</a>
<a name="ln410"> </a>
<a name="ln411">                if (move.IsEnPassant())</a>
<a name="ln412">                {</a>
<a name="ln413">                    var capturedPawnSquare = Constants.EnPassantCaptureSquares[targetSquare];</a>
<a name="ln414">                    Utils.Assert(PieceBitBoards[oppositePawnIndex].GetBit(capturedPawnSquare), $&quot;Expected {(Side)oppositeSide} pawn in {capturedPawnSquare}&quot;);</a>
<a name="ln415"> </a>
<a name="ln416">                    PieceBitBoards[oppositePawnIndex].PopBit(capturedPawnSquare);</a>
<a name="ln417">                    OccupancyBitBoards[oppositeSide].PopBit(capturedPawnSquare);</a>
<a name="ln418">                    UniqueIdentifier ^= ZobristTable.PieceHash(capturedPawnSquare, oppositePawnIndex);</a>
<a name="ln419">                }</a>
<a name="ln420">                else</a>
<a name="ln421">                {</a>
<a name="ln422">                    var limit = (int)Piece.K + oppositeSideOffset;</a>
<a name="ln423">                    for (int pieceIndex = oppositePawnIndex; pieceIndex &lt; limit; ++pieceIndex)</a>
<a name="ln424">                    {</a>
<a name="ln425">                        if (PieceBitBoards[pieceIndex].GetBit(targetSquare))</a>
<a name="ln426">                        {</a>
<a name="ln427">                            PieceBitBoards[pieceIndex].PopBit(targetSquare);</a>
<a name="ln428">                            UniqueIdentifier ^= ZobristTable.PieceHash(targetSquare, pieceIndex);</a>
<a name="ln429">                            break;</a>
<a name="ln430">                        }</a>
<a name="ln431">                    }</a>
<a name="ln432"> </a>
<a name="ln433">                    OccupancyBitBoards[oppositeSide].PopBit(targetSquare);</a>
<a name="ln434">                }</a>
<a name="ln435">            }</a>
<a name="ln436">            else if (move.IsDoublePawnPush())</a>
<a name="ln437">            {</a>
<a name="ln438">                var pawnPush = +8 - ((int)oldSide * 16);</a>
<a name="ln439">                var enPassantSquare = sourceSquare + pawnPush;</a>
<a name="ln440"> </a>
<a name="ln441">                EnPassant = (BoardSquare)enPassantSquare;</a>
<a name="ln442">                UniqueIdentifier ^= ZobristTable.EnPassantHash(enPassantSquare);</a>
<a name="ln443">            }</a>
<a name="ln444">            else if (move.IsShortCastle())</a>
<a name="ln445">            {</a>
<a name="ln446">                var rookSourceSquare = Utils.ShortCastleRookSourceSquare(oldSide);</a>
<a name="ln447">                var rookTargetSquare = Utils.ShortCastleRookTargetSquare(oldSide);</a>
<a name="ln448">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln449"> </a>
<a name="ln450">                PieceBitBoards[rookIndex].PopBit(rookSourceSquare);</a>
<a name="ln451">                OccupancyBitBoards[(int)Side].PopBit(rookSourceSquare);</a>
<a name="ln452"> </a>
<a name="ln453">                PieceBitBoards[rookIndex].SetBit(rookTargetSquare);</a>
<a name="ln454">                OccupancyBitBoards[(int)Side].SetBit(rookTargetSquare);</a>
<a name="ln455"> </a>
<a name="ln456">                UniqueIdentifier ^=</a>
<a name="ln457">                    ZobristTable.PieceHash(rookSourceSquare, rookIndex)</a>
<a name="ln458">                    ^ ZobristTable.PieceHash(rookTargetSquare, rookIndex);</a>
<a name="ln459">            }</a>
<a name="ln460">            else if (move.IsLongCastle())</a>
<a name="ln461">            {</a>
<a name="ln462">                var rookSourceSquare = Utils.LongCastleRookSourceSquare(oldSide);</a>
<a name="ln463">                var rookTargetSquare = Utils.LongCastleRookTargetSquare(oldSide);</a>
<a name="ln464">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln465"> </a>
<a name="ln466">                PieceBitBoards[rookIndex].PopBit(rookSourceSquare);</a>
<a name="ln467">                OccupancyBitBoards[(int)Side].PopBit(rookSourceSquare);</a>
<a name="ln468"> </a>
<a name="ln469">                PieceBitBoards[rookIndex].SetBit(rookTargetSquare);</a>
<a name="ln470">                OccupancyBitBoards[(int)Side].SetBit(rookTargetSquare);</a>
<a name="ln471"> </a>
<a name="ln472">                UniqueIdentifier ^=</a>
<a name="ln473">                    ZobristTable.PieceHash(rookSourceSquare, rookIndex)</a>
<a name="ln474">                    ^ ZobristTable.PieceHash(rookTargetSquare, rookIndex);</a>
<a name="ln475">            }</a>
<a name="ln476"> </a>
<a name="ln477">            Side = (Side)oppositeSide;</a>
<a name="ln478">            OccupancyBitBoards[(int)Side.Both] = OccupancyBitBoards[(int)Side.White] | OccupancyBitBoards[(int)Side.Black];</a>
<a name="ln479"> </a>
<a name="ln480">            // Updating castling rights</a>
<a name="ln481">            Castle &amp;= Constants.CastlingRightsUpdateConstants[sourceSquare];</a>
<a name="ln482">            Castle &amp;= Constants.CastlingRightsUpdateConstants[targetSquare];</a>
<a name="ln483"> </a>
<a name="ln484">            UniqueIdentifier ^= ZobristTable.CastleHash(Castle);</a>
<a name="ln485">        }</a>
<a name="ln486"> </a>
<a name="ln487">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln488">        public MakeMoveGameState MakeMove_Original(Move move)</a>
<a name="ln489">        {</a>
<a name="ln490">            int capturedPiece = -1;</a>
<a name="ln491">            var castleCopy = Castle;</a>
<a name="ln492">            BoardSquare enpassantCopy = EnPassant;</a>
<a name="ln493"> </a>
<a name="ln494">            var oldSide = Side;</a>
<a name="ln495">            var offset = Utils.PieceOffset(oldSide);</a>
<a name="ln496">            var oppositeSide = Utils.OppositeSide(oldSide);</a>
<a name="ln497"> </a>
<a name="ln498">            int sourceSquare = move.SourceSquare();</a>
<a name="ln499">            int targetSquare = move.TargetSquare();</a>
<a name="ln500">            int piece = move.Piece();</a>
<a name="ln501">            int promotedPiece = move.PromotedPiece();</a>
<a name="ln502"> </a>
<a name="ln503">            var newPiece = piece;</a>
<a name="ln504">            if (promotedPiece != default)</a>
<a name="ln505">            {</a>
<a name="ln506">                newPiece = promotedPiece;</a>
<a name="ln507">            }</a>
<a name="ln508"> </a>
<a name="ln509">            PieceBitBoards[piece].PopBit(sourceSquare);</a>
<a name="ln510">            OccupancyBitBoards[(int)Side].PopBit(sourceSquare);</a>
<a name="ln511"> </a>
<a name="ln512">            PieceBitBoards[newPiece].SetBit(targetSquare);</a>
<a name="ln513">            OccupancyBitBoards[(int)Side].SetBit(targetSquare);</a>
<a name="ln514"> </a>
<a name="ln515">            UniqueIdentifier ^=</a>
<a name="ln516">                ZobristTable.SideHash()</a>
<a name="ln517">                ^ ZobristTable.PieceHash(sourceSquare, piece)</a>
<a name="ln518">                ^ ZobristTable.PieceHash(targetSquare, newPiece)</a>
<a name="ln519">                ^ ZobristTable.EnPassantHash((int)EnPassant)            // We clear the existing enpassant square, if any</a>
<a name="ln520">                ^ ZobristTable.CastleHash(Castle);                      // We clear the existing castle rights</a>
<a name="ln521"> </a>
<a name="ln522">            EnPassant = BoardSquare.noSquare;</a>
<a name="ln523">            if (move.IsCapture())</a>
<a name="ln524">            {</a>
<a name="ln525">                var oppositeSideOffset = Utils.PieceOffset(oppositeSide);</a>
<a name="ln526">                var oppositePawnIndex = (int)Piece.P + oppositeSideOffset;</a>
<a name="ln527"> </a>
<a name="ln528">                if (move.IsEnPassant())</a>
<a name="ln529">                {</a>
<a name="ln530">                    var capturedPawnSquare = Constants.EnPassantCaptureSquares[targetSquare];</a>
<a name="ln531">                    Utils.Assert(PieceBitBoards[oppositePawnIndex].GetBit(capturedPawnSquare), $&quot;Expected {(Side)oppositeSide} pawn in {capturedPawnSquare}&quot;);</a>
<a name="ln532"> </a>
<a name="ln533">                    PieceBitBoards[oppositePawnIndex].PopBit(capturedPawnSquare);</a>
<a name="ln534">                    OccupancyBitBoards[oppositeSide].PopBit(capturedPawnSquare);</a>
<a name="ln535">                    UniqueIdentifier ^= ZobristTable.PieceHash(capturedPawnSquare, oppositePawnIndex);</a>
<a name="ln536">                    capturedPiece = oppositePawnIndex;</a>
<a name="ln537">                }</a>
<a name="ln538">                else</a>
<a name="ln539">                {</a>
<a name="ln540">                    var limit = (int)Piece.K + oppositeSideOffset;</a>
<a name="ln541">                    for (int pieceIndex = oppositePawnIndex; pieceIndex &lt; limit; ++pieceIndex)</a>
<a name="ln542">                    {</a>
<a name="ln543">                        if (PieceBitBoards[pieceIndex].GetBit(targetSquare))</a>
<a name="ln544">                        {</a>
<a name="ln545">                            PieceBitBoards[pieceIndex].PopBit(targetSquare);</a>
<a name="ln546">                            UniqueIdentifier ^= ZobristTable.PieceHash(targetSquare, pieceIndex);</a>
<a name="ln547">                            capturedPiece = pieceIndex;</a>
<a name="ln548">                            break;</a>
<a name="ln549">                        }</a>
<a name="ln550">                    }</a>
<a name="ln551"> </a>
<a name="ln552">                    OccupancyBitBoards[oppositeSide].PopBit(targetSquare);</a>
<a name="ln553">                }</a>
<a name="ln554">            }</a>
<a name="ln555">            else if (move.IsDoublePawnPush())</a>
<a name="ln556">            {</a>
<a name="ln557">                var pawnPush = +8 - ((int)oldSide * 16);</a>
<a name="ln558">                var enPassantSquare = sourceSquare + pawnPush;</a>
<a name="ln559"> </a>
<a name="ln560">                EnPassant = (BoardSquare)enPassantSquare;</a>
<a name="ln561">                UniqueIdentifier ^= ZobristTable.EnPassantHash(enPassantSquare);</a>
<a name="ln562">            }</a>
<a name="ln563">            else if (move.IsShortCastle())</a>
<a name="ln564">            {</a>
<a name="ln565">                var rookSourceSquare = Utils.ShortCastleRookSourceSquare(oldSide);</a>
<a name="ln566">                var rookTargetSquare = Utils.ShortCastleRookTargetSquare(oldSide);</a>
<a name="ln567">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln568"> </a>
<a name="ln569">                PieceBitBoards[rookIndex].PopBit(rookSourceSquare);</a>
<a name="ln570">                OccupancyBitBoards[(int)Side].PopBit(rookSourceSquare);</a>
<a name="ln571"> </a>
<a name="ln572">                PieceBitBoards[rookIndex].SetBit(rookTargetSquare);</a>
<a name="ln573">                OccupancyBitBoards[(int)Side].SetBit(rookTargetSquare);</a>
<a name="ln574"> </a>
<a name="ln575">                UniqueIdentifier ^=</a>
<a name="ln576">                    ZobristTable.PieceHash(rookSourceSquare, rookIndex)</a>
<a name="ln577">                    ^ ZobristTable.PieceHash(rookTargetSquare, rookIndex);</a>
<a name="ln578">            }</a>
<a name="ln579">            else if (move.IsLongCastle())</a>
<a name="ln580">            {</a>
<a name="ln581">                var rookSourceSquare = Utils.LongCastleRookSourceSquare(oldSide);</a>
<a name="ln582">                var rookTargetSquare = Utils.LongCastleRookTargetSquare(oldSide);</a>
<a name="ln583">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln584"> </a>
<a name="ln585">                PieceBitBoards[rookIndex].PopBit(rookSourceSquare);</a>
<a name="ln586">                OccupancyBitBoards[(int)Side].PopBit(rookSourceSquare);</a>
<a name="ln587"> </a>
<a name="ln588">                PieceBitBoards[rookIndex].SetBit(rookTargetSquare);</a>
<a name="ln589">                OccupancyBitBoards[(int)Side].SetBit(rookTargetSquare);</a>
<a name="ln590"> </a>
<a name="ln591">                UniqueIdentifier ^=</a>
<a name="ln592">                    ZobristTable.PieceHash(rookSourceSquare, rookIndex)</a>
<a name="ln593">                    ^ ZobristTable.PieceHash(rookTargetSquare, rookIndex);</a>
<a name="ln594">            }</a>
<a name="ln595"> </a>
<a name="ln596">            Side = (Side)oppositeSide;</a>
<a name="ln597">            OccupancyBitBoards[(int)Side.Both] = OccupancyBitBoards[(int)Side.White] | OccupancyBitBoards[(int)Side.Black];</a>
<a name="ln598"> </a>
<a name="ln599">            // Updating castling rights</a>
<a name="ln600">            Castle &amp;= Constants.CastlingRightsUpdateConstants[sourceSquare];</a>
<a name="ln601">            Castle &amp;= Constants.CastlingRightsUpdateConstants[targetSquare];</a>
<a name="ln602"> </a>
<a name="ln603">            UniqueIdentifier ^= ZobristTable.CastleHash(Castle);</a>
<a name="ln604"> </a>
<a name="ln605">            return new MakeMoveGameState(capturedPiece, castleCopy, enpassantCopy);</a>
<a name="ln606">        }</a>
<a name="ln607"> </a>
<a name="ln608">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln609">        public void UnmakeMove_Original(Move move, MakeMoveGameState gameState)</a>
<a name="ln610">        {</a>
<a name="ln611">            var oppositeSide = (int)Side;</a>
<a name="ln612">            Side = (Side)Utils.OppositeSide(Side);</a>
<a name="ln613">            var offset = Utils.PieceOffset(Side);</a>
<a name="ln614"> </a>
<a name="ln615">            int sourceSquare = move.SourceSquare();</a>
<a name="ln616">            int targetSquare = move.TargetSquare();</a>
<a name="ln617">            int piece = move.Piece();</a>
<a name="ln618">            int promotedPiece = move.PromotedPiece();</a>
<a name="ln619"> </a>
<a name="ln620">            var newPiece = piece;</a>
<a name="ln621">            if (promotedPiece != default)</a>
<a name="ln622">            {</a>
<a name="ln623">                newPiece = promotedPiece;</a>
<a name="ln624">            }</a>
<a name="ln625"> </a>
<a name="ln626">            PieceBitBoards[newPiece].PopBit(targetSquare);</a>
<a name="ln627">            OccupancyBitBoards[(int)Side].PopBit(targetSquare);</a>
<a name="ln628"> </a>
<a name="ln629">            PieceBitBoards[piece].SetBit(sourceSquare);</a>
<a name="ln630">            OccupancyBitBoards[(int)Side].SetBit(sourceSquare);</a>
<a name="ln631"> </a>
<a name="ln632">            UniqueIdentifier ^=</a>
<a name="ln633">                ZobristTable.SideHash()</a>
<a name="ln634">                ^ ZobristTable.PieceHash(sourceSquare, piece)</a>
<a name="ln635">                ^ ZobristTable.PieceHash(targetSquare, newPiece)</a>
<a name="ln636">                ^ ZobristTable.EnPassantHash((int)EnPassant)        // We clear the existing enpassant square, if any</a>
<a name="ln637">                ^ ZobristTable.CastleHash(Castle);                  // We clear the existing castling rights</a>
<a name="ln638"> </a>
<a name="ln639">            EnPassant = BoardSquare.noSquare;</a>
<a name="ln640">            if (move.IsCapture())</a>
<a name="ln641">            {</a>
<a name="ln642">                var oppositeSideOffset = Utils.PieceOffset(oppositeSide);</a>
<a name="ln643">                var oppositePawnIndex = (int)Piece.P + oppositeSideOffset;</a>
<a name="ln644"> </a>
<a name="ln645">                if (move.IsEnPassant())</a>
<a name="ln646">                {</a>
<a name="ln647">                    var capturedPawnSquare = Constants.EnPassantCaptureSquares[targetSquare];</a>
<a name="ln648">                    Utils.Assert(OccupancyBitBoards[(int)Side.Both].GetBit(capturedPawnSquare) == default,</a>
<a name="ln649">                        $&quot;Expected empty {capturedPawnSquare}&quot;);</a>
<a name="ln650"> </a>
<a name="ln651">                    PieceBitBoards[oppositePawnIndex].SetBit(capturedPawnSquare);</a>
<a name="ln652">                    OccupancyBitBoards[oppositeSide].SetBit(capturedPawnSquare);</a>
<a name="ln653">                    UniqueIdentifier ^= ZobristTable.PieceHash(capturedPawnSquare, oppositePawnIndex);</a>
<a name="ln654">                }</a>
<a name="ln655">                else</a>
<a name="ln656">                {</a>
<a name="ln657">                    PieceBitBoards[gameState.CapturedPiece].SetBit(targetSquare);</a>
<a name="ln658">                    UniqueIdentifier ^= ZobristTable.PieceHash(targetSquare, gameState.CapturedPiece);</a>
<a name="ln659"> </a>
<a name="ln660">                    OccupancyBitBoards[oppositeSide].SetBit(targetSquare);</a>
<a name="ln661">                }</a>
<a name="ln662">            }</a>
<a name="ln663">            else if (move.IsDoublePawnPush())</a>
<a name="ln664">            {</a>
<a name="ln665">                EnPassant = gameState.EnPassant;</a>
<a name="ln666">                UniqueIdentifier ^= ZobristTable.EnPassantHash((int)EnPassant);</a>
<a name="ln667">            }</a>
<a name="ln668">            else if (move.IsShortCastle())</a>
<a name="ln669">            {</a>
<a name="ln670">                var rookSourceSquare = Utils.ShortCastleRookSourceSquare(Side);</a>
<a name="ln671">                var rookTargetSquare = Utils.ShortCastleRookTargetSquare(Side);</a>
<a name="ln672">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln673"> </a>
<a name="ln674">                PieceBitBoards[rookIndex].SetBit(rookSourceSquare);</a>
<a name="ln675">                OccupancyBitBoards[(int)Side].SetBit(rookSourceSquare);</a>
<a name="ln676"> </a>
<a name="ln677">                PieceBitBoards[rookIndex].PopBit(rookTargetSquare);</a>
<a name="ln678">                OccupancyBitBoards[(int)Side].PopBit(rookTargetSquare);</a>
<a name="ln679"> </a>
<a name="ln680">                UniqueIdentifier ^=</a>
<a name="ln681">                    ZobristTable.PieceHash(rookSourceSquare, rookIndex)</a>
<a name="ln682">                    ^ ZobristTable.PieceHash(rookTargetSquare, rookIndex);</a>
<a name="ln683">            }</a>
<a name="ln684">            else if (move.IsLongCastle())</a>
<a name="ln685">            {</a>
<a name="ln686">                var rookSourceSquare = Utils.LongCastleRookSourceSquare(Side);</a>
<a name="ln687">                var rookTargetSquare = Utils.LongCastleRookTargetSquare(Side);</a>
<a name="ln688">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln689"> </a>
<a name="ln690">                PieceBitBoards[rookIndex].SetBit(rookSourceSquare);</a>
<a name="ln691">                OccupancyBitBoards[(int)Side].SetBit(rookSourceSquare);</a>
<a name="ln692"> </a>
<a name="ln693">                PieceBitBoards[rookIndex].PopBit(rookTargetSquare);</a>
<a name="ln694">                OccupancyBitBoards[(int)Side].PopBit(rookTargetSquare);</a>
<a name="ln695"> </a>
<a name="ln696">                UniqueIdentifier ^=</a>
<a name="ln697">                    ZobristTable.PieceHash(rookSourceSquare, rookIndex)</a>
<a name="ln698">                    ^ ZobristTable.PieceHash(rookTargetSquare, rookIndex);</a>
<a name="ln699">            }</a>
<a name="ln700"> </a>
<a name="ln701">            OccupancyBitBoards[(int)Side.Both] = OccupancyBitBoards[(int)Side.White] | OccupancyBitBoards[(int)Side.Black];</a>
<a name="ln702"> </a>
<a name="ln703">            // Updating castling rights</a>
<a name="ln704">            Castle = gameState.Castle;</a>
<a name="ln705"> </a>
<a name="ln706">            UniqueIdentifier ^= ZobristTable.CastleHash(Castle);</a>
<a name="ln707">        }</a>
<a name="ln708"> </a>
<a name="ln709">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln710">        public MakeMoveGameStateWithZobristKey MakeMove_WithZobristKey(Move move)</a>
<a name="ln711">        {</a>
<a name="ln712">            int capturedPiece = -1;</a>
<a name="ln713">            var castleCopy = Castle;</a>
<a name="ln714">            BoardSquare enpassantCopy = EnPassant;</a>
<a name="ln715">            var uniqueIdentifierCopy = UniqueIdentifier;</a>
<a name="ln716"> </a>
<a name="ln717">            var oldSide = Side;</a>
<a name="ln718">            var offset = Utils.PieceOffset(oldSide);</a>
<a name="ln719">            var oppositeSide = Utils.OppositeSide(oldSide);</a>
<a name="ln720"> </a>
<a name="ln721">            int sourceSquare = move.SourceSquare();</a>
<a name="ln722">            int targetSquare = move.TargetSquare();</a>
<a name="ln723">            int piece = move.Piece();</a>
<a name="ln724">            int promotedPiece = move.PromotedPiece();</a>
<a name="ln725"> </a>
<a name="ln726">            var newPiece = piece;</a>
<a name="ln727">            if (promotedPiece != default)</a>
<a name="ln728">            {</a>
<a name="ln729">                newPiece = promotedPiece;</a>
<a name="ln730">            }</a>
<a name="ln731"> </a>
<a name="ln732">            PieceBitBoards[piece].PopBit(sourceSquare);</a>
<a name="ln733">            OccupancyBitBoards[(int)Side].PopBit(sourceSquare);</a>
<a name="ln734"> </a>
<a name="ln735">            PieceBitBoards[newPiece].SetBit(targetSquare);</a>
<a name="ln736">            OccupancyBitBoards[(int)Side].SetBit(targetSquare);</a>
<a name="ln737"> </a>
<a name="ln738">            UniqueIdentifier ^=</a>
<a name="ln739">                ZobristTable.SideHash()</a>
<a name="ln740">                ^ ZobristTable.PieceHash(sourceSquare, piece)</a>
<a name="ln741">                ^ ZobristTable.PieceHash(targetSquare, newPiece)</a>
<a name="ln742">                ^ ZobristTable.EnPassantHash((int)EnPassant)            // We clear the existing enpassant square, if any</a>
<a name="ln743">                ^ ZobristTable.CastleHash(Castle);                      // We clear the existing castle rights</a>
<a name="ln744"> </a>
<a name="ln745">            EnPassant = BoardSquare.noSquare;</a>
<a name="ln746">            if (move.IsCapture())</a>
<a name="ln747">            {</a>
<a name="ln748">                var oppositeSideOffset = Utils.PieceOffset(oppositeSide);</a>
<a name="ln749">                var oppositePawnIndex = (int)Piece.P + oppositeSideOffset;</a>
<a name="ln750"> </a>
<a name="ln751">                if (move.IsEnPassant())</a>
<a name="ln752">                {</a>
<a name="ln753">                    var capturedPawnSquare = Constants.EnPassantCaptureSquares[targetSquare];</a>
<a name="ln754">                    Utils.Assert(PieceBitBoards[oppositePawnIndex].GetBit(capturedPawnSquare), $&quot;Expected {(Side)oppositeSide} pawn in {capturedPawnSquare}&quot;);</a>
<a name="ln755"> </a>
<a name="ln756">                    PieceBitBoards[oppositePawnIndex].PopBit(capturedPawnSquare);</a>
<a name="ln757">                    OccupancyBitBoards[oppositeSide].PopBit(capturedPawnSquare);</a>
<a name="ln758">                    UniqueIdentifier ^= ZobristTable.PieceHash(capturedPawnSquare, oppositePawnIndex);</a>
<a name="ln759">                    capturedPiece = oppositePawnIndex;</a>
<a name="ln760">                }</a>
<a name="ln761">                else</a>
<a name="ln762">                {</a>
<a name="ln763">                    var limit = (int)Piece.K + oppositeSideOffset;</a>
<a name="ln764">                    for (int pieceIndex = oppositePawnIndex; pieceIndex &lt; limit; ++pieceIndex)</a>
<a name="ln765">                    {</a>
<a name="ln766">                        if (PieceBitBoards[pieceIndex].GetBit(targetSquare))</a>
<a name="ln767">                        {</a>
<a name="ln768">                            PieceBitBoards[pieceIndex].PopBit(targetSquare);</a>
<a name="ln769">                            UniqueIdentifier ^= ZobristTable.PieceHash(targetSquare, pieceIndex);</a>
<a name="ln770">                            capturedPiece = pieceIndex;</a>
<a name="ln771">                            break;</a>
<a name="ln772">                        }</a>
<a name="ln773">                    }</a>
<a name="ln774"> </a>
<a name="ln775">                    OccupancyBitBoards[oppositeSide].PopBit(targetSquare);</a>
<a name="ln776">                }</a>
<a name="ln777">            }</a>
<a name="ln778">            else if (move.IsDoublePawnPush())</a>
<a name="ln779">            {</a>
<a name="ln780">                var pawnPush = +8 - ((int)oldSide * 16);</a>
<a name="ln781">                var enPassantSquare = sourceSquare + pawnPush;</a>
<a name="ln782"> </a>
<a name="ln783">                EnPassant = (BoardSquare)enPassantSquare;</a>
<a name="ln784">                UniqueIdentifier ^= ZobristTable.EnPassantHash(enPassantSquare);</a>
<a name="ln785">            }</a>
<a name="ln786">            else if (move.IsShortCastle())</a>
<a name="ln787">            {</a>
<a name="ln788">                var rookSourceSquare = Utils.ShortCastleRookSourceSquare(oldSide);</a>
<a name="ln789">                var rookTargetSquare = Utils.ShortCastleRookTargetSquare(oldSide);</a>
<a name="ln790">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln791"> </a>
<a name="ln792">                PieceBitBoards[rookIndex].PopBit(rookSourceSquare);</a>
<a name="ln793">                OccupancyBitBoards[(int)Side].PopBit(rookSourceSquare);</a>
<a name="ln794"> </a>
<a name="ln795">                PieceBitBoards[rookIndex].SetBit(rookTargetSquare);</a>
<a name="ln796">                OccupancyBitBoards[(int)Side].SetBit(rookTargetSquare);</a>
<a name="ln797"> </a>
<a name="ln798">                UniqueIdentifier ^=</a>
<a name="ln799">                    ZobristTable.PieceHash(rookSourceSquare, rookIndex)</a>
<a name="ln800">                    ^ ZobristTable.PieceHash(rookTargetSquare, rookIndex);</a>
<a name="ln801">            }</a>
<a name="ln802">            else if (move.IsLongCastle())</a>
<a name="ln803">            {</a>
<a name="ln804">                var rookSourceSquare = Utils.LongCastleRookSourceSquare(oldSide);</a>
<a name="ln805">                var rookTargetSquare = Utils.LongCastleRookTargetSquare(oldSide);</a>
<a name="ln806">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln807"> </a>
<a name="ln808">                PieceBitBoards[rookIndex].PopBit(rookSourceSquare);</a>
<a name="ln809">                OccupancyBitBoards[(int)Side].PopBit(rookSourceSquare);</a>
<a name="ln810"> </a>
<a name="ln811">                PieceBitBoards[rookIndex].SetBit(rookTargetSquare);</a>
<a name="ln812">                OccupancyBitBoards[(int)Side].SetBit(rookTargetSquare);</a>
<a name="ln813"> </a>
<a name="ln814">                UniqueIdentifier ^=</a>
<a name="ln815">                    ZobristTable.PieceHash(rookSourceSquare, rookIndex)</a>
<a name="ln816">                    ^ ZobristTable.PieceHash(rookTargetSquare, rookIndex);</a>
<a name="ln817">            }</a>
<a name="ln818"> </a>
<a name="ln819">            Side = (Side)oppositeSide;</a>
<a name="ln820">            OccupancyBitBoards[(int)Side.Both] = OccupancyBitBoards[(int)Side.White] | OccupancyBitBoards[(int)Side.Black];</a>
<a name="ln821"> </a>
<a name="ln822">            // Updating castling rights</a>
<a name="ln823">            Castle &amp;= Constants.CastlingRightsUpdateConstants[sourceSquare];</a>
<a name="ln824">            Castle &amp;= Constants.CastlingRightsUpdateConstants[targetSquare];</a>
<a name="ln825"> </a>
<a name="ln826">            UniqueIdentifier ^= ZobristTable.CastleHash(Castle);</a>
<a name="ln827"> </a>
<a name="ln828">            return new MakeMoveGameStateWithZobristKey(capturedPiece, castleCopy, enpassantCopy, uniqueIdentifierCopy);</a>
<a name="ln829">        }</a>
<a name="ln830"> </a>
<a name="ln831">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln832">        public MakeMoveGameStateWithZobristKey MakeMove_WithZobristKey_PreSwitchSpecialMove(Move move)</a>
<a name="ln833">        {</a>
<a name="ln834">            int capturedPiece = -1;</a>
<a name="ln835">            byte castleCopy = Castle;</a>
<a name="ln836">            BoardSquare enpassantCopy = EnPassant;</a>
<a name="ln837">            var uniqueIdentifierCopy = UniqueIdentifier;</a>
<a name="ln838"> </a>
<a name="ln839">            var oldSide = (int)Side;</a>
<a name="ln840">            var offset = Utils.PieceOffset(oldSide);</a>
<a name="ln841">            var oppositeSide = Utils.OppositeSide(oldSide);</a>
<a name="ln842"> </a>
<a name="ln843">            int sourceSquare = move.SourceSquare();</a>
<a name="ln844">            int targetSquare = move.TargetSquare();</a>
<a name="ln845">            int piece = move.Piece();</a>
<a name="ln846">            int promotedPiece = move.PromotedPiece();</a>
<a name="ln847"> </a>
<a name="ln848">            var newPiece = piece;</a>
<a name="ln849">            if (promotedPiece != default)</a>
<a name="ln850">            {</a>
<a name="ln851">                newPiece = promotedPiece;</a>
<a name="ln852">            }</a>
<a name="ln853"> </a>
<a name="ln854">            PieceBitBoards[piece].PopBit(sourceSquare);</a>
<a name="ln855">            OccupancyBitBoards[oldSide].PopBit(sourceSquare);</a>
<a name="ln856"> </a>
<a name="ln857">            PieceBitBoards[newPiece].SetBit(targetSquare);</a>
<a name="ln858">            OccupancyBitBoards[oldSide].SetBit(targetSquare);</a>
<a name="ln859"> </a>
<a name="ln860">            UniqueIdentifier ^=</a>
<a name="ln861">                ZobristTable.SideHash()</a>
<a name="ln862">                ^ ZobristTable.PieceHash(sourceSquare, piece)</a>
<a name="ln863">                ^ ZobristTable.PieceHash(targetSquare, newPiece)</a>
<a name="ln864">                ^ ZobristTable.EnPassantHash((int)EnPassant)            // We clear the existing enpassant square, if any</a>
<a name="ln865">                ^ ZobristTable.CastleHash(Castle);                      // We clear the existing castle rights</a>
<a name="ln866"> </a>
<a name="ln867">            EnPassant = BoardSquare.noSquare;</a>
<a name="ln868">            if (move.IsCapture())</a>
<a name="ln869">            {</a>
<a name="ln870">                var oppositePawnIndex = (int)Piece.p - offset;</a>
<a name="ln871"> </a>
<a name="ln872">                var capturedSquare = targetSquare;</a>
<a name="ln873">                capturedPiece = oppositePawnIndex;</a>
<a name="ln874">                if (move.IsEnPassant())</a>
<a name="ln875">                {</a>
<a name="ln876">                    capturedSquare = Constants.EnPassantCaptureSquares[targetSquare];</a>
<a name="ln877">                    Utils.Assert(PieceBitBoards[oppositePawnIndex].GetBit(capturedSquare), $&quot;Expected {(Side)oppositeSide} pawn in {capturedSquare}&quot;);</a>
<a name="ln878">                }</a>
<a name="ln879">                else</a>
<a name="ln880">                {</a>
<a name="ln881">                    capturedPiece = move.CapturedPiece();</a>
<a name="ln882">                }</a>
<a name="ln883"> </a>
<a name="ln884">                PieceBitBoards[capturedPiece].PopBit(capturedSquare);</a>
<a name="ln885">                OccupancyBitBoards[oppositeSide].PopBit(capturedSquare);</a>
<a name="ln886">                UniqueIdentifier ^= ZobristTable.PieceHash(capturedSquare, capturedPiece);</a>
<a name="ln887">            }</a>
<a name="ln888">            else if (move.IsDoublePawnPush())</a>
<a name="ln889">            {</a>
<a name="ln890">                var pawnPush = +8 - (oldSide * 16);</a>
<a name="ln891">                var enPassantSquare = sourceSquare + pawnPush;</a>
<a name="ln892">                Utils.Assert(Constants.EnPassantCaptureSquares.Length &gt; enPassantSquare &amp;&amp; Constants.EnPassantCaptureSquares[enPassantSquare] != 0, $&quot;Unexpected en passant square : {(BoardSquare)enPassantSquare}&quot;);</a>
<a name="ln893"> </a>
<a name="ln894">                EnPassant = (BoardSquare)enPassantSquare;</a>
<a name="ln895">                UniqueIdentifier ^= ZobristTable.EnPassantHash(enPassantSquare);</a>
<a name="ln896">            }</a>
<a name="ln897">            else if (move.IsShortCastle())</a>
<a name="ln898">            {</a>
<a name="ln899">                var rookSourceSquare = Utils.ShortCastleRookSourceSquare(oldSide);</a>
<a name="ln900">                var rookTargetSquare = Utils.ShortCastleRookTargetSquare(oldSide);</a>
<a name="ln901">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln902"> </a>
<a name="ln903">                PieceBitBoards[rookIndex].PopBit(rookSourceSquare);</a>
<a name="ln904">                OccupancyBitBoards[oldSide].PopBit(rookSourceSquare);</a>
<a name="ln905"> </a>
<a name="ln906">                PieceBitBoards[rookIndex].SetBit(rookTargetSquare);</a>
<a name="ln907">                OccupancyBitBoards[oldSide].SetBit(rookTargetSquare);</a>
<a name="ln908"> </a>
<a name="ln909">                UniqueIdentifier ^=</a>
<a name="ln910">                    ZobristTable.PieceHash(rookSourceSquare, rookIndex)</a>
<a name="ln911">                    ^ ZobristTable.PieceHash(rookTargetSquare, rookIndex);</a>
<a name="ln912">            }</a>
<a name="ln913">            else if (move.IsLongCastle())</a>
<a name="ln914">            {</a>
<a name="ln915">                var rookSourceSquare = Utils.LongCastleRookSourceSquare(oldSide);</a>
<a name="ln916">                var rookTargetSquare = Utils.LongCastleRookTargetSquare(oldSide);</a>
<a name="ln917">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln918"> </a>
<a name="ln919">                PieceBitBoards[rookIndex].PopBit(rookSourceSquare);</a>
<a name="ln920">                OccupancyBitBoards[oldSide].PopBit(rookSourceSquare);</a>
<a name="ln921"> </a>
<a name="ln922">                PieceBitBoards[rookIndex].SetBit(rookTargetSquare);</a>
<a name="ln923">                OccupancyBitBoards[oldSide].SetBit(rookTargetSquare);</a>
<a name="ln924"> </a>
<a name="ln925">                UniqueIdentifier ^=</a>
<a name="ln926">                    ZobristTable.PieceHash(rookSourceSquare, rookIndex)</a>
<a name="ln927">                    ^ ZobristTable.PieceHash(rookTargetSquare, rookIndex);</a>
<a name="ln928">            }</a>
<a name="ln929"> </a>
<a name="ln930">            Side = (Side)oppositeSide;</a>
<a name="ln931">            OccupancyBitBoards[2] = OccupancyBitBoards[1] | OccupancyBitBoards[0];</a>
<a name="ln932"> </a>
<a name="ln933">            // Updating castling rights</a>
<a name="ln934">            Castle &amp;= Constants.CastlingRightsUpdateConstants[sourceSquare];</a>
<a name="ln935">            Castle &amp;= Constants.CastlingRightsUpdateConstants[targetSquare];</a>
<a name="ln936"> </a>
<a name="ln937">            UniqueIdentifier ^= ZobristTable.CastleHash(Castle);</a>
<a name="ln938"> </a>
<a name="ln939">            return new MakeMoveGameStateWithZobristKey(capturedPiece, castleCopy, enpassantCopy, uniqueIdentifierCopy);</a>
<a name="ln940">        }</a>
<a name="ln941"> </a>
<a name="ln942">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln943">        public MakeMoveGameStateWithZobristKey MakeMove_WithZobristKey_SwitchSpecialMove(Move move)</a>
<a name="ln944">        {</a>
<a name="ln945">            int capturedPiece = -1;</a>
<a name="ln946"> </a>
<a name="ln947">            byte castleCopy = Castle;</a>
<a name="ln948">            BoardSquare enpassantCopy = EnPassant;</a>
<a name="ln949">            var uniqueIdentifierCopy = UniqueIdentifier;</a>
<a name="ln950"> </a>
<a name="ln951">            var oldSide = (int)Side;</a>
<a name="ln952">            var offset = Utils.PieceOffset(oldSide);</a>
<a name="ln953">            var oppositeSide = Utils.OppositeSide(oldSide);</a>
<a name="ln954"> </a>
<a name="ln955">            int sourceSquare = move.SourceSquare();</a>
<a name="ln956">            int targetSquare = move.TargetSquare();</a>
<a name="ln957">            int piece = move.Piece();</a>
<a name="ln958">            int promotedPiece = move.PromotedPiece();</a>
<a name="ln959"> </a>
<a name="ln960">            var newPiece = piece;</a>
<a name="ln961">            if (promotedPiece != default)</a>
<a name="ln962">            {</a>
<a name="ln963">                newPiece = promotedPiece;</a>
<a name="ln964">            }</a>
<a name="ln965"> </a>
<a name="ln966">            PieceBitBoards[piece].PopBit(sourceSquare);</a>
<a name="ln967">            OccupancyBitBoards[oldSide].PopBit(sourceSquare);</a>
<a name="ln968"> </a>
<a name="ln969">            PieceBitBoards[newPiece].SetBit(targetSquare);</a>
<a name="ln970">            OccupancyBitBoards[oldSide].SetBit(targetSquare);</a>
<a name="ln971"> </a>
<a name="ln972">            UniqueIdentifier ^=</a>
<a name="ln973">                ZobristTable.SideHash()</a>
<a name="ln974">                ^ ZobristTable.PieceHash(sourceSquare, piece)</a>
<a name="ln975">                ^ ZobristTable.PieceHash(targetSquare, newPiece)</a>
<a name="ln976">                ^ ZobristTable.EnPassantHash((int)EnPassant)            // We clear the existing enpassant square, if any</a>
<a name="ln977">                ^ ZobristTable.CastleHash(Castle);                      // We clear the existing castle rights</a>
<a name="ln978"> </a>
<a name="ln979">            EnPassant = BoardSquare.noSquare;</a>
<a name="ln980"> </a>
<a name="ln981">            switch (move.SpecialMoveFlag())</a>
<a name="ln982">            {</a>
<a name="ln983">                case SpecialMoveType.None:</a>
<a name="ln984">                    {</a>
<a name="ln985">                        if (move.IsCapture())</a>
<a name="ln986">                        {</a>
<a name="ln987">                            var capturedSquare = targetSquare;</a>
<a name="ln988">                            capturedPiece = move.CapturedPiece();</a>
<a name="ln989"> </a>
<a name="ln990">                            PieceBitBoards[capturedPiece].PopBit(capturedSquare);</a>
<a name="ln991">                            OccupancyBitBoards[oppositeSide].PopBit(capturedSquare);</a>
<a name="ln992">                            UniqueIdentifier ^= ZobristTable.PieceHash(capturedSquare, capturedPiece);</a>
<a name="ln993">                        }</a>
<a name="ln994"> </a>
<a name="ln995">                        break;</a>
<a name="ln996">                    }</a>
<a name="ln997">                case SpecialMoveType.DoublePawnPush:</a>
<a name="ln998">                    {</a>
<a name="ln999">                        var pawnPush = +8 - (oldSide * 16);</a>
<a name="ln1000">                        var enPassantSquare = sourceSquare + pawnPush;</a>
<a name="ln1001">                        Utils.Assert(Constants.EnPassantCaptureSquares.Length &gt; enPassantSquare &amp;&amp; Constants.EnPassantCaptureSquares[enPassantSquare] != 0, $&quot;Unexpected en passant square : {(BoardSquare)enPassantSquare}&quot;);</a>
<a name="ln1002"> </a>
<a name="ln1003">                        EnPassant = (BoardSquare)enPassantSquare;</a>
<a name="ln1004">                        UniqueIdentifier ^= ZobristTable.EnPassantHash(enPassantSquare);</a>
<a name="ln1005"> </a>
<a name="ln1006">                        break;</a>
<a name="ln1007">                    }</a>
<a name="ln1008">                case SpecialMoveType.ShortCastle:</a>
<a name="ln1009">                    {</a>
<a name="ln1010">                        var rookSourceSquare = Utils.ShortCastleRookSourceSquare(oldSide);</a>
<a name="ln1011">                        var rookTargetSquare = Utils.ShortCastleRookTargetSquare(oldSide);</a>
<a name="ln1012">                        var rookIndex = (int)Piece.R + offset;</a>
<a name="ln1013"> </a>
<a name="ln1014">                        PieceBitBoards[rookIndex].PopBit(rookSourceSquare);</a>
<a name="ln1015">                        OccupancyBitBoards[oldSide].PopBit(rookSourceSquare);</a>
<a name="ln1016"> </a>
<a name="ln1017">                        PieceBitBoards[rookIndex].SetBit(rookTargetSquare);</a>
<a name="ln1018">                        OccupancyBitBoards[oldSide].SetBit(rookTargetSquare);</a>
<a name="ln1019"> </a>
<a name="ln1020">                        UniqueIdentifier ^=</a>
<a name="ln1021">                            ZobristTable.PieceHash(rookSourceSquare, rookIndex)</a>
<a name="ln1022">                            ^ ZobristTable.PieceHash(rookTargetSquare, rookIndex);</a>
<a name="ln1023"> </a>
<a name="ln1024">                        break;</a>
<a name="ln1025">                    }</a>
<a name="ln1026">                case SpecialMoveType.LongCastle:</a>
<a name="ln1027">                    {</a>
<a name="ln1028">                        var rookSourceSquare = Utils.LongCastleRookSourceSquare(oldSide);</a>
<a name="ln1029">                        var rookTargetSquare = Utils.LongCastleRookTargetSquare(oldSide);</a>
<a name="ln1030">                        var rookIndex = (int)Piece.R + offset;</a>
<a name="ln1031"> </a>
<a name="ln1032">                        PieceBitBoards[rookIndex].PopBit(rookSourceSquare);</a>
<a name="ln1033">                        OccupancyBitBoards[oldSide].PopBit(rookSourceSquare);</a>
<a name="ln1034"> </a>
<a name="ln1035">                        PieceBitBoards[rookIndex].SetBit(rookTargetSquare);</a>
<a name="ln1036">                        OccupancyBitBoards[oldSide].SetBit(rookTargetSquare);</a>
<a name="ln1037"> </a>
<a name="ln1038">                        UniqueIdentifier ^=</a>
<a name="ln1039">                            ZobristTable.PieceHash(rookSourceSquare, rookIndex)</a>
<a name="ln1040">                            ^ ZobristTable.PieceHash(rookTargetSquare, rookIndex);</a>
<a name="ln1041"> </a>
<a name="ln1042">                        break;</a>
<a name="ln1043">                    }</a>
<a name="ln1044">                case SpecialMoveType.EnPassant:</a>
<a name="ln1045">                    {</a>
<a name="ln1046">                        var oppositePawnIndex = (int)Piece.p - offset;</a>
<a name="ln1047"> </a>
<a name="ln1048">                        var capturedSquare = Constants.EnPassantCaptureSquares[targetSquare];</a>
<a name="ln1049">                        capturedPiece = oppositePawnIndex;</a>
<a name="ln1050">                        Utils.Assert(PieceBitBoards[oppositePawnIndex].GetBit(capturedSquare), $&quot;Expected {(Side)oppositeSide} pawn in {capturedSquare}&quot;);</a>
<a name="ln1051"> </a>
<a name="ln1052">                        PieceBitBoards[capturedPiece].PopBit(capturedSquare);</a>
<a name="ln1053">                        OccupancyBitBoards[oppositeSide].PopBit(capturedSquare);</a>
<a name="ln1054">                        UniqueIdentifier ^= ZobristTable.PieceHash(capturedSquare, capturedPiece);</a>
<a name="ln1055"> </a>
<a name="ln1056">                        break;</a>
<a name="ln1057">                    }</a>
<a name="ln1058">            }</a>
<a name="ln1059"> </a>
<a name="ln1060">            Side = (Side)oppositeSide;</a>
<a name="ln1061">            OccupancyBitBoards[2] = OccupancyBitBoards[1] | OccupancyBitBoards[0];</a>
<a name="ln1062"> </a>
<a name="ln1063">            // Updating castling rights</a>
<a name="ln1064">            Castle &amp;= Constants.CastlingRightsUpdateConstants[sourceSquare];</a>
<a name="ln1065">            Castle &amp;= Constants.CastlingRightsUpdateConstants[targetSquare];</a>
<a name="ln1066"> </a>
<a name="ln1067">            UniqueIdentifier ^= ZobristTable.CastleHash(Castle);</a>
<a name="ln1068"> </a>
<a name="ln1069">            return new MakeMoveGameStateWithZobristKey(capturedPiece, castleCopy, enpassantCopy, uniqueIdentifierCopy);</a>
<a name="ln1070">        }</a>
<a name="ln1071"> </a>
<a name="ln1072">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1073">        public void UnmakeMove_WithZobristKey(Move move, MakeMoveGameStateWithZobristKey gameState)</a>
<a name="ln1074">        {</a>
<a name="ln1075">            var oppositeSide = (int)Side;</a>
<a name="ln1076">            Side = (Side)Utils.OppositeSide(Side);</a>
<a name="ln1077">            var offset = Utils.PieceOffset(Side);</a>
<a name="ln1078"> </a>
<a name="ln1079">            int sourceSquare = move.SourceSquare();</a>
<a name="ln1080">            int targetSquare = move.TargetSquare();</a>
<a name="ln1081">            int piece = move.Piece();</a>
<a name="ln1082">            int promotedPiece = move.PromotedPiece();</a>
<a name="ln1083"> </a>
<a name="ln1084">            var newPiece = piece;</a>
<a name="ln1085">            if (promotedPiece != default)</a>
<a name="ln1086">            {</a>
<a name="ln1087">                newPiece = promotedPiece;</a>
<a name="ln1088">            }</a>
<a name="ln1089"> </a>
<a name="ln1090">            PieceBitBoards[newPiece].PopBit(targetSquare);</a>
<a name="ln1091">            OccupancyBitBoards[(int)Side].PopBit(targetSquare);</a>
<a name="ln1092"> </a>
<a name="ln1093">            PieceBitBoards[piece].SetBit(sourceSquare);</a>
<a name="ln1094">            OccupancyBitBoards[(int)Side].SetBit(sourceSquare);</a>
<a name="ln1095"> </a>
<a name="ln1096">            if (move.IsCapture())</a>
<a name="ln1097">            {</a>
<a name="ln1098">                var oppositeSideOffset = Utils.PieceOffset(oppositeSide);</a>
<a name="ln1099">                var oppositePawnIndex = (int)Piece.P + oppositeSideOffset;</a>
<a name="ln1100"> </a>
<a name="ln1101">                if (move.IsEnPassant())</a>
<a name="ln1102">                {</a>
<a name="ln1103">                    var capturedPawnSquare = Constants.EnPassantCaptureSquares[targetSquare];</a>
<a name="ln1104">                    Utils.Assert(OccupancyBitBoards[(int)Side.Both].GetBit(capturedPawnSquare) == default,</a>
<a name="ln1105">                        $&quot;Expected empty {capturedPawnSquare}&quot;);</a>
<a name="ln1106"> </a>
<a name="ln1107">                    PieceBitBoards[oppositePawnIndex].SetBit(capturedPawnSquare);</a>
<a name="ln1108">                    OccupancyBitBoards[oppositeSide].SetBit(capturedPawnSquare);</a>
<a name="ln1109">                }</a>
<a name="ln1110">                else</a>
<a name="ln1111">                {</a>
<a name="ln1112">                    PieceBitBoards[gameState.CapturedPiece].SetBit(targetSquare);</a>
<a name="ln1113">                    OccupancyBitBoards[oppositeSide].SetBit(targetSquare);</a>
<a name="ln1114">                }</a>
<a name="ln1115">            }</a>
<a name="ln1116">            else if (move.IsShortCastle())</a>
<a name="ln1117">            {</a>
<a name="ln1118">                var rookSourceSquare = Utils.ShortCastleRookSourceSquare(Side);</a>
<a name="ln1119">                var rookTargetSquare = Utils.ShortCastleRookTargetSquare(Side);</a>
<a name="ln1120">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln1121"> </a>
<a name="ln1122">                PieceBitBoards[rookIndex].SetBit(rookSourceSquare);</a>
<a name="ln1123">                OccupancyBitBoards[(int)Side].SetBit(rookSourceSquare);</a>
<a name="ln1124"> </a>
<a name="ln1125">                PieceBitBoards[rookIndex].PopBit(rookTargetSquare);</a>
<a name="ln1126">                OccupancyBitBoards[(int)Side].PopBit(rookTargetSquare);</a>
<a name="ln1127">            }</a>
<a name="ln1128">            else if (move.IsLongCastle())</a>
<a name="ln1129">            {</a>
<a name="ln1130">                var rookSourceSquare = Utils.LongCastleRookSourceSquare(Side);</a>
<a name="ln1131">                var rookTargetSquare = Utils.LongCastleRookTargetSquare(Side);</a>
<a name="ln1132">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln1133"> </a>
<a name="ln1134">                PieceBitBoards[rookIndex].SetBit(rookSourceSquare);</a>
<a name="ln1135">                OccupancyBitBoards[(int)Side].SetBit(rookSourceSquare);</a>
<a name="ln1136"> </a>
<a name="ln1137">                PieceBitBoards[rookIndex].PopBit(rookTargetSquare);</a>
<a name="ln1138">                OccupancyBitBoards[(int)Side].PopBit(rookTargetSquare);</a>
<a name="ln1139">            }</a>
<a name="ln1140"> </a>
<a name="ln1141">            OccupancyBitBoards[(int)Side.Both] = OccupancyBitBoards[(int)Side.White] | OccupancyBitBoards[(int)Side.Black];</a>
<a name="ln1142"> </a>
<a name="ln1143">            // Updating saved values</a>
<a name="ln1144">            Castle = gameState.Castle;</a>
<a name="ln1145">            EnPassant = gameState.EnPassant;</a>
<a name="ln1146">            UniqueIdentifier = gameState.ZobristKey;</a>
<a name="ln1147">        }</a>
<a name="ln1148"> </a>
<a name="ln1149">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1150">        public void UnmakeMove_WithZobristKey_PreSwitchSpecialMove(Move move, MakeMoveGameStateWithZobristKey gameState)</a>
<a name="ln1151">        {</a>
<a name="ln1152">            var oppositeSide = (int)Side;</a>
<a name="ln1153">            var side = Utils.OppositeSide(oppositeSide);</a>
<a name="ln1154">            Side = (Side)side;</a>
<a name="ln1155">            var offset = Utils.PieceOffset(side);</a>
<a name="ln1156"> </a>
<a name="ln1157">            int sourceSquare = move.SourceSquare();</a>
<a name="ln1158">            int targetSquare = move.TargetSquare();</a>
<a name="ln1159">            int piece = move.Piece();</a>
<a name="ln1160">            int promotedPiece = move.PromotedPiece();</a>
<a name="ln1161"> </a>
<a name="ln1162">            var newPiece = piece;</a>
<a name="ln1163">            if (promotedPiece != default)</a>
<a name="ln1164">            {</a>
<a name="ln1165">                newPiece = promotedPiece;</a>
<a name="ln1166">            }</a>
<a name="ln1167"> </a>
<a name="ln1168">            PieceBitBoards[newPiece].PopBit(targetSquare);</a>
<a name="ln1169">            OccupancyBitBoards[side].PopBit(targetSquare);</a>
<a name="ln1170"> </a>
<a name="ln1171">            PieceBitBoards[piece].SetBit(sourceSquare);</a>
<a name="ln1172">            OccupancyBitBoards[side].SetBit(sourceSquare);</a>
<a name="ln1173"> </a>
<a name="ln1174">            if (move.IsCapture())</a>
<a name="ln1175">            {</a>
<a name="ln1176">                var oppositePawnIndex = (int)Piece.p - offset;</a>
<a name="ln1177"> </a>
<a name="ln1178">                if (move.IsEnPassant())</a>
<a name="ln1179">                {</a>
<a name="ln1180">                    var capturedPawnSquare = Constants.EnPassantCaptureSquares[targetSquare];</a>
<a name="ln1181">                    Utils.Assert(OccupancyBitBoards[(int)Side.Both].GetBit(capturedPawnSquare) == default,</a>
<a name="ln1182">                        $&quot;Expected empty {capturedPawnSquare}&quot;);</a>
<a name="ln1183"> </a>
<a name="ln1184">                    PieceBitBoards[oppositePawnIndex].SetBit(capturedPawnSquare);</a>
<a name="ln1185">                    OccupancyBitBoards[oppositeSide].SetBit(capturedPawnSquare);</a>
<a name="ln1186">                }</a>
<a name="ln1187">                else</a>
<a name="ln1188">                {</a>
<a name="ln1189">                    PieceBitBoards[move.CapturedPiece()].SetBit(targetSquare);</a>
<a name="ln1190">                    OccupancyBitBoards[oppositeSide].SetBit(targetSquare);</a>
<a name="ln1191">                }</a>
<a name="ln1192">            }</a>
<a name="ln1193">            else if (move.IsShortCastle())</a>
<a name="ln1194">            {</a>
<a name="ln1195">                var rookSourceSquare = Utils.ShortCastleRookSourceSquare(side);</a>
<a name="ln1196">                var rookTargetSquare = Utils.ShortCastleRookTargetSquare(side);</a>
<a name="ln1197">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln1198"> </a>
<a name="ln1199">                PieceBitBoards[rookIndex].SetBit(rookSourceSquare);</a>
<a name="ln1200">                OccupancyBitBoards[side].SetBit(rookSourceSquare);</a>
<a name="ln1201"> </a>
<a name="ln1202">                PieceBitBoards[rookIndex].PopBit(rookTargetSquare);</a>
<a name="ln1203">                OccupancyBitBoards[side].PopBit(rookTargetSquare);</a>
<a name="ln1204">            }</a>
<a name="ln1205">            else if (move.IsLongCastle())</a>
<a name="ln1206">            {</a>
<a name="ln1207">                var rookSourceSquare = Utils.LongCastleRookSourceSquare(side);</a>
<a name="ln1208">                var rookTargetSquare = Utils.LongCastleRookTargetSquare(side);</a>
<a name="ln1209">                var rookIndex = (int)Piece.R + offset;</a>
<a name="ln1210"> </a>
<a name="ln1211">                PieceBitBoards[rookIndex].SetBit(rookSourceSquare);</a>
<a name="ln1212">                OccupancyBitBoards[side].SetBit(rookSourceSquare);</a>
<a name="ln1213"> </a>
<a name="ln1214">                PieceBitBoards[rookIndex].PopBit(rookTargetSquare);</a>
<a name="ln1215">                OccupancyBitBoards[side].PopBit(rookTargetSquare);</a>
<a name="ln1216">            }</a>
<a name="ln1217"> </a>
<a name="ln1218">            OccupancyBitBoards[2] = OccupancyBitBoards[1] | OccupancyBitBoards[0];</a>
<a name="ln1219"> </a>
<a name="ln1220">            // Updating saved values</a>
<a name="ln1221">            Castle = gameState.Castle;</a>
<a name="ln1222">            EnPassant = gameState.EnPassant;</a>
<a name="ln1223">            UniqueIdentifier = gameState.ZobristKey;</a>
<a name="ln1224">        }</a>
<a name="ln1225"> </a>
<a name="ln1226">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1227">        public void UnmakeMove_WithZobristKey_SwitchSpecialMove(Move move, MakeMoveGameStateWithZobristKey gameState)</a>
<a name="ln1228">        {</a>
<a name="ln1229">            var oppositeSide = (int)Side;</a>
<a name="ln1230">            var side = Utils.OppositeSide(oppositeSide);</a>
<a name="ln1231">            Side = (Side)side;</a>
<a name="ln1232">            var offset = Utils.PieceOffset(side);</a>
<a name="ln1233"> </a>
<a name="ln1234">            int sourceSquare = move.SourceSquare();</a>
<a name="ln1235">            int targetSquare = move.TargetSquare();</a>
<a name="ln1236">            int piece = move.Piece();</a>
<a name="ln1237">            int promotedPiece = move.PromotedPiece();</a>
<a name="ln1238"> </a>
<a name="ln1239">            var newPiece = piece;</a>
<a name="ln1240">            if (promotedPiece != default)</a>
<a name="ln1241">            {</a>
<a name="ln1242">                newPiece = promotedPiece;</a>
<a name="ln1243">            }</a>
<a name="ln1244"> </a>
<a name="ln1245">            PieceBitBoards[newPiece].PopBit(targetSquare);</a>
<a name="ln1246">            OccupancyBitBoards[side].PopBit(targetSquare);</a>
<a name="ln1247"> </a>
<a name="ln1248">            PieceBitBoards[piece].SetBit(sourceSquare);</a>
<a name="ln1249">            OccupancyBitBoards[side].SetBit(sourceSquare);</a>
<a name="ln1250"> </a>
<a name="ln1251">            switch (move.SpecialMoveFlag())</a>
<a name="ln1252">            {</a>
<a name="ln1253">                case SpecialMoveType.None:</a>
<a name="ln1254">                    {</a>
<a name="ln1255">                        if (move.IsCapture())</a>
<a name="ln1256">                        {</a>
<a name="ln1257">                            PieceBitBoards[move.CapturedPiece()].SetBit(targetSquare);</a>
<a name="ln1258">                            OccupancyBitBoards[oppositeSide].SetBit(targetSquare);</a>
<a name="ln1259">                        }</a>
<a name="ln1260"> </a>
<a name="ln1261">                        break;</a>
<a name="ln1262">                    }</a>
<a name="ln1263">                case SpecialMoveType.ShortCastle:</a>
<a name="ln1264">                    {</a>
<a name="ln1265">                        var rookSourceSquare = Utils.ShortCastleRookSourceSquare(side);</a>
<a name="ln1266">                        var rookTargetSquare = Utils.ShortCastleRookTargetSquare(side);</a>
<a name="ln1267">                        var rookIndex = (int)Piece.R + offset;</a>
<a name="ln1268"> </a>
<a name="ln1269">                        PieceBitBoards[rookIndex].SetBit(rookSourceSquare);</a>
<a name="ln1270">                        OccupancyBitBoards[side].SetBit(rookSourceSquare);</a>
<a name="ln1271"> </a>
<a name="ln1272">                        PieceBitBoards[rookIndex].PopBit(rookTargetSquare);</a>
<a name="ln1273">                        OccupancyBitBoards[side].PopBit(rookTargetSquare);</a>
<a name="ln1274"> </a>
<a name="ln1275">                        break;</a>
<a name="ln1276">                    }</a>
<a name="ln1277">                case SpecialMoveType.LongCastle:</a>
<a name="ln1278">                    {</a>
<a name="ln1279">                        var rookSourceSquare = Utils.LongCastleRookSourceSquare(side);</a>
<a name="ln1280">                        var rookTargetSquare = Utils.LongCastleRookTargetSquare(side);</a>
<a name="ln1281">                        var rookIndex = (int)Piece.R + offset;</a>
<a name="ln1282"> </a>
<a name="ln1283">                        PieceBitBoards[rookIndex].SetBit(rookSourceSquare);</a>
<a name="ln1284">                        OccupancyBitBoards[side].SetBit(rookSourceSquare);</a>
<a name="ln1285"> </a>
<a name="ln1286">                        PieceBitBoards[rookIndex].PopBit(rookTargetSquare);</a>
<a name="ln1287">                        OccupancyBitBoards[side].PopBit(rookTargetSquare);</a>
<a name="ln1288"> </a>
<a name="ln1289">                        break;</a>
<a name="ln1290">                    }</a>
<a name="ln1291">                case SpecialMoveType.EnPassant:</a>
<a name="ln1292">                    {</a>
<a name="ln1293">                        var oppositePawnIndex = (int)Piece.p - offset;</a>
<a name="ln1294"> </a>
<a name="ln1295">                        if (move.IsEnPassant())</a>
<a name="ln1296">                        {</a>
<a name="ln1297">                            var capturedPawnSquare = Constants.EnPassantCaptureSquares[targetSquare];</a>
<a name="ln1298">                            Utils.Assert(OccupancyBitBoards[(int)Side.Both].GetBit(capturedPawnSquare) == default,</a>
<a name="ln1299">                                $&quot;Expected empty {capturedPawnSquare}&quot;);</a>
<a name="ln1300"> </a>
<a name="ln1301">                            PieceBitBoards[oppositePawnIndex].SetBit(capturedPawnSquare);</a>
<a name="ln1302">                            OccupancyBitBoards[oppositeSide].SetBit(capturedPawnSquare);</a>
<a name="ln1303">                        }</a>
<a name="ln1304"> </a>
<a name="ln1305">                        break;</a>
<a name="ln1306">                    }</a>
<a name="ln1307">            }</a>
<a name="ln1308"> </a>
<a name="ln1309">            OccupancyBitBoards[2] = OccupancyBitBoards[1] | OccupancyBitBoards[0];</a>
<a name="ln1310"> </a>
<a name="ln1311">            // Updating saved values</a>
<a name="ln1312">            Castle = gameState.Castle;</a>
<a name="ln1313">            EnPassant = gameState.EnPassant;</a>
<a name="ln1314">            UniqueIdentifier = gameState.ZobristKey;</a>
<a name="ln1315">        }</a>
<a name="ln1316"> </a>
<a name="ln1317">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1318">        public void MakeNullMove()</a>
<a name="ln1319">        {</a>
<a name="ln1320">            Side = (Side)Utils.OppositeSide(Side);</a>
<a name="ln1321">            var oldEnPassant = EnPassant;</a>
<a name="ln1322">            EnPassant = BoardSquare.noSquare;</a>
<a name="ln1323"> </a>
<a name="ln1324">            UniqueIdentifier ^=</a>
<a name="ln1325">                ZobristTable.SideHash()</a>
<a name="ln1326">                ^ ZobristTable.EnPassantHash((int)oldEnPassant);</a>
<a name="ln1327">        }</a>
<a name="ln1328"> </a>
<a name="ln1329">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1330">        public void UnMakeNullMove(MakeMoveGameState gameState)</a>
<a name="ln1331">        {</a>
<a name="ln1332">            Side = (Side)Utils.OppositeSide(Side);</a>
<a name="ln1333">            EnPassant = gameState.EnPassant;</a>
<a name="ln1334"> </a>
<a name="ln1335">            UniqueIdentifier ^=</a>
<a name="ln1336">                ZobristTable.SideHash()</a>
<a name="ln1337">                ^ ZobristTable.EnPassantHash((int)EnPassant);</a>
<a name="ln1338">        }</a>
<a name="ln1339"> </a>
<a name="ln1340">        /// &lt;summary&gt;</a>
<a name="ln1341">        /// False if any of the kings has been captured, or if the opponent king is in check.</a>
<a name="ln1342">        /// &lt;/summary&gt;</a>
<a name="ln1343">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1344">        internal readonly bool IsValid()</a>
<a name="ln1345">        {</a>
<a name="ln1346">            var kingBitBoard = PieceBitBoards[(int)Piece.K + Utils.PieceOffset(Side)];</a>
<a name="ln1347">            var kingSquare = kingBitBoard == default ? -1 : kingBitBoard.GetLS1BIndex();</a>
<a name="ln1348"> </a>
<a name="ln1349">            var oppositeKingBitBoard = PieceBitBoards[(int)Piece.K + Utils.PieceOffset((Side)Utils.OppositeSide(Side))];</a>
<a name="ln1350">            var oppositeKingSquare = oppositeKingBitBoard == default ? -1 : oppositeKingBitBoard.GetLS1BIndex();</a>
<a name="ln1351"> </a>
<a name="ln1352">            return kingSquare &gt;= 0 &amp;&amp; oppositeKingSquare &gt;= 0</a>
<a name="ln1353">                &amp;&amp; !MakeMoveAttacks.IsSquaredAttacked(oppositeKingSquare, Side, PieceBitBoards, OccupancyBitBoards);</a>
<a name="ln1354">        }</a>
<a name="ln1355"> </a>
<a name="ln1356">        /// &lt;summary&gt;</a>
<a name="ln1357">        /// Lightweight version of &lt;see cref=&quot;IsValid&quot;/&gt;</a>
<a name="ln1358">        /// False if the opponent king is in check.</a>
<a name="ln1359">        /// This method is meant to be invoked only after &lt;see cref=&quot;Position.MakeMove(int)&quot;/&gt;</a>
<a name="ln1360">        /// &lt;/summary&gt;</a>
<a name="ln1361">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1362">        public readonly bool WasProduceByAValidMove()</a>
<a name="ln1363">        {</a>
<a name="ln1364">            var oppositeKingBitBoard = PieceBitBoards[(int)Piece.K + Utils.PieceOffset((Side)Utils.OppositeSide(Side))];</a>
<a name="ln1365">            var oppositeKingSquare = oppositeKingBitBoard == default ? -1 : oppositeKingBitBoard.GetLS1BIndex();</a>
<a name="ln1366"> </a>
<a name="ln1367">            return oppositeKingSquare &gt;= 0 &amp;&amp; !MakeMoveAttacks.IsSquaredAttacked(oppositeKingSquare, Side, PieceBitBoards, OccupancyBitBoards);</a>
<a name="ln1368">        }</a>
<a name="ln1369"> </a>
<a name="ln1370">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1371">        public readonly IEnumerable&lt;Move&gt; AllPossibleMoves(Move[]? movePool = null) =&gt; MakeMoveMoveGenerator.GenerateAllMoves(this, movePool);</a>
<a name="ln1372">    }</a>
<a name="ln1373"> </a>
<a name="ln1374">    public readonly struct MakeMoveGameState</a>
<a name="ln1375">    {</a>
<a name="ln1376">        public readonly int CapturedPiece;</a>
<a name="ln1377"> </a>
<a name="ln1378">        public readonly byte Castle;</a>
<a name="ln1379"> </a>
<a name="ln1380">        public readonly BoardSquare EnPassant;</a>
<a name="ln1381"> </a>
<a name="ln1382">        public MakeMoveGameState(int capturedPiece, byte castle, BoardSquare enpassant)</a>
<a name="ln1383">        {</a>
<a name="ln1384">            CapturedPiece = capturedPiece;</a>
<a name="ln1385">            Castle = castle;</a>
<a name="ln1386">            EnPassant = enpassant;</a>
<a name="ln1387">        }</a>
<a name="ln1388">    }</a>
<a name="ln1389"> </a>
<a name="ln1390">    public readonly struct MakeMoveGameStateWithZobristKey</a>
<a name="ln1391">    {</a>
<a name="ln1392">        public readonly ulong ZobristKey;</a>
<a name="ln1393"> </a>
<a name="ln1394">        public readonly int CapturedPiece;</a>
<a name="ln1395"> </a>
<a name="ln1396">        public readonly BoardSquare EnPassant;</a>
<a name="ln1397"> </a>
<a name="ln1398">        public readonly byte Castle;</a>
<a name="ln1399"> </a>
<a name="ln1400">        public MakeMoveGameStateWithZobristKey(int capturedPiece, byte castle, BoardSquare enpassant, ulong zobristKey)</a>
<a name="ln1401">        {</a>
<a name="ln1402">            CapturedPiece = capturedPiece;</a>
<a name="ln1403">            Castle = castle;</a>
<a name="ln1404">            EnPassant = enpassant;</a>
<a name="ln1405">            ZobristKey = zobristKey;</a>
<a name="ln1406">        }</a>
<a name="ln1407">    }</a>
<a name="ln1408"> </a>
<a name="ln1409">    #region</a>
<a name="ln1410"> </a>
<a name="ln1411">    public static class MakeMoveZobristTable</a>
<a name="ln1412">    {</a>
<a name="ln1413">        private static readonly ulong[,] _table = Initialize();</a>
<a name="ln1414"> </a>
<a name="ln1415">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1416">        public static ulong PieceHash(int boardSquare, int piece) =&gt; _table[boardSquare, piece];</a>
<a name="ln1417"> </a>
<a name="ln1418">        /// &lt;summary&gt;</a>
<a name="ln1419">        /// Uses &lt;see cref=&quot;Piece.P&quot;/&gt; and squares &lt;see cref=&quot;BoardSquare.a1&quot;/&gt;-&lt;see cref=&quot;BoardSquare.h1&quot;/&gt;</a>
<a name="ln1420">        /// &lt;/summary&gt;</a>
<a name="ln1421">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1422">        public static ulong EnPassantHash(int enPassantSquare)</a>
<a name="ln1423">        {</a>
<a name="ln1424">            if (enPassantSquare == (int)BoardSquare.noSquare)</a>
<a name="ln1425">            {</a>
<a name="ln1426">                return default;</a>
<a name="ln1427">            }</a>
<a name="ln1428"> </a>
<a name="ln1429">            var file = enPassantSquare % 8;</a>
<a name="ln1430"> </a>
<a name="ln1431">            return _table[file, (int)Piece.P];</a>
<a name="ln1432">        }</a>
<a name="ln1433"> </a>
<a name="ln1434">        /// &lt;summary&gt;</a>
<a name="ln1435">        /// Uses &lt;see cref=&quot;Piece.p&quot;/&gt; and &lt;see cref=&quot;BoardSquare.h8&quot;/&gt;</a>
<a name="ln1436">        /// &lt;/summary&gt;</a>
<a name="ln1437">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1438">        public static ulong SideHash()</a>
<a name="ln1439">        {</a>
<a name="ln1440">            return _table[(int)BoardSquare.h8, (int)Piece.p];</a>
<a name="ln1441">        }</a>
<a name="ln1442"> </a>
<a name="ln1443">        /// &lt;summary&gt;</a>
<a name="ln1444">        /// Uses &lt;see cref=&quot;Piece.p&quot;/&gt; and</a>
<a name="ln1445">        /// &lt;see cref=&quot;BoardSquare.a8&quot;/&gt; for &lt;see cref=&quot;CastlingRights.WK&quot;/&gt;, &lt;see cref=&quot;BoardSquare.b8&quot;/&gt; for &lt;see cref=&quot;CastlingRights.WQ&quot;/&gt;</a>
<a name="ln1446">        /// &lt;see cref=&quot;BoardSquare.c8&quot;/&gt; for &lt;see cref=&quot;CastlingRights.BK&quot;/&gt;, &lt;see cref=&quot;BoardSquare.d8&quot;/&gt; for &lt;see cref=&quot;CastlingRights.BQ&quot;/&gt;</a>
<a name="ln1447">        /// &lt;/summary&gt;</a>
<a name="ln1448">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1449">        public static ulong CastleHash(byte castle)</a>
<a name="ln1450">        {</a>
<a name="ln1451">            ulong combinedHash = 0;</a>
<a name="ln1452"> </a>
<a name="ln1453">            if ((castle &amp; (int)CastlingRights.WK) != default)</a>
<a name="ln1454">            {</a>
<a name="ln1455">                combinedHash ^= _table[(int)BoardSquare.a8, (int)Piece.p];        // a8</a>
<a name="ln1456">            }</a>
<a name="ln1457"> </a>
<a name="ln1458">            if ((castle &amp; (int)CastlingRights.WQ) != default)</a>
<a name="ln1459">            {</a>
<a name="ln1460">                combinedHash ^= _table[(int)BoardSquare.b8, (int)Piece.p];        // b8</a>
<a name="ln1461">            }</a>
<a name="ln1462"> </a>
<a name="ln1463">            if ((castle &amp; (int)CastlingRights.BK) != default)</a>
<a name="ln1464">            {</a>
<a name="ln1465">                combinedHash ^= _table[(int)BoardSquare.c8, (int)Piece.p];        // c8</a>
<a name="ln1466">            }</a>
<a name="ln1467"> </a>
<a name="ln1468">            if ((castle &amp; (int)CastlingRights.BQ) != default)</a>
<a name="ln1469">            {</a>
<a name="ln1470">                combinedHash ^= _table[(int)BoardSquare.d8, (int)Piece.p];        // d8</a>
<a name="ln1471">            }</a>
<a name="ln1472"> </a>
<a name="ln1473">            return combinedHash;</a>
<a name="ln1474">        }</a>
<a name="ln1475"> </a>
<a name="ln1476">        /// &lt;summary&gt;</a>
<a name="ln1477">        /// Calculates from scratch the hash of a position</a>
<a name="ln1478">        /// &lt;/summary&gt;</a>
<a name="ln1479">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1480">        public static ulong PositionHash(MakeMovePosition position)</a>
<a name="ln1481">        {</a>
<a name="ln1482">            ulong positionHash = 0;</a>
<a name="ln1483"> </a>
<a name="ln1484">            for (int squareIndex = 0; squareIndex &lt; 64; ++squareIndex)</a>
<a name="ln1485">            {</a>
<a name="ln1486">                for (int pieceIndex = 0; pieceIndex &lt; 12; ++pieceIndex)</a>
<a name="ln1487">                {</a>
<a name="ln1488">                    if (position.PieceBitBoards[pieceIndex].GetBit(squareIndex))</a>
<a name="ln1489">                    {</a>
<a name="ln1490">                        positionHash ^= PieceHash(squareIndex, pieceIndex);</a>
<a name="ln1491">                    }</a>
<a name="ln1492">                }</a>
<a name="ln1493">            }</a>
<a name="ln1494"> </a>
<a name="ln1495">            positionHash ^= EnPassantHash((int)position.EnPassant)</a>
<a name="ln1496">                ^ SideHash()</a>
<a name="ln1497">                ^ CastleHash(position.Castle);</a>
<a name="ln1498"> </a>
<a name="ln1499">            return positionHash;</a>
<a name="ln1500">        }</a>
<a name="ln1501"> </a>
<a name="ln1502">        /// &lt;summary&gt;</a>
<a name="ln1503">        /// Initializes Zobrist table (long[64, 12])</a>
<a name="ln1504">        /// &lt;/summary&gt;</a>
<a name="ln1505">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1506">        internal static ulong[,] Initialize()</a>
<a name="ln1507">        {</a>
<a name="ln1508">            var zobristTable = new ulong[64, 12];</a>
<a name="ln1509">            var randomInstance = new LynxRandom(int.MaxValue);</a>
<a name="ln1510"> </a>
<a name="ln1511">            for (int squareIndex = 0; squareIndex &lt; 64; ++squareIndex)</a>
<a name="ln1512">            {</a>
<a name="ln1513">                for (int pieceIndex = 0; pieceIndex &lt; 12; ++pieceIndex)</a>
<a name="ln1514">                {</a>
<a name="ln1515">                    zobristTable[squareIndex, pieceIndex] = randomInstance.NextUInt64();</a>
<a name="ln1516">                }</a>
<a name="ln1517">            }</a>
<a name="ln1518"> </a>
<a name="ln1519">            return zobristTable;</a>
<a name="ln1520">        }</a>
<a name="ln1521">    }</a>
<a name="ln1522"> </a>
<a name="ln1523">    public static class MakeMoveMoveGenerator</a>
<a name="ln1524">    {</a>
<a name="ln1525">        /// &lt;summary&gt;</a>
<a name="ln1526">        /// Indexed by &lt;see cref=&quot;Piece&quot;/&gt;.</a>
<a name="ln1527">        /// Checks are not considered</a>
<a name="ln1528">        /// &lt;/summary&gt;</a>
<a name="ln1529">        private static readonly Func&lt;int, BitBoard, BitBoard&gt;[] _pieceAttacks =</a>
<a name="ln1530">        [</a>
<a name="ln1531">            (int origin, BitBoard _) =&gt; MakeMoveAttacks.PawnAttacks[(int)Side.White][origin],</a>
<a name="ln1532">            (int origin, BitBoard _) =&gt; MakeMoveAttacks.KnightAttacks[origin],</a>
<a name="ln1533">            MakeMoveAttacks.BishopAttacks,</a>
<a name="ln1534">            MakeMoveAttacks.RookAttacks,</a>
<a name="ln1535">            MakeMoveAttacks.QueenAttacks,</a>
<a name="ln1536">            (int origin, BitBoard _) =&gt; MakeMoveAttacks.KingAttacks[origin],</a>
<a name="ln1537"> </a>
<a name="ln1538">            (int origin, BitBoard _) =&gt; MakeMoveAttacks.PawnAttacks[(int)Side.Black][origin],</a>
<a name="ln1539">            (int origin, BitBoard _) =&gt; MakeMoveAttacks.KnightAttacks[origin],</a>
<a name="ln1540">            MakeMoveAttacks.BishopAttacks,</a>
<a name="ln1541">            MakeMoveAttacks.RookAttacks,</a>
<a name="ln1542">            MakeMoveAttacks.QueenAttacks,</a>
<a name="ln1543">            (int origin, BitBoard _) =&gt; MakeMoveAttacks.KingAttacks[origin],</a>
<a name="ln1544">        ];</a>
<a name="ln1545"> </a>
<a name="ln1546">        /// &lt;summary&gt;</a>
<a name="ln1547">        /// Generates all psuedo-legal moves from &lt;paramref name=&quot;position&quot;/&gt;, ordered by &lt;see cref=&quot;Move.Score(Position)&quot;/&gt;</a>
<a name="ln1548">        /// &lt;/summary&gt;</a>
<a name="ln1549">        /// &lt;param name=&quot;capturesOnly&quot;&gt;Filters out all moves but captures&lt;/param&gt;</a>
<a name="ln1550">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1551">        public static IEnumerable&lt;Move&gt; GenerateAllMoves(MakeMovePosition position, Move[]? movePool = null, bool capturesOnly = false)</a>
<a name="ln1552">        {</a>
<a name="ln1553">            movePool ??= new Move[Constants.MaxNumberOfPossibleMovesInAPosition];</a>
<a name="ln1554">            int localIndex = 0;</a>
<a name="ln1555"> </a>
<a name="ln1556">            var offset = Utils.PieceOffset(position.Side);</a>
<a name="ln1557"> </a>
<a name="ln1558">            GeneratePawnMoves(ref localIndex, movePool, position, offset, capturesOnly);</a>
<a name="ln1559">            GenerateCastlingMoves(ref localIndex, movePool, position, offset);</a>
<a name="ln1560">            GeneratePieceMoves(ref localIndex, movePool, (int)Piece.K + offset, position, capturesOnly);</a>
<a name="ln1561">            GeneratePieceMoves(ref localIndex, movePool, (int)Piece.N + offset, position, capturesOnly);</a>
<a name="ln1562">            GeneratePieceMoves(ref localIndex, movePool, (int)Piece.B + offset, position, capturesOnly);</a>
<a name="ln1563">            GeneratePieceMoves(ref localIndex, movePool, (int)Piece.R + offset, position, capturesOnly);</a>
<a name="ln1564">            GeneratePieceMoves(ref localIndex, movePool, (int)Piece.Q + offset, position, capturesOnly);</a>
<a name="ln1565"> </a>
<a name="ln1566">            return movePool.Take(localIndex);</a>
<a name="ln1567">        }</a>
<a name="ln1568"> </a>
<a name="ln1569">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1570">        internal static void GeneratePawnMoves(ref int localIndex, Move[] movePool, MakeMovePosition position, int offset, bool capturesOnly = false)</a>
<a name="ln1571">        {</a>
<a name="ln1572">            int sourceSquare, targetSquare;</a>
<a name="ln1573"> </a>
<a name="ln1574">            var piece = (int)Piece.P + offset;</a>
<a name="ln1575">            var pawnPush = +8 - ((int)position.Side * 16);          // position.Side == Side.White ? -8 : +8</a>
<a name="ln1576">            int oppositeSide = Utils.OppositeSide(position.Side);   // position.Side == Side.White ? (int)Side.Black : (int)Side.White</a>
<a name="ln1577">            var bitboard = position.PieceBitBoards[piece];</a>
<a name="ln1578"> </a>
<a name="ln1579">            while (bitboard != default)</a>
<a name="ln1580">            {</a>
<a name="ln1581">                sourceSquare = bitboard.GetLS1BIndex();</a>
<a name="ln1582">                bitboard.ResetLS1B();</a>
<a name="ln1583"> </a>
<a name="ln1584">                var sourceRank = (sourceSquare / 8) + 1;</a>
<a name="ln1585"> </a>
<a name="ln1586">                // Pawn pushes</a>
<a name="ln1587">                var singlePushSquare = sourceSquare + pawnPush;</a>
<a name="ln1588">                if (!position.OccupancyBitBoards[2].GetBit(singlePushSquare))</a>
<a name="ln1589">                {</a>
<a name="ln1590">                    // Single pawn push</a>
<a name="ln1591">                    var targetRank = (singlePushSquare / 8) + 1;</a>
<a name="ln1592">                    if (targetRank == 1 || targetRank == 8)  // Promotion</a>
<a name="ln1593">                    {</a>
<a name="ln1594">                        movePool[localIndex++] = MoveExtensions.EncodePromotion(sourceSquare, singlePushSquare, piece, promotedPiece: (int)Piece.Q + offset);</a>
<a name="ln1595">                        movePool[localIndex++] = MoveExtensions.EncodePromotion(sourceSquare, singlePushSquare, piece, promotedPiece: (int)Piece.R + offset);</a>
<a name="ln1596">                        movePool[localIndex++] = MoveExtensions.EncodePromotion(sourceSquare, singlePushSquare, piece, promotedPiece: (int)Piece.N + offset);</a>
<a name="ln1597">                        movePool[localIndex++] = MoveExtensions.EncodePromotion(sourceSquare, singlePushSquare, piece, promotedPiece: (int)Piece.B + offset);</a>
<a name="ln1598">                    }</a>
<a name="ln1599">                    else if (!capturesOnly)</a>
<a name="ln1600">                    {</a>
<a name="ln1601">                        movePool[localIndex++] = MoveExtensions.Encode(sourceSquare, singlePushSquare, piece);</a>
<a name="ln1602">                    }</a>
<a name="ln1603"> </a>
<a name="ln1604">                    // Double pawn push</a>
<a name="ln1605">                    // Inside of the if because singlePush square cannot be occupied either</a>
<a name="ln1606">                    if (!capturesOnly)</a>
<a name="ln1607">                    {</a>
<a name="ln1608">                        var doublePushSquare = sourceSquare + (2 * pawnPush);</a>
<a name="ln1609">                        if (!position.OccupancyBitBoards[2].GetBit(doublePushSquare)</a>
<a name="ln1610">                            &amp;&amp; ((sourceRank == 2 &amp;&amp; position.Side == Side.Black) || (sourceRank == 7 &amp;&amp; position.Side == Side.White)))</a>
<a name="ln1611">                        {</a>
<a name="ln1612">                            movePool[localIndex++] = MoveExtensions.EncodeDoublePawnPush(sourceSquare, doublePushSquare, piece);</a>
<a name="ln1613">                        }</a>
<a name="ln1614">                    }</a>
<a name="ln1615">                }</a>
<a name="ln1616"> </a>
<a name="ln1617">                var attacks = MakeMoveAttacks.PawnAttacks[(int)position.Side][sourceSquare];</a>
<a name="ln1618"> </a>
<a name="ln1619">                // En passant</a>
<a name="ln1620">                if (position.EnPassant != BoardSquare.noSquare &amp;&amp; attacks.GetBit(position.EnPassant))</a>
<a name="ln1621">                // We assume that position.OccupancyBitBoards[oppositeOccupancy].GetBit(targetSquare + singlePush) == true</a>
<a name="ln1622">                {</a>
<a name="ln1623">                    movePool[localIndex++] = MoveExtensions.EncodeEnPassant(sourceSquare, (int)position.EnPassant, piece);</a>
<a name="ln1624">                }</a>
<a name="ln1625"> </a>
<a name="ln1626">                // Captures</a>
<a name="ln1627">                var attackedSquares = attacks &amp; position.OccupancyBitBoards[oppositeSide];</a>
<a name="ln1628">                while (attackedSquares != default)</a>
<a name="ln1629">                {</a>
<a name="ln1630">                    targetSquare = attackedSquares.GetLS1BIndex();</a>
<a name="ln1631">                    attackedSquares.ResetLS1B();</a>
<a name="ln1632"> </a>
<a name="ln1633">                    var targetRank = (targetSquare / 8) + 1;</a>
<a name="ln1634">                    if (targetRank == 1 || targetRank == 8)  // Capture with promotion</a>
<a name="ln1635">                    {</a>
<a name="ln1636">                        movePool[localIndex++] = MoveExtensions.EncodePromotion(sourceSquare, targetSquare, piece, promotedPiece: (int)Piece.Q + offset);</a>
<a name="ln1637">                        movePool[localIndex++] = MoveExtensions.EncodePromotion(sourceSquare, targetSquare, piece, promotedPiece: (int)Piece.R + offset);</a>
<a name="ln1638">                        movePool[localIndex++] = MoveExtensions.EncodePromotion(sourceSquare, targetSquare, piece, promotedPiece: (int)Piece.N + offset);</a>
<a name="ln1639">                        movePool[localIndex++] = MoveExtensions.EncodePromotion(sourceSquare, targetSquare, piece, promotedPiece: (int)Piece.B + offset);</a>
<a name="ln1640">                    }</a>
<a name="ln1641">                    else</a>
<a name="ln1642">                    {</a>
<a name="ln1643">                        movePool[localIndex++] = MoveExtensions.EncodeCapture(sourceSquare, targetSquare, piece, position.Board[targetSquare]);</a>
<a name="ln1644">                    }</a>
<a name="ln1645">                }</a>
<a name="ln1646">            }</a>
<a name="ln1647">        }</a>
<a name="ln1648"> </a>
<a name="ln1649">        /// &lt;summary&gt;</a>
<a name="ln1650">        /// Obvious moves that put the king in check have been discarded, but the rest still need to be discarded</a>
<a name="ln1651">        /// see FEN position &quot;8/8/8/2bbb3/2bKb3/2bbb3/8/8 w - - 0 1&quot;, where 4 legal moves (corners) are found</a>
<a name="ln1652">        /// &lt;/summary&gt;</a>
<a name="ln1653">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1654">        internal static void GenerateCastlingMoves(ref int localIndex, Move[] movePool, MakeMovePosition position, int offset)</a>
<a name="ln1655">        {</a>
<a name="ln1656">            var piece = (int)Piece.K + offset;</a>
<a name="ln1657">            var oppositeSide = (Side)Utils.OppositeSide(position.Side);</a>
<a name="ln1658"> </a>
<a name="ln1659">            int sourceSquare = position.PieceBitBoards[piece].GetLS1BIndex(); // There's for sure only one</a>
<a name="ln1660"> </a>
<a name="ln1661">            // Castles</a>
<a name="ln1662">            if (position.Castle != default)</a>
<a name="ln1663">            {</a>
<a name="ln1664">                if (position.Side == Side.White)</a>
<a name="ln1665">                {</a>
<a name="ln1666">                    bool ise1Attacked = MakeMoveAttacks.IsSquaredAttackedBySide((int)BoardSquare.e1, position, oppositeSide);</a>
<a name="ln1667">                    if (((position.Castle &amp; (int)CastlingRights.WK) != default)</a>
<a name="ln1668">                        &amp;&amp; !position.OccupancyBitBoards[(int)Side.Both].GetBit(BoardSquare.f1)</a>
<a name="ln1669">                        &amp;&amp; !position.OccupancyBitBoards[(int)Side.Both].GetBit(BoardSquare.g1)</a>
<a name="ln1670">                        &amp;&amp; !ise1Attacked</a>
<a name="ln1671">                        &amp;&amp; !MakeMoveAttacks.IsSquaredAttackedBySide((int)BoardSquare.f1, position, oppositeSide)</a>
<a name="ln1672">                        &amp;&amp; !MakeMoveAttacks.IsSquaredAttackedBySide((int)BoardSquare.g1, position, oppositeSide))</a>
<a name="ln1673">                    {</a>
<a name="ln1674">                        movePool[localIndex++] = MoveExtensions.EncodeShortCastle(sourceSquare, Constants.WhiteShortCastleKingSquare, piece);</a>
<a name="ln1675">                    }</a>
<a name="ln1676"> </a>
<a name="ln1677">                    if (((position.Castle &amp; (int)CastlingRights.WQ) != default)</a>
<a name="ln1678">                        &amp;&amp; !position.OccupancyBitBoards[(int)Side.Both].GetBit(BoardSquare.d1)</a>
<a name="ln1679">                        &amp;&amp; !position.OccupancyBitBoards[(int)Side.Both].GetBit(BoardSquare.c1)</a>
<a name="ln1680">                        &amp;&amp; !position.OccupancyBitBoards[(int)Side.Both].GetBit(BoardSquare.b1)</a>
<a name="ln1681">                        &amp;&amp; !ise1Attacked</a>
<a name="ln1682">                        &amp;&amp; !MakeMoveAttacks.IsSquaredAttackedBySide((int)BoardSquare.d1, position, oppositeSide)</a>
<a name="ln1683">                        &amp;&amp; !MakeMoveAttacks.IsSquaredAttackedBySide((int)BoardSquare.c1, position, oppositeSide))</a>
<a name="ln1684">                    {</a>
<a name="ln1685">                        movePool[localIndex++] = MoveExtensions.EncodeLongCastle(sourceSquare, Constants.WhiteLongCastleKingSquare, piece);</a>
<a name="ln1686">                    }</a>
<a name="ln1687">                }</a>
<a name="ln1688">                else</a>
<a name="ln1689">                {</a>
<a name="ln1690">                    bool ise8Attacked = MakeMoveAttacks.IsSquaredAttackedBySide((int)BoardSquare.e8, position, oppositeSide);</a>
<a name="ln1691">                    if (((position.Castle &amp; (int)CastlingRights.BK) != default)</a>
<a name="ln1692">                        &amp;&amp; !position.OccupancyBitBoards[(int)Side.Both].GetBit(BoardSquare.f8)</a>
<a name="ln1693">                        &amp;&amp; !position.OccupancyBitBoards[(int)Side.Both].GetBit(BoardSquare.g8)</a>
<a name="ln1694">                        &amp;&amp; !ise8Attacked</a>
<a name="ln1695">                        &amp;&amp; !MakeMoveAttacks.IsSquaredAttackedBySide((int)BoardSquare.f8, position, oppositeSide)</a>
<a name="ln1696">                        &amp;&amp; !MakeMoveAttacks.IsSquaredAttackedBySide((int)BoardSquare.g8, position, oppositeSide))</a>
<a name="ln1697">                    {</a>
<a name="ln1698">                        movePool[localIndex++] = MoveExtensions.EncodeShortCastle(sourceSquare, Constants.BlackShortCastleKingSquare, piece);</a>
<a name="ln1699">                    }</a>
<a name="ln1700"> </a>
<a name="ln1701">                    if (((position.Castle &amp; (int)CastlingRights.BQ) != default)</a>
<a name="ln1702">                        &amp;&amp; !position.OccupancyBitBoards[(int)Side.Both].GetBit(BoardSquare.d8)</a>
<a name="ln1703">                        &amp;&amp; !position.OccupancyBitBoards[(int)Side.Both].GetBit(BoardSquare.c8)</a>
<a name="ln1704">                        &amp;&amp; !position.OccupancyBitBoards[(int)Side.Both].GetBit(BoardSquare.b8)</a>
<a name="ln1705">                        &amp;&amp; !ise8Attacked</a>
<a name="ln1706">                        &amp;&amp; !MakeMoveAttacks.IsSquaredAttackedBySide((int)BoardSquare.d8, position, oppositeSide)</a>
<a name="ln1707">                        &amp;&amp; !MakeMoveAttacks.IsSquaredAttackedBySide((int)BoardSquare.c8, position, oppositeSide))</a>
<a name="ln1708">                    {</a>
<a name="ln1709">                        movePool[localIndex++] = MoveExtensions.EncodeLongCastle(sourceSquare, Constants.BlackLongCastleKingSquare, piece);</a>
<a name="ln1710">                    }</a>
<a name="ln1711">                }</a>
<a name="ln1712">            }</a>
<a name="ln1713">        }</a>
<a name="ln1714"> </a>
<a name="ln1715">        /// &lt;summary&gt;</a>
<a name="ln1716">        /// Generate Knight, Bishop, Rook and Queen moves</a>
<a name="ln1717">        /// &lt;/summary&gt;</a>
<a name="ln1718">        /// &lt;param name=&quot;piece&quot;&gt;&lt;see cref=&quot;Piece&quot;/&gt;&lt;/param&gt;</a>
<a name="ln1719">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1720">        internal static void GeneratePieceMoves(ref int localIndex, Move[] movePool, int piece, MakeMovePosition position, bool capturesOnly = false)</a>
<a name="ln1721">        {</a>
<a name="ln1722">            var bitboard = position.PieceBitBoards[piece];</a>
<a name="ln1723">            int sourceSquare, targetSquare;</a>
<a name="ln1724"> </a>
<a name="ln1725">            while (bitboard != default)</a>
<a name="ln1726">            {</a>
<a name="ln1727">                sourceSquare = bitboard.GetLS1BIndex();</a>
<a name="ln1728">                bitboard.ResetLS1B();</a>
<a name="ln1729"> </a>
<a name="ln1730">                var attacks = _pieceAttacks[piece](sourceSquare, position.OccupancyBitBoards[(int)Side.Both])</a>
<a name="ln1731">                    &amp; ~position.OccupancyBitBoards[(int)position.Side];</a>
<a name="ln1732"> </a>
<a name="ln1733">                while (attacks != default)</a>
<a name="ln1734">                {</a>
<a name="ln1735">                    targetSquare = attacks.GetLS1BIndex();</a>
<a name="ln1736">                    attacks.ResetLS1B();</a>
<a name="ln1737"> </a>
<a name="ln1738">                    if (position.OccupancyBitBoards[(int)Side.Both].GetBit(targetSquare))</a>
<a name="ln1739">                    {</a>
<a name="ln1740">                        movePool[localIndex++] = MoveExtensions.EncodeCapture(sourceSquare, targetSquare, piece, capturedPiece: 1);</a>
<a name="ln1741">                    }</a>
<a name="ln1742">                    else if (!capturesOnly)</a>
<a name="ln1743">                    {</a>
<a name="ln1744">                        movePool[localIndex++] = MoveExtensions.Encode(sourceSquare, targetSquare, piece);</a>
<a name="ln1745">                    }</a>
<a name="ln1746">                }</a>
<a name="ln1747">            }</a>
<a name="ln1748">        }</a>
<a name="ln1749">    }</a>
<a name="ln1750"> </a>
<a name="ln1751">    public static class MakeMoveAttacks</a>
<a name="ln1752">    {</a>
<a name="ln1753">        private static readonly BitBoard[] _bishopOccupancyMasks;</a>
<a name="ln1754">        private static readonly BitBoard[] _rookOccupancyMasks;</a>
<a name="ln1755"> </a>
<a name="ln1756">        /// &lt;summary&gt;</a>
<a name="ln1757">        /// [64 (Squares), 512 (Occupancies)]</a>
<a name="ln1758">        /// Use &lt;see cref=&quot;BishopAttacks(int, BitBoard)&quot;/&gt;</a>
<a name="ln1759">        /// &lt;/summary&gt;</a>
<a name="ln1760">        private static readonly BitBoard[][] _bishopAttacks;</a>
<a name="ln1761"> </a>
<a name="ln1762">        /// &lt;summary&gt;</a>
<a name="ln1763">        /// [64 (Squares), 4096 (Occupancies)]</a>
<a name="ln1764">        /// Use &lt;see cref=&quot;RookAttacks(int, BitBoard)&quot;/&gt;</a>
<a name="ln1765">        /// &lt;/summary&gt;</a>
<a name="ln1766">        private static readonly BitBoard[][] _rookAttacks;</a>
<a name="ln1767"> </a>
<a name="ln1768">        /// &lt;summary&gt;</a>
<a name="ln1769">        /// [2 (B|W), 64 (Squares)]</a>
<a name="ln1770">        /// &lt;/summary&gt;</a>
<a name="ln1771">        public static BitBoard[][] PawnAttacks { get; }</a>
<a name="ln1772">        public static BitBoard[] KnightAttacks { get; }</a>
<a name="ln1773">        public static BitBoard[] KingAttacks { get; }</a>
<a name="ln1774"> </a>
<a name="ln1775">        static MakeMoveAttacks()</a>
<a name="ln1776">        {</a>
<a name="ln1777">            KingAttacks = AttackGenerator.InitializeKingAttacks();</a>
<a name="ln1778">            PawnAttacks = AttackGenerator.InitializePawnAttacks();</a>
<a name="ln1779">            KnightAttacks = AttackGenerator.InitializeKnightAttacks();</a>
<a name="ln1780"> </a>
<a name="ln1781">            (_bishopOccupancyMasks, _bishopAttacks) = AttackGenerator.InitializeBishopMagicAttacks();</a>
<a name="ln1782">            (_rookOccupancyMasks, _rookAttacks) = AttackGenerator.InitializeRookMagicAttacks();</a>
<a name="ln1783">        }</a>
<a name="ln1784"> </a>
<a name="ln1785">        /// &lt;summary&gt;</a>
<a name="ln1786">        /// Get Bishop attacks assuming current board occupancy</a>
<a name="ln1787">        /// &lt;/summary&gt;</a>
<a name="ln1788">        /// &lt;param name=&quot;occupancy&quot;&gt;Occupancy of &lt;see cref=&quot;Side.Both&quot;/&gt;&lt;/param&gt;</a>
<a name="ln1789">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1790">        public static BitBoard BishopAttacks(int squareIndex, BitBoard occupancy)</a>
<a name="ln1791">        {</a>
<a name="ln1792">            var occ = occupancy &amp; _bishopOccupancyMasks[squareIndex];</a>
<a name="ln1793">            occ *= Constants.BishopMagicNumbers[squareIndex];</a>
<a name="ln1794">            occ &gt;&gt;= (64 - Constants.BishopRelevantOccupancyBits[squareIndex]);</a>
<a name="ln1795"> </a>
<a name="ln1796">            return _bishopAttacks[squareIndex][occ];</a>
<a name="ln1797">        }</a>
<a name="ln1798"> </a>
<a name="ln1799">        /// &lt;summary&gt;</a>
<a name="ln1800">        /// Get Rook attacks assuming current board occupancy</a>
<a name="ln1801">        /// &lt;/summary&gt;</a>
<a name="ln1802">        /// &lt;param name=&quot;occupancy&quot;&gt;Occupancy of &lt;see cref=&quot;Side.Both&quot;/&gt;&lt;/param&gt;</a>
<a name="ln1803">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1804">        public static BitBoard RookAttacks(int squareIndex, BitBoard occupancy)</a>
<a name="ln1805">        {</a>
<a name="ln1806">            var occ = occupancy &amp; _rookOccupancyMasks[squareIndex];</a>
<a name="ln1807">            occ *= Constants.RookMagicNumbers[squareIndex];</a>
<a name="ln1808">            occ &gt;&gt;= (64 - Constants.RookRelevantOccupancyBits[squareIndex]);</a>
<a name="ln1809"> </a>
<a name="ln1810">            return _rookAttacks[squareIndex][occ];</a>
<a name="ln1811">        }</a>
<a name="ln1812"> </a>
<a name="ln1813">        /// &lt;summary&gt;</a>
<a name="ln1814">        /// Get Queen attacks assuming current board occupancy</a>
<a name="ln1815">        /// Use &lt;see cref=&quot;QueenAttacks(BitBoard, BitBoard)&quot;/&gt; if rook and bishop attacks are already calculated</a>
<a name="ln1816">        /// &lt;/summary&gt;</a>
<a name="ln1817">        /// &lt;param name=&quot;occupancy&quot;&gt;Occupancy of &lt;see cref=&quot;Side.Both&quot;/&gt;&lt;/param&gt;</a>
<a name="ln1818">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1819">        public static BitBoard QueenAttacks(int squareIndex, BitBoard occupancy)</a>
<a name="ln1820">        {</a>
<a name="ln1821">            return QueenAttacks(</a>
<a name="ln1822">                RookAttacks(squareIndex, occupancy),</a>
<a name="ln1823">                BishopAttacks(squareIndex, occupancy));</a>
<a name="ln1824">        }</a>
<a name="ln1825"> </a>
<a name="ln1826">        /// &lt;summary&gt;</a>
<a name="ln1827">        /// Get Queen attacks having rook and bishop attacks pre-calculated</a>
<a name="ln1828">        /// &lt;/summary&gt;</a>
<a name="ln1829">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1830">        public static BitBoard QueenAttacks(BitBoard rookAttacks, BitBoard bishopAttacks)</a>
<a name="ln1831">        {</a>
<a name="ln1832">            return rookAttacks | bishopAttacks;</a>
<a name="ln1833">        }</a>
<a name="ln1834"> </a>
<a name="ln1835">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1836">        public static bool IsSquaredAttackedBySide(int squaredIndex, MakeMovePosition position, Side sideToMove) =&gt;</a>
<a name="ln1837">            IsSquaredAttacked(squaredIndex, sideToMove, position.PieceBitBoards, position.OccupancyBitBoards);</a>
<a name="ln1838"> </a>
<a name="ln1839">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1840">        public static bool IsSquaredAttacked(int squareIndex, Side sideToMove, BitBoard[] piecePosition, BitBoard[] occupancy)</a>
<a name="ln1841">        {</a>
<a name="ln1842">            Utils.Assert(sideToMove != Side.Both);</a>
<a name="ln1843"> </a>
<a name="ln1844">            var offset = Utils.PieceOffset(sideToMove);</a>
<a name="ln1845"> </a>
<a name="ln1846">            // I tried to order them from most to least likely</a>
<a name="ln1847">            return</a>
<a name="ln1848">                IsSquareAttackedByPawns(squareIndex, sideToMove, offset, piecePosition)</a>
<a name="ln1849">                || IsSquareAttackedByKnights(squareIndex, offset, piecePosition)</a>
<a name="ln1850">                || IsSquareAttackedByBishops(squareIndex, offset, piecePosition, occupancy, out var bishopAttacks)</a>
<a name="ln1851">                || IsSquareAttackedByRooks(squareIndex, offset, piecePosition, occupancy, out var rookAttacks)</a>
<a name="ln1852">                || IsSquareAttackedByQueens(offset, bishopAttacks, rookAttacks, piecePosition)</a>
<a name="ln1853">                || IsSquareAttackedByKing(squareIndex, offset, piecePosition);</a>
<a name="ln1854">        }</a>
<a name="ln1855"> </a>
<a name="ln1856">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1857">        public static bool IsSquareInCheck(int squareIndex, Side sideToMove, BitBoard[] piecePosition, BitBoard[] occupancy)</a>
<a name="ln1858">        {</a>
<a name="ln1859">            Utils.Assert(sideToMove != Side.Both);</a>
<a name="ln1860"> </a>
<a name="ln1861">            var offset = Utils.PieceOffset(sideToMove);</a>
<a name="ln1862"> </a>
<a name="ln1863">            // I tried to order them from most to least likely</a>
<a name="ln1864">            return</a>
<a name="ln1865">                IsSquareAttackedByRooks(squareIndex, offset, piecePosition, occupancy, out var rookAttacks)</a>
<a name="ln1866">                || IsSquareAttackedByBishops(squareIndex, offset, piecePosition, occupancy, out var bishopAttacks)</a>
<a name="ln1867">                || IsSquareAttackedByQueens(offset, bishopAttacks, rookAttacks, piecePosition)</a>
<a name="ln1868">                || IsSquareAttackedByKnights(squareIndex, offset, piecePosition)</a>
<a name="ln1869">                || IsSquareAttackedByPawns(squareIndex, sideToMove, offset, piecePosition);</a>
<a name="ln1870">        }</a>
<a name="ln1871"> </a>
<a name="ln1872">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1873">        private static bool IsSquareAttackedByPawns(int squareIndex, Side sideToMove, int offset, BitBoard[] pieces)</a>
<a name="ln1874">        {</a>
<a name="ln1875">            var oppositeColorIndex = ((int)sideToMove + 1) % 2;</a>
<a name="ln1876"> </a>
<a name="ln1877">            return (PawnAttacks[oppositeColorIndex][squareIndex] &amp; pieces[offset]) != default;</a>
<a name="ln1878">        }</a>
<a name="ln1879"> </a>
<a name="ln1880">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1881">        private static bool IsSquareAttackedByKnights(int squareIndex, int offset, BitBoard[] piecePosition)</a>
<a name="ln1882">        {</a>
<a name="ln1883">            return (KnightAttacks[squareIndex] &amp; piecePosition[(int)Piece.N + offset]) != default;</a>
<a name="ln1884">        }</a>
<a name="ln1885"> </a>
<a name="ln1886">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1887">        private static bool IsSquareAttackedByKing(int squareIndex, int offset, BitBoard[] piecePosition)</a>
<a name="ln1888">        {</a>
<a name="ln1889">            return (KingAttacks[squareIndex] &amp; piecePosition[(int)Piece.K + offset]) != default;</a>
<a name="ln1890">        }</a>
<a name="ln1891"> </a>
<a name="ln1892">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1893">        private static bool IsSquareAttackedByBishops(int squareIndex, int offset, BitBoard[] piecePosition, BitBoard[] occupancy, out BitBoard bishopAttacks)</a>
<a name="ln1894">        {</a>
<a name="ln1895">            bishopAttacks = BishopAttacks(squareIndex, occupancy[(int)Side.Both]);</a>
<a name="ln1896">            return (bishopAttacks &amp; piecePosition[(int)Piece.B + offset]) != default;</a>
<a name="ln1897">        }</a>
<a name="ln1898"> </a>
<a name="ln1899">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1900">        private static bool IsSquareAttackedByRooks(int squareIndex, int offset, BitBoard[] piecePosition, BitBoard[] occupancy, out BitBoard rookAttacks)</a>
<a name="ln1901">        {</a>
<a name="ln1902">            rookAttacks = RookAttacks(squareIndex, occupancy[(int)Side.Both]);</a>
<a name="ln1903">            return (rookAttacks &amp; piecePosition[(int)Piece.R + offset]) != default;</a>
<a name="ln1904">        }</a>
<a name="ln1905"> </a>
<a name="ln1906">        [MethodImpl(MethodImplOptions.AggressiveInlining)]</a>
<a name="ln1907">        private static bool IsSquareAttackedByQueens(int offset, BitBoard bishopAttacks, BitBoard rookAttacks, BitBoard[] piecePosition)</a>
<a name="ln1908">        {</a>
<a name="ln1909">            var queenAttacks = QueenAttacks(rookAttacks, bishopAttacks);</a>
<a name="ln1910">            return (queenAttacks &amp; piecePosition[(int)Piece.Q + offset]) != default;</a>
<a name="ln1911">        }</a>
<a name="ln1912">    }</a>
<a name="ln1913"> </a>
<a name="ln1914">    #endregion</a>
<a name="ln1915">}</a>
<a name="ln1916"> </a>
<a name="ln1917">#pragma warning restore S101, S1854 // Types should be named in PascalCase</a>
</code></pre>
<div class="balloon" rel="1251"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3002/" target="_blank">V3002</a> The switch statement does not cover all values of the 'SpecialMoveType' enum: DoublePawnPush.</p></div>
<div class="balloon" rel="352"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3117/" target="_blank">V3117</a> Constructor parameter 'nullMove' is not used.</p></div>
<div class="balloon" rel="1579"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3150/" target="_blank">V3150</a> Loop break conditions do not depend on the number of iterations.</p></div>
<div class="balloon" rel="1628"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3150/" target="_blank">V3150</a> Loop break conditions do not depend on the number of iterations.</p></div>
<div class="balloon" rel="1725"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3150/" target="_blank">V3150</a> Loop break conditions do not depend on the number of iterations.</p></div>
<div class="balloon" rel="1733"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v3150/" target="_blank">V3150</a> Loop break conditions do not depend on the number of iterations.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>